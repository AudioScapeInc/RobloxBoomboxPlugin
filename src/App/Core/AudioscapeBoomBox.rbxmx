<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBX4477d26ac5cc4f8581c1bff6a0c9880e">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">AudioscapeBoomBox</string>
			<string name="ScriptGuid">{c7ddc03d-df31-441e-8296-1189d757e294}</string>
			<ProtectedString name="Source"><![CDATA[--// Services
local HttpService = game:GetService("HttpService") -- Service for HTTP requests and JSON encoding/decoding
local Players = game:GetService("Players") -- Service for player management
local ReplicatedStorage = game:GetService("ReplicatedStorage") -- Storage for objects that need to be accessible by both client and server
local RunService = game:GetService("RunService") -- Service to handle game loop and execution of code based on environment
local AssetService = game:GetService("AssetService") -- Service to retrieve asset metadata, particularly audio assets

-- Exit if running on the client side
if RunService:IsClient() then
	return {}
end

--// Types
-- Type definition for Roblox audio metadata
type RobloxAudioMetadata = {
	Artist: string, -- The artist of the audio track
	AssetId: string, -- The unique ID of the audio asset
	AudioType: string, -- Type of the audio (e.g., music, sound effect)
	Duration: number, -- Duration of the audio in seconds
	Title: string, -- Title of the audio track
}

--// Telemetry
local Events = require(script.Server.Events) -- Module to handle server events and telemetry

--// Boombox Class
local BoomBox = {}
BoomBox.__index = BoomBox

-- Constructor for the BoomBox class
function BoomBox.new()
	local self = setmetatable({}, BoomBox)
	return self
end

-- Function to restructure the Roblox audio metadata into a format expected by the boombox system
-- @param Songs: Table of RobloxAudioMetadata - List of audio metadata to restructure
-- @param Fade: Number or nil - Fade duration to be applied to the first song
-- @return: JSON encoded string of the restructured song metadata
function BoomBox:RestructureFromRobloxMetaData(Songs: { RobloxAudioMetadata }, Fade)
	local RestructuredSongMetaData = {}

	for _, Song in ipairs(Songs) do
		table.insert(RestructuredSongMetaData, {
			asset_id = Song.AssetId, -- Asset ID of the song
			asset_audioDetails_title = Song.Title, -- Title of the song
			asset_audioDetails_musicAlbum = Song.Artist, -- Artist of the song
			asset_audioDetails_musicGenre = "Unknown", -- Music genre, set to unknown as a default

			Fade = _ == 1 and Fade or nil, -- Apply fade to the first song only
		})
	end

	return HttpService:JSONEncode(RestructuredSongMetaData) -- Convert the table to JSON
end

-- Function to push songs to the boombox queue for players
-- @param Info: Table containing details about the songs to be queued and player information
function BoomBox:PushToQueue(
	Info: {
		Players: { Player }?, -- Optional list of players to push the queue to
		AssetIDs: { number }, -- List of asset IDs of the songs to queue
		PlayNow: boolean, -- Whether to play the songs immediately
		ClearQueue: boolean, -- Whether to clear the existing queue
		Fade: number?, -- Optional fade duration for the first song
	}
)
	local AssetIds = Info.AssetIDs

	if type(AssetIds) == "number" then
		AssetIds = { AssetIds } -- Convert single asset ID to a table
	end

	-- Restructure the audio metadata for use in the boombox system
	local RobloxAudioMetadata =
		self:RestructureFromRobloxMetaData(AssetService:GetAudioMetadataAsync(AssetIds), Info.Fade)
	local AudioScapeAudioMetadata

	-- Spawn a task to get additional audio metadata via telemetry
	task.spawn(function()
		AudioScapeAudioMetadata = Events.ServerTelemetry:Invoke(nil, "details", AssetIds)
	end)

	-- For each player, create a RemoteFunction to fill metadata and invoke client functions
	for _, Player in Info.Players or Players:GetPlayers() do
		task.spawn(function()
			local RequestMetadataFill = Instance.new("RemoteFunction")
			RequestMetadataFill.Name = "BoomboxPothole" .. HttpService:GenerateGUID()
			RequestMetadataFill.Parent = ReplicatedStorage
			RequestMetadataFill.OnServerInvoke = function()
				repeat
					task.wait()
				until AudioScapeAudioMetadata -- Wait until additional metadata is available

				task.delay(1, function()
					RequestMetadataFill:Destroy() -- Destroy the RemoteFunction after use
				end)

				return AudioScapeAudioMetadata -- Return the metadata to the client
			end
			local Test = Events.HeadlessFunctions:InvokeClient(Player, RobloxAudioMetadata, RequestMetadataFill, Info)
		end)
	end
end

-- Function to adjust the volume for specific players or all players
-- @param Info: Table containing player information and the volume level
function BoomBox:AdjustVolume(
	Info: {
		Players: { Player }?, -- Optional list of players to adjust the volume for
		Volume: number, -- The volume level to set
	}
)
	assert(Info.Volume, "Volume is required") -- Ensure the volume is provided

	if Info.Players then
		for _, Player in Info.Players do
			Events.HeadlessEvents:FireClient(Player, "AdjustVolume", Info.Volume) -- Adjust volume for specific players
		end
	else
		Events.HeadlessEvents:FireAllClients("AdjustVolume", Info) -- Adjust volume for all players
	end
end

-- Function to adjust the maximum volume for specific players or all players
-- @param Info: Table containing player information and the maximum volume level
function BoomBox:AdjustMaxVolume(
	Info: {
		Players: { Player }?, -- Optional list of players to adjust the max volume for
		MaxVolume: number, -- The maximum volume level to set
	}
)
	assert(Info.MaxVolume, "MaxVolume is required") -- Ensure the maximum volume is provided

	if Info.Players then
		for _, Player in Info.Players do
			Events.HeadlessEvents:FireClient(Player, "AdjustMaxVolume", Info.MaxVolume) -- Adjust max volume for specific players
		end
	else
		Events.HeadlessEvents:FireAllClients("AdjustMaxVolume", Info) -- Adjust max volume for all players
	end
end

-- Return a new instance of the BoomBox class
return BoomBox.new()]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Configuration" referent="RBXd9d76565d2ac46fc98a9205319ed36b4">
			<Properties>
				<BinaryString name="AttributesSerialize"><![CDATA[BgAAAAgAAABBdXRvcGxheQMAEgAAAERlZmF1bHRBY2NlbnRDb2xvcg8AAIA/AACAPwAAgD8P
AAAARGVmYXVsdFBvc2l0aW9uEAAAgD8AAAA/DwAAAERyYWdnaW5nRW5hYmxlZAMACQAAAE1h
eFZvbHVtZQYAAAAAAADwPwkAAABNaW5pbWl6ZWQDAA==]]></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">AttributeConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="LocalScript" referent="RBX55c3fb2bd90a47a19fe364cd6986b89a">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Client</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{a37f2ea7-6d1c-44e5-8635-6615d5a76175}</string>
				<ProtectedString name="Source"><![CDATA[--@localscript
--[[
--Created Date: Tuesday July 9th 2024 10:43:39 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 11:37:15 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")


--// Variables
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	Telemetry = Remotes:WaitForChild("Telemetry") :: RemoteFunction,
}

local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

--// Attributes
local Autoplay = script:GetAttribute("Autoplay")
local MaxVolume = script:GetAttribute("MaxVolume")
local Minimized = script:GetAttribute("Minimized")
local DraggingEnabled = script:GetAttribute("DraggingEnabled")
local DefaultPosition = script:GetAttribute("DefaultPosition")
local DefaultAccentColor = script:GetAttribute("DefaultAccentColor")

Handlers_Interface:Set("AutoPlay", Autoplay)
Handlers_Interface:Set("MaxVolume", MaxVolume)
Handlers_Interface:Set("PlayerHidden", Minimized)
Handlers_Interface:Set("PlayerVisible", not Minimized)
Handlers_Interface:Set("DraggingEnabled", DraggingEnabled)
Handlers_Interface:Set("DefaultPosition", DefaultPosition)
Handlers_Interface:Set("DefaultAccentColor", DefaultAccentColor)

--// Init
require(Interface)
Handlers_Interface:Set("Queue", {})

--// Var

task.spawn(function()
	local Song = Events.Persistence:InvokeServer("GET", "playing")

	if Song then
		Song = HttpService:JSONDecode(Song)
		Handlers_Interface:Set("Sound", Song)
	end

	local Queue = Events.Persistence:InvokeServer("GET", "queue")

	if Queue and Queue ~= "null" then
		Handlers_Interface:Set("Queue", HttpService:JSONDecode(Queue))
	end
end)

require(script.Managers)

Handlers_Interface:Set("Loaded", true)]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXfb4d3d4daf224c88b60e6ee75626e414">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Managers</string>
					<string name="ScriptGuid">{27193c10-bfc4-4a5c-a3d1-a73880b8d292}</string>
					<ProtectedString name="Source"><![CDATA[return {
	require(script.Telemetry),
	require(script.AudioControls),
	require(script.Queue),
	require(script.Search),
	require(script.HeadlessRemotes),
	require(script.Persistence),
	require(script.Like),
	require(script.Loader),
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXd4e38b710a90492fb2d6dffb57bc920c">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioControls</string>
						<string name="ScriptGuid">{e5daeb8f-ed81-4af9-9d46-bf5af1319fc9}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Instween = require(script.Parent.Parent.Util.Instween)

Handlers_Interface:Subscribe("PlaySound", function(Song: any, Fading: boolean)
	if Fading then
		local Sound = Handlers_Interface:Get("SoundInstance") :: Sound

		local CurrentTween = Instween.new(
			Sound,
			{
				Volume = 0,
			},
			2,
			{
				EasingStyle = Enum.EasingStyle.Linear,
				EasingDirection = Enum.EasingDirection.Out,
			}
		)

		CurrentTween.Completed:Once(function()
			CurrentTween:Destroy()
			Handlers_Interface:Set("Fading", false)
			task.delay(1, function()
				Sound:Destroy()
			end)
		end)

		local NewSound = Instance.new("Sound")
		NewSound.Parent = Sound.Parent
		Handlers_Interface:Set("SoundInstance", NewSound)

		CurrentTween:Play()
		Handlers_Interface:Set("Fading", true)
	end

	Handlers_Interface:Set("Sound", Song)
end)

Handlers_Interface:Subscribe("AddToQueue", function(Song: any)
	local Queue = Handlers_Interface:Get("Queue") :: { [any]: any }
	table.insert(Queue, Song) -- Insert after the first song
	Handlers_Interface:Set("Queue", Queue)
end)

Handlers_Interface:Subscribe("ToggleSong", function(State: number)
	local CurrentQueue = Handlers_Interface:Get("Queue") :: number
	local CurrentQueueIndex = Handlers_Interface:Get("QueueIndex") :: number

	local SoundInstance = Handlers_Interface:Get("SoundInstance") :: Sound
	local songCount = #Handlers_Interface:Get("Queue") -- Assuming songInfo is the table holding the songs

	if State == -1 then
		-- Go to previous song

		if SoundInstance.TimePosition > 5 and SoundInstance.Playing then
			SoundInstance.TimePosition = 0
			return
		end

		CurrentQueueIndex = (CurrentQueueIndex - 1) < 1 and songCount or (CurrentQueueIndex - 1)
		Handlers_Interface:Set("QueueIndex", CurrentQueueIndex)
	elseif State == 1 then
		-- Go to next song
		if Handlers_Interface:Get("Shuffling") then
			local RandomSongIndex = math.random(CurrentQueueIndex, #CurrentQueue)

			-- Move the random song in front of the CurrentQueueIndex
			local RandomSong = table.remove(CurrentQueue, RandomSongIndex)
			CurrentQueueIndex = (CurrentQueueIndex + 1) > songCount and 1 or (CurrentQueueIndex + 1)
			table.insert(CurrentQueue, CurrentQueueIndex, RandomSong)

			-- Update the Queue and QueueIndex in your interface
			Handlers_Interface:Set("Queue", CurrentQueue)
			Handlers_Interface:Set("QueueIndex", CurrentQueueIndex)
		else
			CurrentQueueIndex = (CurrentQueueIndex + 1) > songCount and 1 or (CurrentQueueIndex + 1)
			Handlers_Interface:Set("QueueIndex", CurrentQueueIndex)
		end
	elseif State == 0 then
		-- Stop/Play the song
		if SoundInstance.IsPlaying then
			SoundInstance.Playing = false
			Handlers_Interface:Set("SoundPlaying", false)
		else
			SoundInstance.Playing = true
			Handlers_Interface:Set("SoundPlaying", true)
		end
	end
end)

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX975f5c82255c4033966263e28b5ff0bc">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">HeadlessRemotes</string>
						<string name="ScriptGuid">{ec91611b-e26d-4180-bcad-bcc19f5bcfe0}</string>
						<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript
local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")

local Events = {
	HeadlessEvents = Remotes:WaitForChild("HeadlessEvents") :: RemoteEvent,
	HeadlessFunctions = Remotes:WaitForChild("HeadlessFunctions") :: RemoteFunction,
	Telemetry = Remotes:WaitForChild("Telemetry") :: RemoteFunction,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
}

--// Types
type RobloxAudioMetadata = {
	asset_id: string,
	asset_audioDetails_title: string,
	asset_audioDetails_musicAlbum: string,
	asset_audioDetails_musicGenre: string,
}

Events.HeadlessFunctions.OnClientInvoke = function(
	RobloxAudioMetadata: string,
	RequestMetadataFill: RemoteFunction,
	Info: {
		Fade: number?,
		PlayNow: boolean,
		ClearQueue: boolean,
	}
)
	local Queue = Handlers_Interface:Get("Queue")
	local QueueIndex = Handlers_Interface:Get("QueueIndex")

	-- Decode JSON metadata
	local DecodedMetadata = HttpService:JSONDecode(RobloxAudioMetadata) :: { RobloxAudioMetadata }

	local InsertedPositions = {
		Start = 1,
		End = #DecodedMetadata,
	}

	if Info.ClearQueue or Info.PlayNow then
		Handlers_Interface:Set("Queue", DecodedMetadata)
		Handlers_Interface:Set("QueueIndex", 1)
		Handlers_Interface:Fire("PlaySound", DecodedMetadata[1])
	else
		for i, metadata in ipairs(DecodedMetadata) do
			table.insert(Queue, QueueIndex + i, metadata)
		end
		InsertedPositions.Start = QueueIndex + 1
		InsertedPositions.End = QueueIndex + #DecodedMetadata

		Handlers_Interface:Set("Queue", Queue)
	end

	local AudioScapeAudioMetadata = HttpService:JSONDecode(RequestMetadataFill:InvokeServer())
	task.spawn(function()
		local UpdatedQueue = Handlers_Interface:Get("Queue")

		for i = QueueIndex + 1, #UpdatedQueue do
			for _, audioMetadata in ipairs(AudioScapeAudioMetadata) do
				if UpdatedQueue[i].asset_id == audioMetadata.asset_id then
					-- audioMetadata.Fade = Info.Fade
					UpdatedQueue[i] = audioMetadata
				end
			end
		end

		Handlers_Interface:Set("Queue", UpdatedQueue)
	end)

	return true
end

Remotes.HeadlessEvents.OnClientEvent:Connect(function(EventName: string, ...)
	-- print(EventName)
	if EventName == "AdjustMaxVolume" then
		local MaxVolume = { ... }
		MaxVolume = MaxVolume[1].MaxVolume

		local VolumePercent = Handlers_Interface:Get("VolumePercent")

		Handlers_Interface:Set("MaxVolume", MaxVolume)

		Handlers_Interface:Set("Volume", MaxVolume * VolumePercent)

		local Sound = Handlers_Interface:Get("SoundInstance") :: Sound
		Sound.Volume = MaxVolume * VolumePercent
	elseif EventName == "AdjustVolume" then
		local Volume = { ... }
		Volume = Volume[1].Volume

		local MaxVolume = Handlers_Interface:Get("MaxVolume")

		Handlers_Interface:Set("VolumePercent", Volume / MaxVolume)

		local Sound = Handlers_Interface:Get("SoundInstance") :: Sound
		Sound.Volume = MaxVolume * (Volume / MaxVolume)
		Handlers_Interface:Set("Volume", Sound.Volume)
	end
end)

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXadb14567ed584cd0ad76772fd2a5893f">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Like</string>
						<string name="ScriptGuid">{85c7421b-b838-4333-8384-5824e59247cb}</string>
						<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	Telemetry = Remotes:WaitForChild("Telemetry") :: RemoteFunction,
}

local TimeSorter = require(script.Parent.Parent.Util.TimeSorter)

Handlers_Interface:Subscribe("LikeEvent", function(Payload, Liked: boolean)
	local Like = if Liked == false then "unlike" else "like"

	Events.Telemetry:InvokeServer(Like, Payload)

	local Likes = HttpService:JSONDecode(Events.Telemetry:InvokeServer("likes", {}))
	Handlers_Interface:Set("Favorites", TimeSorter(Likes))
	Handlers_Interface:Set("FavoritesResults", TimeSorter(Likes))
end)

Handlers_Interface:SubscribeToState("Sound", function(Playing: { ["asset_id"]: number })
	local Favorites = Handlers_Interface:Get("Favorites")
	local Found = false

	for _, Song in Favorites do
		if Song and Playing and Song.asset_id == Playing.asset_id then
			Found = true
		end
	end
	Handlers_Interface:Set("PlayingLiked", Found)
end)

Handlers_Interface:SubscribeToState("Favorites", function(Favorites: { { ["asset_id"]: number } })
	local Playing = Handlers_Interface:Get("Sound")
	local Found = false

	local FavoritesDictionary = {}

	for _, Song in Favorites do
		if Playing and Song.asset_id == Playing.asset_id then
			Found = true
		end

		FavoritesDictionary[Song.asset_id] = true
	end

	Handlers_Interface:Set("PlayingLiked", Found)
	Handlers_Interface:Set("FavoritesDictionary", FavoritesDictionary)
end)

local Likes = HttpService:JSONDecode(Events.Telemetry:InvokeServer("likes", {}))
Handlers_Interface:Set("Favorites", TimeSorter(Likes))
Handlers_Interface:Set("FavoritesResults", TimeSorter(Likes))

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXedb962603803469abd3a10ce656d049b">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Loader</string>
						<string name="ScriptGuid">{b7361fee-b02a-4279-b7aa-d7d56d6782c1}</string>
						<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	Telemetry = Remotes:WaitForChild("Telemetry") :: RemoteFunction,
}

local Emotions = Events.Telemetry:InvokeServer("emotions", {})
Handlers_Interface:Set("Emotions", HttpService:JSONDecode(Emotions))

local Genres = Events.Telemetry:InvokeServer("genres", {})
Handlers_Interface:Set("Genres", HttpService:JSONDecode(Genres))

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXa92ab74a14eb4fe4a0db3298f6f20d06">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Persistence</string>
						<string name="ScriptGuid">{0a7c4bf1-2ba7-45b8-a7d7-ec05f1cf4036}</string>
						<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	Telemetry = Remotes:WaitForChild("Telemetry") :: RemoteFunction,
}

Handlers_Interface:SubscribeToState("Sound", function(Sound)
	--// Check if the sound is still the same
	if Handlers_Interface:Get("Sound") ~= Sound then
		return
	end

	--// Post the sound

	if not Sound or not Sound.asset_id then
		return
	end

	local Post = Events.Persistence:InvokeServer("POST", "playing", {
		asset_id = Sound.asset_id,
		asset_audioDetails_title = Sound.asset_audioDetails_title,
		asset_audioDetails_musicAlbum = Sound.asset_audioDetails_musicAlbum,
	})
end)

Handlers_Interface:SubscribeToState("Queue", function(Queue)
	if Handlers_Interface:Get("Queue") ~= Queue then
		return
	end

	local QueueIndex = Handlers_Interface:Get("QueueIndex")
	local StoredQueue = {}

	for i = QueueIndex, #Queue do
		table.insert(StoredQueue, Queue[i])
	end

	--// Post the sound
	local Post = Events.Persistence:InvokeServer("POST", "queue", StoredQueue)
end)

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXaddd049a3bfa487ebe272395016ea5b3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Queue</string>
						<string name="ScriptGuid">{831af7fb-662c-4a17-aac2-5c656e0cc8a4}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

Handlers_Interface:SubscribeToState("QueueIndex", function(Index)
	if not Handlers_Interface:Get("Loaded") then
		return
	end

	local Queue = Handlers_Interface:Get("Queue") :: { [any]: any }
	local QueueLength = #Queue
	local NewIndex = math.clamp(Index, 1, QueueLength)

	--// Play First Song
	Handlers_Interface:Set("Sound", Queue[NewIndex])
end)

Handlers_Interface:SubscribeToState("Queue", function(Queue: { [number]: any })
	local QueueIndex = Handlers_Interface:Get("QueueIndex") :: number
	local QueueMaxLength = Handlers_Interface:Get("QueueMaxLength") :: number

	local NewIndex = QueueIndex

	if #Queue > QueueMaxLength then
		if QueueIndex > 1 and #Queue > QueueMaxLength then
			-- Remove the first song

			table.remove(Queue, 1)
			NewIndex = QueueIndex - 1
		elseif QueueIndex == 1 and #Queue > QueueMaxLength then
			-- Remove the second to last song
			table.remove(Queue, #Queue - 1)
		end

		Handlers_Interface:Set("Queue", Queue)

		if NewIndex ~= QueueIndex then
			Handlers_Interface:Set("QueueIndex", NewIndex)
		end
	end
end)

Handlers_Interface:Subscribe("QueueReorder", function(Data, Play)
	local Queue = Handlers_Interface:Get("Queue") :: { [number]: any }

	local Index = Data["Index"] :: number
	local NewIndex = Data["NewIndex"] :: number

	local Song = Queue[Index]

	table.remove(Queue, Index)
	table.insert(Queue, NewIndex, Song)

	Handlers_Interface:Set("Queue", Queue)

	local NewQueue = Handlers_Interface:Get("Queue") :: { [number]: any }
end)

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX11b0fc23287e42f9974bb921b76b7773">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Search</string>
						<string name="ScriptGuid">{ad81f5b2-361e-4c78-b23e-c3712c360559}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

Handlers_Interface:SubscribeToState("LibraryResults", function(State)
	if State[1] then
		-- Songs = State
		-- Handlers_Interface:Set("Queue", State)a

		if Handlers_Interface:Get("QueueIndex") == 1 then
			Handlers_Interface:Set("Sound", State[1])
		else
			Handlers_Interface:Set("QueueIndex", 1)
		end

		local Payload = {
			search_term = Handlers_Interface:Get("SearchQuery"),
			results = {},
		}

		for i, v in pairs(State) do
			table.insert(Payload.results, tonumber(v.asset_id))
		end
	end
end)

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0a83942e3bef41ffa637f593088333b6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Telemetry</string>
						<string name="ScriptGuid">{ae2ca7b2-9097-46d6-a91e-0c2212f3cebe}</string>
						<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	Telemetry = Remotes:WaitForChild("Telemetry") :: RemoteFunction,
}

Handlers_Interface:Subscribe("ClientTelemetry", function(Action: string, Payload: any)
	if Action == "search" then
		Handlers_Interface:Set("Searching", true)

		local Results = HttpService:JSONDecode(Events.Telemetry:InvokeServer("search", Payload))

		if #Results < 1 then
			Handlers_Interface:Set("Searching", false)
		end

		if Results[1] then
			Handlers_Interface:Set("LibraryResults", Results)
			Handlers_Interface:Set("Searching", false)
		end
	else
		Events.Telemetry:InvokeServer(Action, Payload)
	end
end)

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX35d27ead963441ab93242ae69fb9750b">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Util</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX4e4285b33306435693ed45919797607b">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Instween</string>
						<string name="ScriptGuid">{1e475845-4a07-4091-b461-0950fd8df3aa}</string>
						<ProtectedString name="Source"><![CDATA[--[[
Tween

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = Tween.TopLevel('foo')
    print(foobar.Thing)

DESCRIPTION

    A detailed description of the module.

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of Tween.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

--// module
local Tween = {}

function Tween.new(Object: Instance, Changes: table, Time: number, Settings: table)
	Settings = Settings or {}

	if Settings.Reversing then
		local test = if Settings.Reversing ~= nil then Settings.Reversing else false
	end

	local Info = TweenInfo.new(
		Time,
		Settings.EasingStyle or Enum.EasingStyle.Linear, -- EasingStyle
		Settings.EasingDirection or Enum.EasingDirection.Out, -- EasingDirection
		Settings.TimesRepeated or 0, -- Times repeteated
		if Settings.Reversing ~= nil then Settings.Reversing else false, -- Reversing
		Settings.Delay or 0 -- Time Delay
	)
	local Action = TweenService:Create(Object, Info, Changes)
	return Action
end

return Tween]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXcffe1ecfb1c4401789e31a79c8f19598">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TimeSorter</string>
						<string name="ScriptGuid">{da028db4-b5ed-49ea-bd4e-b7171140ccfa}</string>
						<ProtectedString name="Source"><![CDATA[-- liked_at_sorter.lua

local liked_at_sorter = {}

-- Function to convert ISO 8601 liked_at to a comparable format
local function parse_liked_at(ts)
	local pattern = "(%d+)-(%d+)-(%d+)T(%d+):(%d+):(%d+).(%d+)Z"
	local year, month, day, hour, min, sec, msec = ts:match(pattern)
	return os.time({ year = year, month = month, day = day, hour = hour, min = min, sec = sec }) + (msec / 1000)
end

-- Function to sort a dictionary of dictionaries by liked_ats
function liked_at_sorter.sort_by_liked_at(data)
	-- Extract keys and sort them based on liked_ats
	local keys = {}
	for k in pairs(data) do
		table.insert(keys, k)
	end

	table.sort(keys, function(a, b)
		return parse_liked_at(data[a].liked_at) < parse_liked_at(data[b].liked_at)
	end)

	-- Create a new sorted dictionary
	local sorted_data = {}
	for _, k in ipairs(keys) do
		sorted_data[k] = data[k]
	end

	return sorted_data
end

return liked_at_sorter.sort_by_liked_at]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="StringValue" referent="RBX0dad24cb9a8c4448a2ecf0e9eaaf8fdb">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Developer_API_Key</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<string name="Value">AeQ4lrVjX31Giir84cipc6ZXD0FXtnMQagqN7WqS</string>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXe6687065b2a8494aa6c1aa051273d0a1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Server</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{4ab08dd2-0ad0-4c61-9732-179023b39b02}</string>
				<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Tuesday July 9th 2024 10:22:26 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 12:31:09 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
-- Implementation of Interface.

--// Services
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Events
local Events = require(script.Events)

--// Init
local Interface, Packages = script.Parent.Interface, script.Parent.BoomBoxPackages
Interface.Parent, Packages.Parent = ReplicatedStorage, ReplicatedStorage

local Configuration = script.Parent.AttributeConfiguration

type Settings = {
	game_id: number,
	settings: {
		accentColour: string,
		position: {
			x: number,
			y: number,
		},
		volume: number,
		draggingEnabled: boolean,
	},
}

local DefaultSettings = {
	game_id = game.GameId,
	settings = {
		accentColour = "#FFFFFFF",
		position = {
			x = 1,
			y = 0.5,
		},
		volume = 1,
		draggingEnabled = false,
	},
} :: Settings

local Settings = {
	game_id = game.GameId,
	settings = {
		accentColour = "#FFFFFFF",
		position = {
			x = 1,
			y = 0.5,
		},
		volume = 1,
		draggingEnabled = false,
	},
} :: Settings

--// Private Functions
local function CreateClient(Player: Player)
	local PlayerGui = Player:FindFirstChild("PlayerGui") :: PlayerGui

	if PlayerGui and PlayerGui:FindFirstChild("BoomBoxClient") then
		return
	end

	local BoomBoxClient = script.Parent.Client:Clone() :: LocalScript
	BoomBoxClient.Name = "BoomBoxClient"

	BoomBoxClient:SetAttribute("Autoplay", Configuration:GetAttribute("Autoplay"))
	BoomBoxClient:SetAttribute("Minimized", Configuration:GetAttribute("Minimized"))
	BoomBoxClient:SetAttribute("MaxVolume", Settings.settings.volume)
	BoomBoxClient:SetAttribute(
		"DraggingEnabled",
		Settings.settings.draggingEnabled or DefaultSettings.settings.draggingEnabled
	)
	BoomBoxClient:SetAttribute(
		"DefaultPosition",
		Configuration:GetAttribute("DefaultPosition")
		-- Vector2.new(
		-- 	Settings.settings.position.x or DefaultSettings.settings.position.x,
		-- 	Settings.settings.position.y or DefaultSettings.settings.position.y
		-- )
	)
	BoomBoxClient:SetAttribute("DefaultAccentColor", Color3.fromHex(Settings.settings.accentColour))

	BoomBoxClient.Parent = Player:WaitForChild("PlayerGui")
	BoomBoxClient.Enabled = true
end

--// API
local API = script.API

for i, v in pairs(API:GetChildren()) do
	require(v)(Events)
end

--// Settings
Settings = HttpService:JSONDecode(Events.ServerTelemetry:Invoke(nil, "settings", {}))

--// Loading For Clients
Players.PlayerAdded:Connect(function(Player: Player)
	CreateClient(Player)
end)

for _, Player in Players:GetPlayers() do
	CreateClient(Player)
end]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX000fbfa4445d48409ab7092e92f03289">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">API</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX281f5cecf28e48d5ace9dbf1f22dd3e3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">API_Persistence</string>
						<string name="ScriptGuid">{34afa557-b350-454a-a0ec-26606a797108}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local DataStoreService = game:GetService("DataStoreService")
local QueuePersistence = DataStoreService:GetDataStore("QueuePersistence")
local PlayingPersistence = DataStoreService:GetDataStore("PlayingPersistence")

--// Debug
local Debug = require(script.Parent.Parent.Debug)

--// Events
local Events = require(script.Parent.Parent.Events)

--// Settings
local QuerySettings = {
	SearchLimit = 10,
}

--// Private Function
local function GetKeyName()
	local Name = script.Name
	local Split = string.split(Name, "_")

	return `{Split[2]}_{Split[1]}_Key`
end

local TemplateData = {
	asset_id = 1846594513,
	asset_audioDetails_title = "Melt Down",
	asset_audioDetails_musicAlbum = "Drones And Beats",
}

local PlayerData = {
	playing = {},
	queues = {},
}

local function Request(Player: Player, RequestType: string, Action: string, Payload)
	local Persistence = Action == "queue" and QueuePersistence or PlayingPersistence

	if RequestType == "GET" then
		local CurrentData = Persistence:GetAsync(Player.UserId)

		if not CurrentData then
			Persistence:SetAsync(Player.UserId, HttpService:JSONEncode(TemplateData))
			return TemplateData
		end

		return CurrentData
	elseif RequestType == "POST" then
		Persistence:SetAsync(Player.UserId, HttpService:JSONEncode(Payload))

		return true
	end

	return false
end

--// Return
return function(Remotes: Events.Remotes)
	game:BindToClose(function()
		for _, Player in Players:GetPlayers() do
			task.spawn(Request, Player, "POST", "queue", PlayerData.queues[Player])
			task.spawn(Request, Player, "POST", "playing", PlayerData.playing[Player])
		end
	end)

	Players.PlayerRemoving:Connect(function(Player)
		task.spawn(Request, Player, "POST", "queue", PlayerData.queues[Player])
		task.spawn(Request, Player, "POST", "playing", PlayerData.playing[Player])
	end)

	Remotes.Persistence.OnServerInvoke = function(Player: Player, RequestType: string, Action: string, Payload)
		if RequestType == "POST" then
			if Action == "queue" then
				PlayerData.queues[Player] = Payload

				return PlayerData.queues[Player]
			elseif Action == "playing" then
				PlayerData.playing[Player] = Payload

				return PlayerData.playing[Player]
			end
		else
			return Request(Player, RequestType, Action, Payload)
		end
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXc510913267c74404aa2fad4a1f1dc86d">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">API_Telemetry</string>
						<string name="ScriptGuid">{5a0dcfb9-9d6d-43bb-b5da-6419c7dbafa4}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

--// Debug
local Debug = require(script.Parent.Parent.Debug)

--// DeveloperKey
local DeveloperKey = script.Parent.Parent.Parent.Developer_API_Key

--// Events
local Events = require(script.Parent.Parent.Events)

--// Settings
local QuerySettings = {
	SearchLimit = 10,
}

--// API KEY
local API_KEY = RunService:IsStudio() and DeveloperKey.Value or HttpService:GetSecret("audioscape_boombox_api_key")

--// Private Function
local function GetKeyName()
	local Name = script.Name
	local Split = string.split(Name, "_")

	return `{Split[2]}_{Split[1]}_Key`
end

local function GetPayload(Player: Player, Action: string, Payload: any, Data, url)
	local action = Action:lower()
	if action == "search" then -- Search for an asset
		-- print(Payload)

		-- Data["event_type"] = action -- event type should be 'search'
		Data["query"] = Payload.query -- The search term the user entered
		Data["genre"] = Payload.genre -- The results of the search
		Data["emotion"] = Payload.emotion -- The results of the search

		Data["game_id"] = game.GameId -- The Game Id
		Data["game_name"] = game.Name -- The Game Name

		Data["RequestType"] = "POST"

		return `{url}search`
	elseif action == "play" or action == "skip" or action == "rewind" then -- Play an asset
		Data["event_type"] = action
		Data["event_data"] = {
			["game_id"] = game.GameId, -- The Game Id
			["game_name"] = game.Name, -- The Game Name
			["asset_id"] = tonumber(Payload.asset_id),
		}
		Data["RequestType"] = "POST"

		return `{url}telemetry`
	elseif action == "details" then -- Play an asset
		Data["event_type"] = "/assets/details"
		Data["asset_ids"] = Payload
		Data["RequestType"] = "POST"

		return `{url}/assets/details`
	elseif action == "discover" then -- Play an asset
		Data["event_type"] = action
		Data["event_data"] = {
			["game_id"] = game.GameId, -- The Game Id
			["game_name"] = game.Name, -- The Game Name
			["filter_value"] = Payload.filter_value,
			["results"] = Payload.results,
		}

		Data["RequestType"] = "POST"

		return `{url}telemetry`
	elseif action == "like" or action == "unlike" then -- Like an asset
		Data["asset_id"] = tonumber(Payload.asset_id)
		Data["RequestType"] = "POST"

		return `{url}{action}`
	elseif action == "emotions" or action == "genres" then -- Get all the assets the user has liked
		Data["RequestType"] = "GET"

		return `{url}{action}`
	elseif action == "likes" then -- Get all the assets the user has liked
		Data["RequestType"] = "GET"

		return `{url}{action}?user_id={Player.UserId}`
	elseif action == "settings" then -- Get all the assets the user has liked
		Data["RequestType"] = "GET"

		return `{url}{action}?game_id={game.GameId}`
	end

	return url
end

local function SendRequestFromType(API_KEY, url, jsonData, headers, Data)
	if Debug.TelemetryDebug then
		print(`Request Type: {Data.RequestType}`)
	end

	if Data.RequestType == "POST" then
		if Debug.TelemetryDebug then
			print(
				"POST REQUEST:",
				"\n",
				url,
				"\n",
				jsonData,
				"\n",
				Enum.HttpContentType.ApplicationJson,
				"\n",
				false,
				"\n",
				headers,
				"\n"
			)
		end

		local Request = HttpService:RequestAsync({
			Url = url, -- This website helps debug HTTP requests
			Method = Data.RequestType,
			Headers = {
				["Content-Type"] = "application/json", -- When sending JSON, set this!
				["X-API-Key"] = API_KEY,
			},
			Body = jsonData,
		})

		return Request.Body -- Unable to cast Dictionary to token
	elseif Data.RequestType == "GET" then
		local Request = HttpService:RequestAsync({
			Url = url, -- This website helps debug HTTP requests
			Method = Data.RequestType,
			Headers = {
				["Content-Type"] = "application/json", -- When sending JSON, set this!
				["X-API-Key"] = API_KEY,
			},
		})

		return Request.Body
	else
		error("Invalid Request Type")
	end
end

local function Request(Player: Player, Action: string, Payload: string | { [any]: any })
	local SecretIsString = type(API_KEY) == "string"

	local url = SecretIsString and "https://0ibi1y5igg.execute-api.us-east-2.amazonaws.com/dev/"
		or "https://api.audioscape.ai/boombox/"

	local headers = {
		["content"] = "application/json",
		["X-API-Key"] = API_KEY,
	}
	local data = {}

	data["game_id"] = game.GameId -- The Game Id
	data["game_name"] = game.Name -- The Game Name
	data["AS-BoomBox-GameId"] = game.GameId
	data["AS-BoomBox-GameName"] = game.Name
	data["AS-BoomBox-ClientDeviceType"] = RunService:IsStudio() and "Studio" or "Game"

	if Player then
		data["user_id"] = Player.UserId
		data["player_id"] = Player.UserId
		data["AS-BoomBox-PlayerId"] = Player.UserId
	end

	url = GetPayload(Player, Action, Payload, data, url)

	local jsonData = HttpService:JSONEncode(data)

	local response = SendRequestFromType(API_KEY, url, jsonData, headers, data)

	if Debug.TelemetryDebug then
		print("URL: ", url, "\n")
		print("From: ", data["user_id"], "\n")
		print("Current Payload: ", Payload, "\n")
		print("JSON Data: ", data, "\n")
		print("Response Decode: ", HttpService:JSONDecode(response), "\n")
	end

	return response
end

--// Return
return function(Remotes: Events.Remotes)
	Remotes.Telemetry.OnServerInvoke = Request
	Remotes.ServerTelemetry.OnInvoke = Request
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX04fe013a30584c5f91fff0fabf1b1450">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Debug</string>
					<string name="ScriptGuid">{b7e297f3-dd47-410a-9f27-88287400e8f2}</string>
					<ProtectedString name="Source"><![CDATA[return {
	SearchDebug = false,
	TelemetryDebug = false,
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX610f995adcf24ecc87f8fd95545caef0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Events</string>
					<string name="ScriptGuid">{d219085d-bfc6-4679-afd7-09a28555b674}</string>
					<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Types
export type Remotes = {
	--// Remote Events
	CreatePublicSound: RemoteEvent,

	--// Remote Functions
	Telemetry: RemoteFunction,
	ServerTelemetry: BindableFunction,

	Persistence: RemoteFunction,
}

--// Variables
local BoomboxRemotes = Instance.new("Folder")
BoomboxRemotes.Name = "BoomboxRemotes"
BoomboxRemotes.Parent = ReplicatedStorage

--// Private Functions
local function CreateRemoteEvent(Name: string)
	local RemoteEvent = Instance.new("RemoteEvent")
	RemoteEvent.Name = Name
	RemoteEvent.Parent = BoomboxRemotes

	return RemoteEvent
end

local function CreateRemoteFunction(Name: string)
	local RemoteFunction = Instance.new("RemoteFunction")
	RemoteFunction.Name = Name
	RemoteFunction.Parent = BoomboxRemotes

	return RemoteFunction
end

local function CreateBindableFunction(Name: string)
	local BindableFunction = Instance.new("BindableFunction")
	BindableFunction.Name = Name
	BindableFunction.Parent = BoomboxRemotes

	return BindableFunction
end

--// Return
return {
	--// Remote Events
	HeadlessEvents = CreateRemoteEvent("HeadlessEvents"),
	CreatePublicSound = CreateRemoteEvent("CreatePublicSound"),

	--// Remote Functions
	Telemetry = CreateRemoteFunction("Telemetry"),
	Persistence = CreateRemoteFunction("Persistence"),
	ServerTelemetry = CreateBindableFunction("ServerTelemetry"),
	HeadlessFunctions = CreateRemoteFunction("HeadlessFunctions"),
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="StringValue" referent="RBX5cd223ad873a4eeabd360608554b91d0">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Version</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<string name="Value">0.0.2</string>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBXbf020f9c01444b31ab64640931f05a8d">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">BoomBoxPackages</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX2c3a589db5ab46129404328fc167af02">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Fusion</string>
					<string name="ScriptGuid">{d8bcabf0-21df-45fa-9145-c8960a454455}</string>
					<ProtectedString name="Source">return require(script.Parent._Index[&quot;elttob_fusion@0.2.0&quot;][&quot;fusion&quot;])</ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4a6ec6951c3743d6a40f68adfcb45d1a">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Maid</string>
					<string name="ScriptGuid">{aee8641e-0da1-49ab-8a10-0a2aaf08ab0a}</string>
					<ProtectedString name="Source">return require(script.Parent._Index[&quot;flamenco687_maid@3.2.2&quot;][&quot;maid&quot;])</ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX882560829cdf484fb95ce2997ad51875">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">_Index</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX0cf07c1b4c8f4c65b289e214c11dd225">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">elttob_fusion@0.2.0</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX43418ee4fc3747eba37d521303adac05">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">fusion</string>
							<string name="ScriptGuid">{15495627-9d00-4e5b-af16-d7162afcc38b}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

--[[
	The entry point for the Fusion library.
]]

local PubTypes = require(script.PubTypes)
local restrictRead = require(script.Utility.restrictRead)

export type StateObject<T> = PubTypes.StateObject<T>
export type CanBeState<T> = PubTypes.CanBeState<T>
export type Symbol = PubTypes.Symbol
export type Value<T> = PubTypes.Value<T>
export type Computed<T> = PubTypes.Computed<T>
export type ForPairs<KO, VO> = PubTypes.ForPairs<KO, VO>
export type ForKeys<KI, KO> = PubTypes.ForKeys<KI, KO>
export type ForValues<VI, VO> = PubTypes.ForKeys<VI, VO>
export type Observer = PubTypes.Observer
export type Tween<T> = PubTypes.Tween<T>
export type Spring<T> = PubTypes.Spring<T>

type Fusion = {
	version: PubTypes.Version,

	New: (className: string) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Hydrate: (target: Instance) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Ref: PubTypes.SpecialKey,
	Cleanup: PubTypes.SpecialKey,
	Children: PubTypes.SpecialKey,
	Out: PubTypes.SpecialKey,
	OnEvent: (eventName: string) -> PubTypes.SpecialKey,
	OnChange: (propertyName: string) -> PubTypes.SpecialKey,

	Value: <T>(initialValue: T) -> Value<T>,
	Computed: <T>(callback: () -> T, destructor: (T) -> ()?) -> Computed<T>,
	ForPairs: <KI, VI, KO, VO, M>(inputTable: CanBeState<{[KI]: VI}>, processor: (KI, VI) -> (KO, VO, M?), destructor: (KO, VO, M?) -> ()?) -> ForPairs<KO, VO>,
	ForKeys: <KI, KO, M>(inputTable: CanBeState<{[KI]: any}>, processor: (KI) -> (KO, M?), destructor: (KO, M?) -> ()?) -> ForKeys<KO, any>,
	ForValues: <VI, VO, M>(inputTable: CanBeState<{[any]: VI}>, processor: (VI) -> (VO, M?), destructor: (VO, M?) -> ()?) -> ForValues<any, VO>,
	Observer: (watchedState: StateObject<any>) -> Observer,

	Tween: <T>(goalState: StateObject<T>, tweenInfo: TweenInfo?) -> Tween<T>,
	Spring: <T>(goalState: StateObject<T>, speed: number?, damping: number?) -> Spring<T>,

	cleanup: (...any) -> (),
	doNothing: (...any) -> ()
}

return restrictRead("Fusion", {
	version = {major = 0, minor = 2, isRelease = true},

	New = require(script.Instances.New),
	Hydrate = require(script.Instances.Hydrate),
	Ref = require(script.Instances.Ref),
	Out = require(script.Instances.Out),
	Cleanup = require(script.Instances.Cleanup),
	Children = require(script.Instances.Children),
	OnEvent = require(script.Instances.OnEvent),
	OnChange = require(script.Instances.OnChange),

	Value = require(script.State.Value),
	Computed = require(script.State.Computed),
	ForPairs = require(script.State.ForPairs),
	ForKeys = require(script.State.ForKeys),
	ForValues = require(script.State.ForValues),
	Observer = require(script.State.Observer),

	Tween = require(script.Animation.Tween),
	Spring = require(script.Animation.Spring),

	cleanup = require(script.Utility.cleanup),
	doNothing = require(script.Utility.doNothing)
}) :: Fusion]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXffb13dd0ad8c4a958188e3db32e6c1b1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animation</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX440584fdfc904652960cc1be5cc183e8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Spring</string>
									<string name="ScriptGuid">{e490dfe8-b0aa-4b57-b3c1-38c228e8a546}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a spring simulation.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local unpackType = require(Package.Animation.unpackType)
local SpringScheduler = require(Package.Animation.SpringScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local xtypeof = require(Package.Utility.xtypeof)
local unwrap = require(Package.State.unwrap)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Spring object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Sets the position of the internal springs, meaning the value of this
	Spring will jump to the given value. This doesn't affect velocity.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setPosition(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springPositions = unpackType(newValue, newType)
	self._currentValue = newValue
	SpringScheduler.add(self)
	updateAll(self)
end

--[[
	Sets the velocity of the internal springs, overwriting the existing velocity
	of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setVelocity(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springVelocities = unpackType(newValue, newType)
	SpringScheduler.add(self)
end

--[[
	Adds to the velocity of the internal springs, on top of the existing
	velocity of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:addVelocity(deltaValue: PubTypes.Animatable)
	local deltaType = typeof(deltaValue)
	if deltaType ~= self._currentType then
		logError("springTypeMismatch", nil, deltaType, self._currentType)
	end

	local springDeltas = unpackType(deltaValue, deltaType)
	for index, delta in ipairs(springDeltas) do
		self._springVelocities[index] += delta
	end
	SpringScheduler.add(self)
end

--[[
	Called when the goal state changes value, or when the speed or damping has
	changed.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- figure out if this was a goal change or a speed/damping change
	if goalValue == self._goalValue then
		-- speed/damping change
		local damping = unwrap(self._damping)
		if typeof(damping) ~= "number" then
			logErrorNonFatal("mistypedSpringDamping", nil, typeof(damping))
		elseif damping < 0 then
			logErrorNonFatal("invalidSpringDamping", nil, damping)
		else
			self._currentDamping = damping
		end

		local speed = unwrap(self._speed)
		if typeof(speed) ~= "number" then
			logErrorNonFatal("mistypedSpringSpeed", nil, typeof(speed))
		elseif speed < 0 then
			logErrorNonFatal("invalidSpringSpeed", nil, speed)
		else
			self._currentSpeed = speed
		end

		return false
	else
		-- goal change - reconfigure spring to target new goal
		self._goalValue = goalValue

		local oldType = self._currentType
		local newType = typeof(goalValue)
		self._currentType = newType

		local springGoals = unpackType(goalValue, newType)
		local numSprings = #springGoals
		self._springGoals = springGoals

		if newType ~= oldType then
			-- if the type changed, snap to the new value and rebuild the
			-- position and velocity tables
			self._currentValue = self._goalValue

			local springPositions = table.create(numSprings, 0)
			local springVelocities = table.create(numSprings, 0)
			for index, springGoal in ipairs(springGoals) do
				springPositions[index] = springGoal
			end
			self._springPositions = springPositions
			self._springVelocities = springVelocities

			-- the spring may have been animating before, so stop that
			SpringScheduler.remove(self)
			return true

			-- otherwise, the type hasn't changed, just the goal...
		elseif numSprings == 0 then
			-- if the type isn't animatable, snap to the new value
			self._currentValue = self._goalValue
			return true

		else
			-- if it's animatable, let it animate to the goal
			SpringScheduler.add(self)
			return false
		end
	end
end

local function Spring<T>(
	goalState: PubTypes.Value<T>,
	speed: PubTypes.CanBeState<number>?,
	damping: PubTypes.CanBeState<number>?
): Types.Spring<T>
	-- apply defaults for speed and damping
	if speed == nil then
		speed = 10
	end
	if damping == nil then
		damping = 1
	end

	local dependencySet = {[goalState] = true}
	if xtypeof(speed) == "State" then
		dependencySet[speed] = true
	end
	if xtypeof(damping) == "State" then
		dependencySet[damping] = true
	end

	local self = setmetatable({
		type = "State",
		kind = "Spring",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_speed = speed,
		_damping = damping,

		_goalState = goalState,
		_goalValue = nil,

		_currentType = nil,
		_currentValue = nil,
		_currentSpeed = unwrap(speed),
		_currentDamping = unwrap(damping),

		_springPositions = nil,
		_springGoals = nil,
		_springVelocities = nil
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true
	self:update()

	return self
end

return Spring]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2a428e3e5957435bb67911e5608e57e0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SpringScheduler</string>
									<string name="ScriptGuid">{bae8eb1b-96f8-420c-83d2-a6ba4170c863}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Manages batch updating of spring objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local packType = require(Package.Animation.packType)
local springCoefficients = require(Package.Animation.springCoefficients)
local updateAll = require(Package.Dependencies.updateAll)

type Set<T> = {[T]: any}
type Spring = Types.Spring<any>

local SpringScheduler = {}

local EPSILON = 0.0001
local activeSprings: Set<Spring> = {}
local lastUpdateTime = os.clock()

function SpringScheduler.add(spring: Spring)
	-- we don't necessarily want to use the most accurate time - here we snap to
	-- the last update time so that springs started within the same frame have
	-- identical time steps
	spring._lastSchedule = lastUpdateTime
	spring._startDisplacements = {}
	spring._startVelocities = {}
	for index, goal in ipairs(spring._springGoals) do
		spring._startDisplacements[index] = spring._springPositions[index] - goal
		spring._startVelocities[index] = spring._springVelocities[index]
	end

	activeSprings[spring] = true
end

function SpringScheduler.remove(spring: Spring)
	activeSprings[spring] = nil
end


local function updateAllSprings()
	local springsToSleep: Set<Spring> = {}
	lastUpdateTime = os.clock()

	for spring in pairs(activeSprings) do
		local posPos, posVel, velPos, velVel = springCoefficients(lastUpdateTime - spring._lastSchedule, spring._currentDamping, spring._currentSpeed)

		local positions = spring._springPositions
		local velocities = spring._springVelocities
		local startDisplacements = spring._startDisplacements
		local startVelocities = spring._startVelocities
		local isMoving = false

		for index, goal in ipairs(spring._springGoals) do
			local oldDisplacement = startDisplacements[index]
			local oldVelocity = startVelocities[index]
			local newDisplacement = oldDisplacement * posPos + oldVelocity * posVel
			local newVelocity = oldDisplacement * velPos + oldVelocity * velVel

			if math.abs(newDisplacement) > EPSILON or math.abs(newVelocity) > EPSILON then
				isMoving = true
			end

			positions[index] = newDisplacement + goal
			velocities[index] = newVelocity
		end

		if not isMoving then
			springsToSleep[spring] = true
		end
	end

	for spring in pairs(activeSprings) do
		spring._currentValue = packType(spring._springPositions, spring._currentType)
		updateAll(spring)
	end

	for spring in pairs(springsToSleep) do
		activeSprings[spring] = nil
	end
end

RunService:BindToRenderStep(
	"__FusionSpringScheduler",
	Enum.RenderPriority.First.Value,
	updateAllSprings
)

return SpringScheduler]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXf3f23aefbca7465c9bb2884023f00904">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Tween</string>
									<string name="ScriptGuid">{bea46e8a-d547-46b5-8033-4722fa6aad0a}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a tween.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local TweenScheduler = require(Package.Animation.TweenScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local xtypeof = require(Package.Utility.xtypeof)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Tween object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value; this will initiate a new tween.
	Returns false as the current value doesn't change right away.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- if the goal hasn't changed, then this is a TweenInfo change.
	-- in that case, if we're not currently animating, we can skip everything
	if goalValue == self._nextValue and not self._currentlyAnimating then
		return false
	end

	local tweenInfo = self._tweenInfo
	if self._tweenInfoIsState then
		tweenInfo = tweenInfo:get()
	end

	-- if we receive a bad TweenInfo, then error and stop the update
	if typeof(tweenInfo) ~= "TweenInfo" then
		logErrorNonFatal("mistypedTweenInfo", nil, typeof(tweenInfo))
		return false
	end

	self._prevValue = self._currentValue
	self._nextValue = goalValue

	self._currentTweenStartTime = os.clock()
	self._currentTweenInfo = tweenInfo

	local tweenDuration = tweenInfo.DelayTime + tweenInfo.Time
	if tweenInfo.Reverses then
		tweenDuration += tweenInfo.Time
	end
	tweenDuration *= tweenInfo.RepeatCount + 1
	self._currentTweenDuration = tweenDuration

	-- start animating this tween
	TweenScheduler.add(self)

	return false
end

local function Tween<T>(
	goalState: PubTypes.StateObject<PubTypes.Animatable>,
	tweenInfo: PubTypes.CanBeState<TweenInfo>?
): Types.Tween<T>
	local currentValue = goalState:get(false)

	-- apply defaults for tween info
	if tweenInfo == nil then
		tweenInfo = TweenInfo.new()
	end

	local dependencySet = {[goalState] = true}
	local tweenInfoIsState = xtypeof(tweenInfo) == "State"

	if tweenInfoIsState then
		dependencySet[tweenInfo] = true
	end

	local startingTweenInfo = tweenInfo
	if tweenInfoIsState then
		startingTweenInfo = startingTweenInfo:get()
	end

	-- If we start with a bad TweenInfo, then we don't want to construct a Tween
	if typeof(startingTweenInfo) ~= "TweenInfo" then
		logError("mistypedTweenInfo", nil, typeof(startingTweenInfo))
	end

	local self = setmetatable({
		type = "State",
		kind = "Tween",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_goalState = goalState,
		_tweenInfo = tweenInfo,
		_tweenInfoIsState = tweenInfoIsState,

		_prevValue = currentValue,
		_nextValue = currentValue,
		_currentValue = currentValue,

		-- store current tween into separately from 'real' tween into, so it
		-- isn't affected by :setTweenInfo() until next change
		_currentTweenInfo = tweenInfo,
		_currentTweenDuration = 0,
		_currentTweenStartTime = 0,
		_currentlyAnimating = false
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true

	return self
end

return Tween]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXc8ce2f9195ce4802899f4a9b279738c2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TweenScheduler</string>
									<string name="ScriptGuid">{7fedbb89-d20a-466f-bc29-71e293d3a53f}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Manages batch updating of tween objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local lerpType = require(Package.Animation.lerpType)
local getTweenRatio = require(Package.Animation.getTweenRatio)
local updateAll = require(Package.Dependencies.updateAll)

local TweenScheduler = {}

type Set<T> = {[T]: any}
type Tween = Types.Tween<any>

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- all the tweens currently being updated
local allTweens: Set<Tween> = {}
setmetatable(allTweens, WEAK_KEYS_METATABLE)

--[[
	Adds a Tween to be updated every render step.
]]
function TweenScheduler.add(tween: Tween)
	allTweens[tween] = true
end

--[[
	Removes a Tween from the scheduler.
]]
function TweenScheduler.remove(tween: Tween)
	allTweens[tween] = nil
end

--[[
	Updates all Tween objects.
]]
local function updateAllTweens()
	local now = os.clock()
	-- FIXME: Typed Luau doesn't understand this loop yet
	for tween: Tween in pairs(allTweens :: any) do
		local currentTime = now - tween._currentTweenStartTime

		if currentTime > tween._currentTweenDuration then
			if tween._currentTweenInfo.Reverses then
				tween._currentValue = tween._prevValue
			else
				tween._currentValue = tween._nextValue
			end
			tween._currentlyAnimating = false
			updateAll(tween)
			TweenScheduler.remove(tween)
		else
			local ratio = getTweenRatio(tween._currentTweenInfo, currentTime)
			local currentValue = lerpType(tween._prevValue, tween._nextValue, ratio)
			tween._currentValue = currentValue
			tween._currentlyAnimating = true
			updateAll(tween)
		end
	end
end

RunService:BindToRenderStep(
	"__FusionTweenScheduler",
	Enum.RenderPriority.First.Value,
	updateAllTweens
)

return TweenScheduler]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX601b43f7b00b496eb0d70d8f5faf4ae8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">getTweenRatio</string>
									<string name="ScriptGuid">{133faaf6-469e-4104-a56b-7275611d66d1}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Given a `tweenInfo` and `currentTime`, returns a ratio which can be used to
	tween between two values over time.
]]

local TweenService = game:GetService("TweenService")

local function getTweenRatio(tweenInfo: TweenInfo, currentTime: number): number
	local delay = tweenInfo.DelayTime
	local duration = tweenInfo.Time
	local reverses = tweenInfo.Reverses
	local numCycles = 1 + tweenInfo.RepeatCount
	local easeStyle = tweenInfo.EasingStyle
	local easeDirection = tweenInfo.EasingDirection

	local cycleDuration = delay + duration
	if reverses then
		cycleDuration += duration
	end

	if currentTime >= cycleDuration * numCycles then
		return 1
	end

	local cycleTime = currentTime % cycleDuration

	if cycleTime <= delay then
		return 0
	end

	local tweenProgress = (cycleTime - delay) / duration
	if tweenProgress > 1 then
		tweenProgress = 2 - tweenProgress
	end

	local ratio = TweenService:GetValue(tweenProgress, easeStyle, easeDirection)
	return ratio
end

return getTweenRatio]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXd1e3a2d014104beba3042dd95255d6f3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">lerpType</string>
									<string name="ScriptGuid">{d7aff763-1919-4215-9f7b-673ca92cfe5d}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Linearly interpolates the given animatable types by a ratio.
	If the types are different or not animatable, then the first value will be
	returned for ratios below 0.5, and the second value for 0.5 and above.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function lerpType(from: any, to: any, ratio: number): any
	local typeString = typeof(from)

	if typeof(to) == typeString then
		-- both types must match for interpolation to make sense
		if typeString == "number" then
			local to, from = to :: number, from :: number
			return (to - from) * ratio + from

		elseif typeString == "CFrame" then
			local to, from = to :: CFrame, from :: CFrame
			return from:Lerp(to, ratio)

		elseif typeString == "Color3" then
			local to, from = to :: Color3, from :: Color3
			local fromLab = Oklab.to(from)
			local toLab = Oklab.to(to)
			return Oklab.from(
				fromLab:Lerp(toLab, ratio),
				false
			)

		elseif typeString == "ColorSequenceKeypoint" then
			local to, from = to :: ColorSequenceKeypoint, from :: ColorSequenceKeypoint
			local fromLab = Oklab.to(from.Value)
			local toLab = Oklab.to(to.Value)
			return ColorSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				Oklab.from(
					fromLab:Lerp(toLab, ratio),
					false
				)
			)

		elseif typeString == "DateTime" then
			local to, from = to :: DateTime, from :: DateTime
			return DateTime.fromUnixTimestampMillis(
				(to.UnixTimestampMillis - from.UnixTimestampMillis) * ratio + from.UnixTimestampMillis
			)

		elseif typeString == "NumberRange" then
			local to, from = to :: NumberRange, from :: NumberRange
			return NumberRange.new(
				(to.Min - from.Min) * ratio + from.Min,
				(to.Max - from.Max) * ratio + from.Max
			)

		elseif typeString == "NumberSequenceKeypoint" then
			local to, from = to :: NumberSequenceKeypoint, from :: NumberSequenceKeypoint
			return NumberSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				(to.Value - from.Value) * ratio + from.Value,
				(to.Envelope - from.Envelope) * ratio + from.Envelope
			)

		elseif typeString == "PhysicalProperties" then
			local to, from = to :: PhysicalProperties, from :: PhysicalProperties
			return PhysicalProperties.new(
				(to.Density - from.Density) * ratio + from.Density,
				(to.Friction - from.Friction) * ratio + from.Friction,
				(to.Elasticity - from.Elasticity) * ratio + from.Elasticity,
				(to.FrictionWeight - from.FrictionWeight) * ratio + from.FrictionWeight,
				(to.ElasticityWeight - from.ElasticityWeight) * ratio + from.ElasticityWeight
			)

		elseif typeString == "Ray" then
			local to, from = to :: Ray, from :: Ray
			return Ray.new(
				from.Origin:Lerp(to.Origin, ratio),
				from.Direction:Lerp(to.Direction, ratio)
			)

		elseif typeString == "Rect" then
			local to, from = to :: Rect, from :: Rect
			return Rect.new(
				from.Min:Lerp(to.Min, ratio),
				from.Max:Lerp(to.Max, ratio)
			)

		elseif typeString == "Region3" then
			local to, from = to :: Region3, from :: Region3
			-- FUTURE: support rotated Region3s if/when they become constructable
			local position = from.CFrame.Position:Lerp(to.CFrame.Position, ratio)
			local halfSize = from.Size:Lerp(to.Size, ratio) / 2
			return Region3.new(position - halfSize, position + halfSize)

		elseif typeString == "Region3int16" then
			local to, from = to :: Region3int16, from :: Region3int16
			return Region3int16.new(
				Vector3int16.new(
					(to.Min.X - from.Min.X) * ratio + from.Min.X,
					(to.Min.Y - from.Min.Y) * ratio + from.Min.Y,
					(to.Min.Z - from.Min.Z) * ratio + from.Min.Z
				),
				Vector3int16.new(
					(to.Max.X - from.Max.X) * ratio + from.Max.X,
					(to.Max.Y - from.Max.Y) * ratio + from.Max.Y,
					(to.Max.Z - from.Max.Z) * ratio + from.Max.Z
				)
			)

		elseif typeString == "UDim" then
			local to, from = to :: UDim, from :: UDim
			return UDim.new(
				(to.Scale - from.Scale) * ratio + from.Scale,
				(to.Offset - from.Offset) * ratio + from.Offset
			)

		elseif typeString == "UDim2" then
			local to, from = to :: UDim2, from :: UDim2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2" then
			local to, from = to :: Vector2, from :: Vector2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2int16" then
			local to, from = to :: Vector2int16, from :: Vector2int16
			return Vector2int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y
			)

		elseif typeString == "Vector3" then
			local to, from = to :: Vector3, from :: Vector3
			return from:Lerp(to, ratio)

		elseif typeString == "Vector3int16" then
			local to, from = to :: Vector3int16, from :: Vector3int16
			return Vector3int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y,
				(to.Z - from.Z) * ratio + from.Z
			)
		end
	end

	-- fallback case: the types are different or not animatable
	if ratio < 0.5 then
		return from
	else
		return to
	end
end

return lerpType]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXd34af160d6e44c1e99be462747379cb7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">packType</string>
									<string name="ScriptGuid">{3be001de-31f2-42a6-9585-6bf5772364b8}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Packs an array of numbers into a given animatable data type.
	If the type is not animatable, nil will be returned.

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function packType(numbers: {number}, typeString: string): PubTypes.Animatable?
	if typeString == "number" then
		return numbers[1]

	elseif typeString == "CFrame" then
		return
			CFrame.new(numbers[1], numbers[2], numbers[3]) *
			CFrame.fromAxisAngle(
				Vector3.new(numbers[4], numbers[5], numbers[6]).Unit,
				numbers[7]
			)

	elseif typeString == "Color3" then
		return Oklab.from(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			false
		)

	elseif typeString == "ColorSequenceKeypoint" then
		return ColorSequenceKeypoint.new(
			numbers[4],
			Oklab.from(
				Vector3.new(numbers[1], numbers[2], numbers[3]),
				false
			)
		)

	elseif typeString == "DateTime" then
		return DateTime.fromUnixTimestampMillis(numbers[1])

	elseif typeString == "NumberRange" then
		return NumberRange.new(numbers[1], numbers[2])

	elseif typeString == "NumberSequenceKeypoint" then
		return NumberSequenceKeypoint.new(numbers[2], numbers[1], numbers[3])

	elseif typeString == "PhysicalProperties" then
		return PhysicalProperties.new(numbers[1], numbers[2], numbers[3], numbers[4], numbers[5])

	elseif typeString == "Ray" then
		return Ray.new(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			Vector3.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "Rect" then
		return Rect.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		local position = Vector3.new(numbers[1], numbers[2], numbers[3])
		local halfSize = Vector3.new(numbers[4] / 2, numbers[5] / 2, numbers[6] / 2)
		return Region3.new(position - halfSize, position + halfSize)

	elseif typeString == "Region3int16" then
		return Region3int16.new(
			Vector3int16.new(numbers[1], numbers[2], numbers[3]),
			Vector3int16.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "UDim" then
		return UDim.new(numbers[1], numbers[2])

	elseif typeString == "UDim2" then
		return UDim2.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Vector2" then
		return Vector2.new(numbers[1], numbers[2])

	elseif typeString == "Vector2int16" then
		return Vector2int16.new(numbers[1], numbers[2])

	elseif typeString == "Vector3" then
		return Vector3.new(numbers[1], numbers[2], numbers[3])

	elseif typeString == "Vector3int16" then
		return Vector3int16.new(numbers[1], numbers[2], numbers[3])
	else
		return nil
	end
end

return packType]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXac7ca42ff57a4b54b8af0dedd834c102">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">springCoefficients</string>
									<string name="ScriptGuid">{645c4cdf-7691-4689-a220-3492e777c7f3}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Returns a 2x2 matrix of coefficients for a given time, damping and speed.
	Specifically, this returns four coefficients - posPos, posVel, velPos, and
	velVel - which can be multiplied with position and velocity like so:

	local newPosition = oldPosition * posPos + oldVelocity * posVel
	local newVelocity = oldPosition * velPos + oldVelocity * velVel

	Special thanks to AxisAngle for helping to improve numerical precision.
]]

local function springCoefficients(time: number, damping: number, speed: number): (number, number, number, number)
	-- if time or speed is 0, then the spring won't move
	if time == 0 or speed == 0 then
		return 1, 0, 0, 1
	end
	local posPos, posVel, velPos, velVel

	if damping > 1 then
		-- overdamped spring
		-- solution to the characteristic equation:
		-- z = -  Sqrt[^2 - 1] 
		-- x[t] -> x0(e^(t z2) z1 - e^(t z1) z2)/(z1 - z2)
		--		 + v0(e^(t z1) - e^(t z2))/(z1 - z2)
		-- v[t] -> x0(z1 z2(-e^(t z1) + e^(t z2)))/(z1 - z2)
		--		 + v0(z1 e^(t z1) - z2 e^(t z2))/(z1 - z2)

		local scaledTime = time * speed
		local alpha = math.sqrt(damping^2 - 1)
		local scaledInvAlpha = -0.5 / alpha
		local z1 = -alpha - damping
		local z2 = 1 / z1
		local expZ1 = math.exp(scaledTime * z1)
		local expZ2 = math.exp(scaledTime * z2)

		posPos = (expZ2*z1 - expZ1*z2) * scaledInvAlpha
		posVel = (expZ1 - expZ2) * scaledInvAlpha / speed
		velPos = (expZ2 - expZ1) * scaledInvAlpha * speed
		velVel = (expZ1*z1 - expZ2*z2) * scaledInvAlpha

	elseif damping == 1 then
		-- critically damped spring
		-- x[t] -> x0(e^-t)(1+t) + v0(e^-t)t
		-- v[t] -> x0(t ^2)(-e^-t) + v0(1 - t)(e^-t)

		local scaledTime = time * speed
		local expTerm = math.exp(-scaledTime)

		posPos = expTerm * (1 + scaledTime)
		posVel = expTerm * time
		velPos = expTerm * (-scaledTime*speed)
		velVel = expTerm * (1 - scaledTime)

	else
		-- underdamped spring
		-- factored out of the solutions to the characteristic equation:
		--  = Sqrt[1 - ^2]
		-- x[t] -> x0(e^-t)( Cos[t] +  Sin[t])/
		--       + v0(e^-t)(Sin[t])/
		-- v[t] -> x0(-e^-t)(^2 + ^2 ^2)(Sin[t])/
		--       + v0(e^-t)( Cos[t] -  Sin[t])/

		local scaledTime = time * speed
		local alpha = math.sqrt(1 - damping^2)
		local invAlpha = 1 / alpha
		local alphaTime = alpha * scaledTime
		local expTerm = math.exp(-scaledTime*damping)
		local sinTerm = expTerm * math.sin(alphaTime)
		local cosTerm = expTerm * math.cos(alphaTime)
		local sinInvAlpha = sinTerm*invAlpha
		local sinInvAlphaDamp = sinInvAlpha*damping

		posPos = sinInvAlphaDamp + cosTerm
		posVel = sinInvAlpha
		velPos = -(sinInvAlphaDamp*damping + sinTerm*alpha)
		velVel = cosTerm - sinInvAlphaDamp
	end

	return posPos, posVel, velPos, velVel
end

return springCoefficients]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4a557b90a249432a91496debce57170a">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">unpackType</string>
									<string name="ScriptGuid">{1be1f29b-f4b7-4944-85df-28dc517b0886}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Unpacks an animatable type into an array of numbers.
	If the type is not animatable, an empty array will be returned.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function unpackType(value: any, typeString: string): {number}
	if typeString == "number" then
		local value = value :: number
		return {value}

	elseif typeString == "CFrame" then
		-- FUTURE: is there a better way of doing this? doing distance
		-- calculations on `angle` may be incorrect
		local axis, angle = value:ToAxisAngle()
		return {value.X, value.Y, value.Z, axis.X, axis.Y, axis.Z, angle}

	elseif typeString == "Color3" then
		local lab = Oklab.to(value)
		return {lab.X, lab.Y, lab.Z}

	elseif typeString == "ColorSequenceKeypoint" then
		local lab = Oklab.to(value.Value)
		return {lab.X, lab.Y, lab.Z, value.Time}

	elseif typeString == "DateTime" then
		return {value.UnixTimestampMillis}

	elseif typeString == "NumberRange" then
		return {value.Min, value.Max}

	elseif typeString == "NumberSequenceKeypoint" then
		return {value.Value, value.Time, value.Envelope}

	elseif typeString == "PhysicalProperties" then
		return {value.Density, value.Friction, value.Elasticity, value.FrictionWeight, value.ElasticityWeight}

	elseif typeString == "Ray" then
		return {value.Origin.X, value.Origin.Y, value.Origin.Z, value.Direction.X, value.Direction.Y, value.Direction.Z}

	elseif typeString == "Rect" then
		return {value.Min.X, value.Min.Y, value.Max.X, value.Max.Y}

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		return {
			value.CFrame.X, value.CFrame.Y, value.CFrame.Z,
			value.Size.X, value.Size.Y, value.Size.Z
		}

	elseif typeString == "Region3int16" then
		return {value.Min.X, value.Min.Y, value.Min.Z, value.Max.X, value.Max.Y, value.Max.Z}

	elseif typeString == "UDim" then
		return {value.Scale, value.Offset}

	elseif typeString == "UDim2" then
		return {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset}

	elseif typeString == "Vector2" then
		return {value.X, value.Y}

	elseif typeString == "Vector2int16" then
		return {value.X, value.Y}

	elseif typeString == "Vector3" then
		return {value.X, value.Y, value.Z}

	elseif typeString == "Vector3int16" then
		return {value.X, value.Y, value.Z}
	else
		return {}
	end
end

return unpackType]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXdad844f708094094a299c48d761af1fb">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Colour</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX331bb50bfd9d489cbfbaa75562f50bdc">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Oklab</string>
									<string name="ScriptGuid">{0370253c-0189-45a2-92ef-938b9c2ccc45}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Provides functions for converting Color3s into Oklab space, for more
	perceptually uniform colour blending.

	See: https://bottosson.github.io/posts/oklab/
]]

local Oklab = {}

-- Converts a Color3 in RGB space to a Vector3 in Oklab space.
function Oklab.to(rgb: Color3): Vector3
	local l = rgb.R * 0.4122214708 + rgb.G * 0.5363325363 + rgb.B * 0.0514459929
	local m = rgb.R * 0.2119034982 + rgb.G * 0.6806995451 + rgb.B * 0.1073969566
	local s = rgb.R * 0.0883024619 + rgb.G * 0.2817188376 + rgb.B * 0.6299787005

	local lRoot = l ^ (1/3)
	local mRoot = m ^ (1/3)
	local sRoot = s ^ (1/3)

	return Vector3.new(
		lRoot * 0.2104542553 + mRoot * 0.7936177850 - sRoot * 0.0040720468,
		lRoot * 1.9779984951 - mRoot * 2.4285922050 + sRoot * 0.4505937099,
		lRoot * 0.0259040371 + mRoot * 0.7827717662 - sRoot * 0.8086757660
	)
end

-- Converts a Vector3 in CIELAB space to a Color3 in RGB space.
-- The Color3 will be clamped by default unless specified otherwise.
function Oklab.from(lab: Vector3, unclamped: boolean?): Color3
	local lRoot = lab.X + lab.Y * 0.3963377774 + lab.Z * 0.2158037573
	local mRoot = lab.X - lab.Y * 0.1055613458 - lab.Z * 0.0638541728
	local sRoot = lab.X - lab.Y * 0.0894841775 - lab.Z * 1.2914855480

	local l = lRoot ^ 3
	local m = mRoot ^ 3
	local s = sRoot ^ 3

	local red = l * 4.0767416621 - m * 3.3077115913 + s * 0.2309699292
	local green = l * -1.2684380046 + m * 2.6097574011 - s * 0.3413193965
	local blue = l * -0.0041960863 - m * 0.7034186147 + s * 1.7076147010

	if not unclamped then
		red = math.clamp(red, 0, 1)
		green = math.clamp(green, 0, 1)
		blue = math.clamp(blue, 0, 1)
	end

	return Color3.new(red, green, blue)
end

return Oklab]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX7f13d6976b9749a7bf59e247f8b2fb66">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Dependencies</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX811926dceb21484a9d19f09c153de264">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">captureDependencies</string>
									<string name="ScriptGuid">{2293c5b1-f2a4-413b-9d9a-4a7f815dab5b}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Calls the given callback, and stores any used external dependencies.
	Arguments can be passed in after the callback.
	If the callback completed successfully, returns true and the returned value,
	otherwise returns false and the error thrown.
	The callback shouldn't yield or run asynchronously.

	NOTE: any calls to useDependency() inside the callback (even if inside any
	nested captureDependencies() call) will not be included in the set, to avoid
	self-dependencies.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local parseError = require(Package.Logging.parseError)
local sharedState = require(Package.Dependencies.sharedState)

type Set<T> = {[T]: any}

local initialisedStack = sharedState.initialisedStack
local initialisedStackCapacity = 0

local function captureDependencies(
	saveToSet: Set<PubTypes.Dependency>,
	callback: (...any) -> any,
	...
): (boolean, any)

	local prevDependencySet = sharedState.dependencySet
	sharedState.dependencySet = saveToSet

	sharedState.initialisedStackSize += 1
	local initialisedStackSize = sharedState.initialisedStackSize

	local initialisedSet
	if initialisedStackSize > initialisedStackCapacity then
		initialisedSet = {}
		initialisedStack[initialisedStackSize] = initialisedSet
		initialisedStackCapacity = initialisedStackSize
	else
		initialisedSet = initialisedStack[initialisedStackSize]
		table.clear(initialisedSet)
	end

	local data = table.pack(xpcall(callback, parseError, ...))

	sharedState.dependencySet = prevDependencySet
	sharedState.initialisedStackSize -= 1

	return table.unpack(data, 1, data.n)
end

return captureDependencies]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXbe9f13d68812459b823be236186a74c2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">initDependency</string>
									<string name="ScriptGuid">{d0dc84af-49b7-44d5-bb9b-5ff31bcd2193}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Registers the creation of an object which can be used as a dependency.

	This is used to make sure objects don't capture dependencies originating
	from inside of themselves.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function initDependency(dependency: PubTypes.Dependency)
	local initialisedStackSize = sharedState.initialisedStackSize

	for index, initialisedSet in ipairs(initialisedStack) do
		if index > initialisedStackSize then
			return
		end

		initialisedSet[dependency] = true
	end
end

return initDependency]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6ec320a61dab4b4980134c14a2fd2b9e">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">sharedState</string>
									<string name="ScriptGuid">{41454646-1139-4088-a8da-8f43e5149fee}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores shared state for dependency management functions.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}

-- The set where used dependencies should be saved to.
local dependencySet: Set<PubTypes.Dependency>? = nil

-- A stack of sets where newly created dependencies should be stored.
local initialisedStack: {Set<PubTypes.Dependency>} = {}
local initialisedStackSize = 0

return {
	dependencySet = dependencySet,
	initialisedStack = initialisedStack,
	initialisedStackSize = initialisedStackSize
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXf9392934409e4559b8638c7da2bc4b14">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">updateAll</string>
									<string name="ScriptGuid">{51865e82-fe49-4c29-83d1-880de50de35b}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Given a reactive object, updates all dependent reactive objects.
	Objects are only ever updated after all of their dependencies are updated,
	are only ever updated once, and won't be updated if their dependencies are
	unchanged.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}
type Descendant = (PubTypes.Dependent & PubTypes.Dependency) | PubTypes.Dependent

-- Credit: https://blog.elttob.uk/2022/11/07/sets-efficient-topological-search.html
local function updateAll(root: PubTypes.Dependency)
	local counters: {[Descendant]: number} = {}
	local flags: {[Descendant]: boolean} = {}
	local queue: {Descendant} = {}
	local queueSize = 0
	local queuePos = 1

	for object in root.dependentSet do
		queueSize += 1
		queue[queueSize] = object
		flags[object] = true
	end

	-- Pass 1: counting up
	while queuePos <= queueSize do
		local next = queue[queuePos]
		local counter = counters[next]
		counters[next] = if counter == nil then 1 else counter + 1
		if (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				queueSize += 1
				queue[queueSize] = object
			end
		end
		queuePos += 1
	end

	-- Pass 2: counting down + processing
	queuePos = 1
	while queuePos <= queueSize do
		local next = queue[queuePos]
		local counter = counters[next] - 1
		counters[next] = counter
		if counter == 0 and flags[next] and next:update() and (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				flags[object] = true
			end
		end
		queuePos += 1
	end
end

return updateAll]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1e7d0fc01e2e4271bacc9e1f4a1e9f29">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">useDependency</string>
									<string name="ScriptGuid">{9ecb79bc-e281-49d0-8fec-3767511baa1a}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	If a target set was specified by captureDependencies(), this will add the
	given dependency to the target set.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function useDependency(dependency: PubTypes.Dependency)
	local dependencySet = sharedState.dependencySet

	if dependencySet ~= nil then
		local initialisedStackSize = sharedState.initialisedStackSize
		if initialisedStackSize > 0 then
			local initialisedSet = initialisedStack[initialisedStackSize]
			if initialisedSet[dependency] ~= nil then
				return
			end
		end
		dependencySet[dependency] = true
	end
end

return useDependency]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX9acb8986f7fe4b35b30ef164ff4d1380">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Instances</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX1411d170af8c4b0fbbc4abd7feafdff8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Children</string>
									<string name="ScriptGuid">{e2ae870a-953b-4c07-88fa-d6046a6b7f60}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which parents any given descendants into
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logWarn = require(Package.Logging.logWarn)
local Observer = require(Package.State.Observer)
local xtypeof = require(Package.Utility.xtypeof)

type Set<T> = {[T]: boolean}

-- Experimental flag: name children based on the key used in the [Children] table
local EXPERIMENTAL_AUTO_NAMING = false

local Children = {}
Children.type = "SpecialKey"
Children.kind = "Children"
Children.stage = "descendants"

function Children:apply(propValue: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	local newParented: Set<Instance> = {}
	local oldParented: Set<Instance> = {}

	-- save disconnection functions for state object observers
	local newDisconnects: {[PubTypes.StateObject<any>]: () -> ()} = {}
	local oldDisconnects: {[PubTypes.StateObject<any>]: () -> ()} = {}

	local updateQueued = false
	local queueUpdate: () -> ()

	-- Rescans this key's value to find new instances to parent and state objects
	-- to observe for changes; then unparents instances no longer found and
	-- disconnects observers for state objects no longer present.
	local function updateChildren()
		if not updateQueued then
			return -- this update may have been canceled by destruction, etc.
		end
		updateQueued = false

		oldParented, newParented = newParented, oldParented
		oldDisconnects, newDisconnects = newDisconnects, oldDisconnects
		table.clear(newParented)
		table.clear(newDisconnects)

		local function processChild(child: any, autoName: string?)
			local kind = xtypeof(child)

			if kind == "Instance" then
				-- case 1; single instance

				newParented[child] = true
				if oldParented[child] == nil then
					-- wasn't previously present

					-- TODO: check for ancestry conflicts here
					child.Parent = applyTo
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldParented[child] = nil
				end

				if EXPERIMENTAL_AUTO_NAMING and autoName ~= nil then
					child.Name = autoName
				end

			elseif kind == "State" then
				-- case 2; state object

				local value = child:get(false)
				-- allow nil to represent the absence of a child
				if value ~= nil then
					processChild(value, autoName)
				end

				local disconnect = oldDisconnects[child]
				if disconnect == nil then
					-- wasn't previously present
					disconnect = Observer(child):onChange(queueUpdate)
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldDisconnects[child] = nil
				end

				newDisconnects[child] = disconnect

			elseif kind == "table" then
				-- case 3; table of objects

				for key, subChild in pairs(child) do
					local keyType = typeof(key)
					local subAutoName: string? = nil

					if keyType == "string" then
						subAutoName = key
					elseif keyType == "number" and autoName ~= nil then
						subAutoName = autoName .. "_" .. key
					end

					processChild(subChild, subAutoName)
				end

			else
				logWarn("unrecognisedChildType", kind)
			end
		end

		if propValue ~= nil then
			-- `propValue` is set to nil on cleanup, so we don't process children
			-- in that case
			processChild(propValue)
		end

		-- unparent any children that are no longer present
		for oldInstance in pairs(oldParented) do
			oldInstance.Parent = nil
		end

		-- disconnect observers which weren't reused
		for oldState, disconnect in pairs(oldDisconnects) do
			disconnect()
		end
	end

	queueUpdate = function()
		if not updateQueued then
			updateQueued = true
			task.defer(updateChildren)
		end
	end

	table.insert(cleanupTasks, function()
		propValue = nil
		updateQueued = true
		updateChildren()
	end)

	-- perform initial child parenting
	updateQueued = true
	updateChildren()
end

return Children :: PubTypes.SpecialKey]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX08f6e79f38e54d1393749a78e25cc990">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Cleanup</string>
									<string name="ScriptGuid">{5b2edd62-a337-4967-ab2b-82abc7a42538}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which adds user-specified tasks to be run
	when the instance is destroyed.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

local Cleanup = {}
Cleanup.type = "SpecialKey"
Cleanup.kind = "Cleanup"
Cleanup.stage = "observer"

function Cleanup:apply(userTask: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	table.insert(cleanupTasks, userTask)
end

return Cleanup]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3bccf1056f974f3487ad935feb7d6cca">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Hydrate</string>
									<string name="ScriptGuid">{70b076e1-efce-4cd9-bfd1-531a8e405a42}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Processes and returns an existing instance, with options for setting
	properties, event handlers and other attributes on the instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)

local function Hydrate(target: Instance)
	return function(props: PubTypes.PropertyTable): Instance
		applyInstanceProps(props, target)
		return target
	end
end

return Hydrate]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXc67731fe9a654a408a7ab3c507211832">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">New</string>
									<string name="ScriptGuid">{17269b02-e239-41c0-8cdb-534ff352c942}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs and returns a new instance, with options for setting properties,
	event handlers and other attributes on the instance right away.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local defaultProps = require(Package.Instances.defaultProps)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)
local logError= require(Package.Logging.logError)

local function New(className: string)
	return function(props: PubTypes.PropertyTable): Instance
		local ok, instance = pcall(Instance.new, className)

		if not ok then
			logError("cannotCreateClass", nil, className)
		end

		local classDefaults = defaultProps[className]
		if classDefaults ~= nil then
			for defaultProp, defaultValue in pairs(classDefaults) do
				instance[defaultProp] = defaultValue
			end
		end

		applyInstanceProps(props, instance)

		return instance
	end
end

return New]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX44e5e541ff14421da410725073286ef6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">OnChange</string>
									<string name="ScriptGuid">{41d701be-0104-48ab-b6ad-4077a82e8ef7}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs special keys for property tables which connect property change
	listeners to an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function OnChange(propertyName: string): PubTypes.SpecialKey
	local changeKey = {}
	changeKey.type = "SpecialKey"
	changeKey.kind = "OnChange"
	changeKey.stage = "observer"

	function changeKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("cannotConnectChange", nil, applyTo.ClassName, propertyName)
		elseif typeof(callback) ~= "function" then
			logError("invalidChangeHandler", nil, propertyName)
		else
			table.insert(cleanupTasks, event:Connect(function()
				callback((applyTo :: any)[propertyName])
			end))
		end
	end

	return changeKey
end

return OnChange]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXe35fd715882144ed8c61c44ae930e0bd">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">OnEvent</string>
									<string name="ScriptGuid">{c9fdc9aa-2ee5-4de9-82cf-eff24765f1ff}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs special keys for property tables which connect event listeners to
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function getProperty_unsafe(instance: Instance, property: string)
	return (instance :: any)[property]
end

local function OnEvent(eventName: string): PubTypes.SpecialKey
	local eventKey = {}
	eventKey.type = "SpecialKey"
	eventKey.kind = "OnEvent"
	eventKey.stage = "observer"

	function eventKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(getProperty_unsafe, applyTo, eventName)
		if not ok or typeof(event) ~= "RBXScriptSignal" then
			logError("cannotConnectEvent", nil, applyTo.ClassName, eventName)
		elseif typeof(callback) ~= "function" then
			logError("invalidEventHandler", nil, eventName)
		else
			table.insert(cleanupTasks, event:Connect(callback))
		end
	end

	return eventKey
end

return OnEvent]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXc5b2d21d52ff419283ca768b831cbacc">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Out</string>
									<string name="ScriptGuid">{f48a7b7e-0eac-4aae-9e15-4349b4602bb0}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which allows users to extract values from
	an instance into an automatically-updated Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local function Out(propertyName: string): PubTypes.SpecialKey
	local outKey = {}
	outKey.type = "SpecialKey"
	outKey.kind = "Out"
	outKey.stage = "observer"

	function outKey:apply(outState: any, applyTo: Instance, cleanupTasks: { PubTypes.Task })
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("invalidOutProperty", nil, applyTo.ClassName, propertyName)
		elseif xtypeof(outState) ~= "State" or outState.kind ~= "Value" then
			logError("invalidOutType")
		else
			outState:set((applyTo :: any)[propertyName])
			table.insert(
				cleanupTasks,
				event:Connect(function()
					outState:set((applyTo :: any)[propertyName])
				end)
			)
			table.insert(cleanupTasks, function()
				outState:set(nil)
			end)
		end
	end

	return outKey
end

return Out]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX94ac3fbd2c2d4edba4fc2d9b3ff617fb">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Ref</string>
									<string name="ScriptGuid">{2e19aad9-bd35-4d1e-b115-c7f274bba976}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which stores a reference to the instance
	in a user-provided Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local Ref = {}
Ref.type = "SpecialKey"
Ref.kind = "Ref"
Ref.stage = "observer"

function Ref:apply(refState: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	if xtypeof(refState) ~= "State" or refState.kind ~= "Value" then
		logError("invalidRefType")
	else
		refState:set(applyTo)
		table.insert(cleanupTasks, function()
			refState:set(nil)
		end)
	end
end

return Ref]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX213e7dcfab954f368c57018c8cc3a696">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">applyInstanceProps</string>
									<string name="ScriptGuid">{aad0a5e4-3e5c-41c0-bf58-7b0a499c9cbe}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Applies a table of properties to an instance, including binding to any
	given state objects and applying any special keys.

	No strong reference is kept by default - special keys should take care not
	to accidentally hold strong references to instances forever.

	If a key is used twice, an error will be thrown. This is done to avoid
	double assignments or double bindings. However, some special keys may want
	to enable such assignments - in which case unique keys should be used for
	each occurence.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local cleanup = require(Package.Utility.cleanup)
local xtypeof = require(Package.Utility.xtypeof)
local logError = require(Package.Logging.logError)
local Observer = require(Package.State.Observer)

local function setProperty_unsafe(instance: Instance, property: string, value: any)
	(instance :: any)[property] = value
end

local function testPropertyAssignable(instance: Instance, property: string)
	(instance :: any)[property] = (instance :: any)[property]
end

local function setProperty(instance: Instance, property: string, value: any)
	if not pcall(setProperty_unsafe, instance, property, value) then
		if not pcall(testPropertyAssignable, instance, property) then
			if instance == nil then
				-- reference has been lost
				logError("setPropertyNilRef", nil, property, tostring(value))
			else
				-- property is not assignable
				logError("cannotAssignProperty", nil, instance.ClassName, property)
			end
		else
			-- property is assignable, but this specific assignment failed
			-- this typically implies the wrong type was received
			local givenType = typeof(value)
			local expectedType = typeof((instance :: any)[property])
			logError("invalidPropertyType", nil, instance.ClassName, property, expectedType, givenType)
		end
	end
end

local function bindProperty(instance: Instance, property: string, value: PubTypes.CanBeState<any>, cleanupTasks: {PubTypes.Task})
	if xtypeof(value) == "State" then
		-- value is a state object - assign and observe for changes
		local willUpdate = false
		local function updateLater()
			if not willUpdate then
				willUpdate = true
				task.defer(function()
					willUpdate = false
					setProperty(instance, property, value:get(false))
				end)
			end
		end

		setProperty(instance, property, value:get(false))
		table.insert(cleanupTasks, Observer(value :: any):onChange(updateLater))
	else
		-- value is a constant - assign once only
		setProperty(instance, property, value)
	end
end

local function applyInstanceProps(props: PubTypes.PropertyTable, applyTo: Instance)
	local specialKeys = {
		self = {} :: {[PubTypes.SpecialKey]: any},
		descendants = {} :: {[PubTypes.SpecialKey]: any},
		ancestor = {} :: {[PubTypes.SpecialKey]: any},
		observer = {} :: {[PubTypes.SpecialKey]: any}
	}
	local cleanupTasks = {}

	for key, value in pairs(props) do
		local keyType = xtypeof(key)

		if keyType == "string" then
			if key ~= "Parent" then
				bindProperty(applyTo, key :: string, value, cleanupTasks)
			end
		elseif keyType == "SpecialKey" then
			local stage = (key :: PubTypes.SpecialKey).stage
			local keys = specialKeys[stage]
			if keys == nil then
				logError("unrecognisedPropertyStage", nil, stage)
			else
				keys[key] = value
			end
		else
			-- we don't recognise what this key is supposed to be
			logError("unrecognisedPropertyKey", nil, xtypeof(key))
		end
	end

	for key, value in pairs(specialKeys.self) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.descendants) do
		key:apply(value, applyTo, cleanupTasks)
	end

	if props.Parent ~= nil then
		bindProperty(applyTo, "Parent", props.Parent, cleanupTasks)
	end

	for key, value in pairs(specialKeys.ancestor) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.observer) do
		key:apply(value, applyTo, cleanupTasks)
	end

	applyTo.Destroying:Connect(function()
		cleanup(cleanupTasks)
	end)
end

return applyInstanceProps]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9c0e3b04b02b4ecbbde3d1a3d8c74996">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">defaultProps</string>
									<string name="ScriptGuid">{12af1d2d-25e7-4490-93fe-d392a07d16e0}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

return {
	ScreenGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	BillboardGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	SurfaceGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,

		SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud,
		PixelsPerStud = 50
	},

	Frame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ScrollingFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ScrollBarImageColor3 = Color3.new(0, 0, 0)
	},

	TextLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextBox = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ClearTextOnFocus = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	ImageLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ImageButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false
	},

	ViewportFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	VideoFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},
	
	CanvasGroup = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	}
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXa468e8dcbe434095a1d988ba5fc8c4a4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Logging</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXbb705056841c4a53bdd9b17fa7550d38">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">logError</string>
									<string name="ScriptGuid">{976662c0-a021-4052-9eef-47ae46058cc1}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific error.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logError(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	error(errorString:gsub("\n", "\n    "), 0)
end

return logError]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX48f3fd57536f4eb785db6a739bfac2bd">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">logErrorNonFatal</string>
									<string name="ScriptGuid">{c4fe3fd1-8ec0-4c07-97f0-221a5cfb9cbd}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific error, without halting execution.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logErrorNonFatal(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	task.spawn(function(...)
		error(errorString:gsub("\n", "\n    "), 0)
	end, ...)
end

return logErrorNonFatal]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXb8e862517c464fe589006b281d9add13">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">logWarn</string>
									<string name="ScriptGuid">{c28b557e-dfc9-4663-8e24-f3c2ae9be68f}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific warning.
]]

local Package = script.Parent.Parent
local messages = require(Package.Logging.messages)

local function logWarn(messageID, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	warn(string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...))
end

return logWarn]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4a8fc5cf264f44cd818f830630cd394d">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">messages</string>
									<string name="ScriptGuid">{7025647f-aa8f-451a-b275-11b3c7d467b8}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores templates for different kinds of logging messages.
]]

return {
	cannotAssignProperty = "The class type '%s' has no assignable property '%s'.",
	cannotConnectChange = "The %s class doesn't have a property called '%s'.",
	cannotConnectEvent = "The %s class doesn't have an event called '%s'.",
	cannotCreateClass = "Can't create a new instance of class '%s'.",
	computedCallbackError = "Computed callback error: ERROR_MESSAGE",
	destructorNeededValue = "To save instances into Values, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededComputed = "To return instances from Computeds, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	multiReturnComputed = "Returning multiple values from Computeds is discouraged, as behaviour will change soon - see discussion #189 on GitHub.",
	destructorNeededForKeys = "To return instances from ForKeys, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForValues = "To return instances from ForValues, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForPairs = "To return instances from ForPairs, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	duplicatePropertyKey = "",
	forKeysProcessorError = "ForKeys callback error: ERROR_MESSAGE",
	forKeysKeyCollision = "ForKeys should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previously input key: '%s'; New input key: '%s'",
	forKeysDestructorError = "ForKeys destructor error: ERROR_MESSAGE",
	forPairsDestructorError = "ForPairs destructor error: ERROR_MESSAGE",
	forPairsKeyCollision = "ForPairs should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previous input pair: '[%s] = %s'; New input pair: '[%s] = %s'",
	forPairsProcessorError = "ForPairs callback error: ERROR_MESSAGE",
	forValuesProcessorError = "ForValues callback error: ERROR_MESSAGE",
	forValuesDestructorError = "ForValues destructor error: ERROR_MESSAGE",
	invalidChangeHandler = "The change handler for the '%s' property must be a function.",
	invalidEventHandler = "The handler for the '%s' event must be a function.",
	invalidPropertyType = "'%s.%s' expected a '%s' type, but got a '%s' type.",
	invalidRefType = "Instance refs must be Value objects.",
	invalidOutType = "[Out] properties must be given Value objects.",
	invalidOutProperty = "The %s class doesn't have a property called '%s'.",
	invalidSpringDamping = "The damping ratio for a spring must be >= 0. (damping was %.2f)",
	invalidSpringSpeed = "The speed of a spring must be >= 0. (speed was %.2f)",
	mistypedSpringDamping = "The damping ratio for a spring must be a number. (got a %s)",
	mistypedSpringSpeed = "The speed of a spring must be a number. (got a %s)",
	mistypedTweenInfo = "The tween info of a tween must be a TweenInfo. (got a %s)",
	springTypeMismatch = "The type '%s' doesn't match the spring's type '%s'.",
	strictReadError = "'%s' is not a valid member of '%s'.",
	unknownMessage = "Unknown error: ERROR_MESSAGE",
	unrecognisedChildType = "'%s' type children aren't accepted by `[Children]`.",
	unrecognisedPropertyKey = "'%s' keys aren't accepted in property tables.",
	unrecognisedPropertyStage = "'%s' isn't a valid stage for a special key to be applied at."
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3c82cd3df79e42fca8c86e5840f3246f">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">parseError</string>
									<string name="ScriptGuid">{e7b39f37-0c45-4219-a923-884e0abc8919}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	An xpcall() error handler to collect and parse useful information about
	errors, such as clean messages and stack traces.

	TODO: this should have a 'type' field for runtime type checking!
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function parseError(err: string): Types.Error
	return {
		type = "Error",
		raw = err,
		message = err:gsub("^.+:%d+:%s*", ""),
		trace = debug.traceback(nil, 2)
	}
end

return parseError]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXf201800f67a741f9bef9cfa14ccfff48">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PubTypes</string>
								<string name="ScriptGuid">{710dc43d-06c9-4778-a2a7-71348e0f8061}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores common public-facing type information for Fusion APIs.
]]

type Set<T> = {[T]: any}

--[[
	General use types
]]

-- A unique symbolic value.
export type Symbol = {
	type: string, -- replace with "Symbol" when Luau supports singleton types
	name: string
}

-- Types that can be expressed as vectors of numbers, and so can be animated.
export type Animatable =
	number |
	CFrame |
	Color3 |
	ColorSequenceKeypoint |
	DateTime |
	NumberRange |
	NumberSequenceKeypoint |
	PhysicalProperties |
	Ray |
	Rect |
	Region3 |
	Region3int16 |
	UDim |
	UDim2 |
	Vector2 |
	Vector2int16 |
	Vector3 |
	Vector3int16

-- A task which can be accepted for cleanup.
export type Task =
	Instance |
	RBXScriptConnection |
	() -> () |
	{destroy: (any) -> ()} |
	{Destroy: (any) -> ()} |
	{Task}

-- Script-readable version information.
export type Version = {
	major: number,
	minor: number,
	isRelease: boolean
}
--[[
	Generic reactive graph types
]]

-- A graph object which can have dependents.
export type Dependency = {
	dependentSet: Set<Dependent>
}

-- A graph object which can have dependencies.
export type Dependent = {
	update: (Dependent) -> boolean,
	dependencySet: Set<Dependency>
}

-- An object which stores a piece of reactive state.
export type StateObject<T> = Dependency & {
	type: string, -- replace with "State" when Luau supports singleton types
	kind: string,
	get: (StateObject<T>, asDependency: boolean?) -> T
}

-- Either a constant value of type T, or a state object containing type T.
export type CanBeState<T> = StateObject<T> | T

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type Value<T> = StateObject<T> & {
	-- kind: "State" (add this when Luau supports singleton types)
 	set: (Value<T>, newValue: any, force: boolean?) -> ()
}

-- A state object whose value is derived from other objects using a callback.
export type Computed<T> = StateObject<T> & Dependent & {
	-- kind: "Computed" (add this when Luau supports singleton types)
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs<KO, VO> = StateObject<{ [KO]: VO }> & Dependent & {
	-- kind: "ForPairs" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForKeys<KO, V> = StateObject<{ [KO]: V }> & Dependent & {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForValues<K, VO> = StateObject<{ [K]: VO }> & Dependent & {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using tweens.
export type Tween<T> = StateObject<T> & Dependent & {
	-- kind: "Tween" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using spring simulation.
export type Spring<T> = StateObject<T> & Dependent & {
	-- kind: "Spring" (add this when Luau supports singleton types)
	-- Uncomment when ENABLE_PARAM_SETTERS is enabled
	-- setPosition: (Spring<T>, newValue: Animatable) -> (),
	-- setVelocity: (Spring<T>, newValue: Animatable) -> (),
	-- addVelocity: (Spring<T>, deltaValue: Animatable) -> ()
}

-- An object which can listen for updates on another state object.
export type Observer = Dependent & {
	-- kind: "Observer" (add this when Luau supports singleton types)
  	onChange: (Observer, callback: () -> ()) -> (() -> ())
}

--[[
	Instance related types
]]

-- Denotes children instances in an instance or component's property table.
export type SpecialKey = {
	type: string, -- replace with "SpecialKey" when Luau supports singleton types
	kind: string,
	stage: string, -- replace with "self" | "descendants" | "ancestor" | "observer" when Luau supports singleton types
	apply: (SpecialKey, value: any, applyTo: Instance, cleanupTasks: {Task}) -> ()
}

-- A collection of instances that may be parented to another instance.
export type Children = Instance | StateObject<Children> | {[any]: Children}

-- A table that defines an instance's properties, handlers and children.
export type PropertyTable = {[string | SpecialKey]: any}

return nil]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX192ecd134c4d4159a8fd50b39d8f613b">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">State</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXb625f3d96ace4df2a3fc5babbdf54795">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Computed</string>
									<string name="ScriptGuid">{bf076f34-ac1c-4d18-a1fd-3767224080ce}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs and returns objects which can be used to model derived reactive
	state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local isSimilar = require(Package.Utility.isSimilar)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the last cached value calculated by this Computed object.
	The computed object will be registered as a dependency unless `asDependency`
	is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Recalculates this Computed's cached value and dependencies.
	Returns true if it changed, or false if it's identical.
]]
function class:update(): boolean
	-- remove this object from its dependencies' dependent sets
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	-- we need to create a new, empty dependency set to capture dependencies
	-- into, but in case there's an error, we want to restore our old set of
	-- dependencies. by using this table-swapping solution, we can avoid the
	-- overhead of allocating new tables each update.
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	local ok, newValue, newMetaValue = captureDependencies(self.dependencySet, self._processor)

	if ok then
		if self._destructor == nil and needsDestruction(newValue) then
			logWarn("destructorNeededComputed")
		end

		if newMetaValue ~= nil then
			logWarn("multiReturnComputed")
		end

		local oldValue = self._value
		local similar = isSimilar(oldValue, newValue)
		if self._destructor ~= nil then
			self._destructor(oldValue)
		end
		self._value = newValue

		-- add this object to the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return not similar
	else
		-- this needs to be non-fatal, because otherwise it'd disrupt the
		-- update process
		logErrorNonFatal("computedCallbackError", newValue)

		-- restore old dependencies, because the new dependencies may be corrupt
		self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet

		-- restore this object in the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return false
	end
end

local function Computed<T>(processor: () -> T, destructor: ((T) -> ())?): Types.Computed<T>
	local self = setmetatable({
		type = "State",
		kind = "Computed",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},
		_processor = processor,
		_destructor = destructor,
		_value = nil,
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return Computed]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXdf18431fa456419a8af233b39ddbcaa6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ForKeys</string>
									<string name="ScriptGuid">{c61c4baa-0222-4247-b074-94323391bb4e}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForKeys state object which maps keys of an array using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up
	calculated keys. If omitted, the default cleanup function will be used instead.

	Optionally, a `meta` value can be returned in the processor function as the
	second value to pass data from the processor to the destructor.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForKeys object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end


--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those key pairs, storing information about any
	dependencies used in the processor callback during output key generation,
	and save the new key to the output array with the same value. If it is
	overwriting an older value, that older value will be passed to the
	destructor for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their output keys from the output table and pass them to the destructor.
]]

function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable
	local outputTable = self._outputTable

	local keyOIMap = self._keyOIMap
	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find keys that changed or were not previously present
	for newInKey, value in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end

		-- check if the key is new
		local shouldRecalculate = oldInputTable[newInKey] == nil

		-- check if the key's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output key if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForKeys")
				end

				local oldInKey = keyOIMap[newOutKey]
				local oldOutKey = keyIOMap[newInKey]

				-- check for key collision
				if oldInKey ~= newInKey and newInputTable[oldInKey] ~= nil then
					logError("forKeysKeyCollision", nil, tostring(newOutKey), tostring(oldInKey), tostring(newOutKey))
				end

				-- check for a changed output key
				if oldOutKey ~= newOutKey and keyOIMap[oldOutKey] == newInKey then
					-- clean up the old calculated value
					local oldMetaValue = meta[oldOutKey]

					local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldMetaValue)
					if not destructOK then
						logErrorNonFatal("forKeysDestructorError", err)
					end

					keyOIMap[oldOutKey] = nil
					outputTable[oldOutKey] = nil
					meta[oldOutKey] = nil
				end

				-- update the stored data for this key
				oldInputTable[newInKey] = value
				meta[newOutKey] = newMetaValue
				keyOIMap[newOutKey] = newInKey
				keyIOMap[newInKey] = newOutKey
				outputTable[newOutKey] = value

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forKeysProcessorError", newOutKey)
			end
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find keys that were removed
	for outputKey, inputKey in pairs(keyOIMap) do
		if newInputTable[inputKey] == nil then
			-- clean up the old calculated value
			local oldMetaValue = meta[outputKey]

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, outputKey, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forKeysDestructorError", err)
			end

			-- remove data
			oldInputTable[inputKey] = nil
			meta[outputKey] = nil
			keyOIMap[outputKey] = nil
			keyIOMap[inputKey] = nil
			outputTable[outputKey] = nil
			self._keyData[inputKey] = nil

			-- if we removed a key, then the table/state changed
			didChange = true
		end
	end

	return didChange
end

local function ForKeys<KI, KO, M>(
	inputTable: PubTypes.CanBeState<{ [KI]: any }>,
	processor: (KI) -> (KO, M?),
	destructor: (KO, M?) -> ()?
): Types.ForKeys<KI, KO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForKeys",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_keyOIMap = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForKeys]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7e4053b62494412e9765da44cb1e7caf">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ForPairs</string>
									<string name="ScriptGuid">{455a21bf-dc1b-49b0-8ee6-f134e5913c68}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForPairs object which maps pairs of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForPairs object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- their associated value has changed
	- a dependency used during generation of this value has changed

	It will recalculate those key/value pairs, storing information about any
	dependencies used in the processor callback during value generation, and
	save the new key/value pair to the output array. If it is overwriting an
	older key/value pair, that older pair will be passed to the destructor
	for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their key/value pairs from the output table and pass them to the destructor.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable

	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- clean out output table
	self._oldOutputTable, self._outputTable = self._outputTable, self._oldOutputTable

	local oldOutputTable = self._oldOutputTable
	local newOutputTable = self._outputTable
	table.clear(newOutputTable)

	-- Step 1: find key/value pairs that changed or were not previously present

	for newInKey, newInValue in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end


		-- check if the pair is new or changed
		local shouldRecalculate = oldInputTable[newInKey] ~= newInValue

		-- check if the pair's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output pair if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newOutValue, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey,
				newInValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForPairs")
				end

				-- if this key was already written to on this run-through, throw a fatal error.
				if newOutputTable[newOutKey] ~= nil then
					-- figure out which key/value pair previously wrote to this key
					local previousNewKey, previousNewValue
					for inKey, outKey in pairs(keyIOMap) do
						if outKey == newOutKey then
							previousNewValue = newInputTable[inKey]
							if previousNewValue ~= nil then
								previousNewKey = inKey
								break
							end
						end
					end

					if previousNewKey ~= nil then
						logError(
							"forPairsKeyCollision",
							nil,
							tostring(newOutKey),
							tostring(previousNewKey),
							tostring(previousNewValue),
							tostring(newInKey),
							tostring(newInValue)
						)
					end
				end

				local oldOutValue = oldOutputTable[newOutKey]

				if oldOutValue ~= newOutValue then
					local oldMetaValue = meta[newOutKey]
					if oldOutValue ~= nil then
						local destructOK, err = xpcall(self._destructor or cleanup, parseError, newOutKey, oldOutValue, oldMetaValue)
						if not destructOK then
							logErrorNonFatal("forPairsDestructorError", err)
						end
					end

					oldOutputTable[newOutKey] = nil
				end

				-- update the stored data for this key/value pair
				oldInputTable[newInKey] = newInValue
				keyIOMap[newInKey] = newOutKey
				meta[newOutKey] = newMetaValue
				newOutputTable[newOutKey] = newOutValue

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forPairsProcessorError", newOutKey)
			end
		else
			local storedOutKey = keyIOMap[newInKey]

			-- check for key collision
			if newOutputTable[storedOutKey] ~= nil then
				-- figure out which key/value pair previously wrote to this key
				local previousNewKey, previousNewValue
				for inKey, outKey in pairs(keyIOMap) do
					if storedOutKey == outKey then
						previousNewValue = newInputTable[inKey]

						if previousNewValue ~= nil then
							previousNewKey = inKey
							break
						end
					end
				end

				if previousNewKey ~= nil then
					logError(
						"forPairsKeyCollision",
						nil,
						tostring(storedOutKey),
						tostring(previousNewKey),
						tostring(previousNewValue),
						tostring(newInKey),
						tostring(newInValue)
					)
				end
			end

			-- copy the stored key/value pair into the new output table
			newOutputTable[storedOutKey] = oldOutputTable[storedOutKey]
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end

	-- STEP 2: find keys that were removed
	for oldOutKey, oldOutValue in pairs(oldOutputTable) do
		-- check if this key/value pair is in the new output table
		if newOutputTable[oldOutKey] ~= oldOutValue then
			-- clean up the old output pair
			local oldMetaValue = meta[oldOutKey]
			if oldOutValue ~= nil then
				local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldOutValue, oldMetaValue)
				if not destructOK then
					logErrorNonFatal("forPairsDestructorError", err)
				end
			end

			-- check if the key was completely removed from the output table
			if newOutputTable[oldOutKey] == nil then
				meta[oldOutKey] = nil
				self._keyData[oldOutKey] = nil
			end

			didChange = true
		end
	end

	for key in pairs(oldInputTable) do
		if newInputTable[key] == nil then
			oldInputTable[key] = nil
			keyIOMap[key] = nil
		end
	end

	return didChange
end

local function ForPairs<KI, VI, KO, VO, M>(
	inputTable: PubTypes.CanBeState<{ [KI]: VI }>,
	processor: (KI, VI) -> (KO, VO, M?),
	destructor: (KO, VO, M?) -> ()?
): Types.ForPairs<KI, VI, KO, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForPairs",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_oldOutputTable = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForPairs]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX51f55cc09a89414986d199a2dd6defc4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ForValues</string>
									<string name="ScriptGuid">{9eea24e5-ce66-49c1-82d7-2a46741ae568}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForValues object which maps values of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]
local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForValues object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any values meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those values, storing information about any dependencies
	used in the processor callback during value generation, and save the new value
	to the output array with the same key. If it is overwriting an older value,
	that older value will be passed to the destructor for cleanup.

	Finally, this function will find values that are no longer present, and remove
	their values from the output table and pass them to the destructor. You can re-use
	the same value multiple times and this will function will update them as little as
	possible; reusing the same values where possible.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local inputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local outputValues = {}

	local didChange = false

	-- clean out value cache
	self._oldValueCache, self._valueCache = self._valueCache, self._oldValueCache
	local newValueCache = self._valueCache
	local oldValueCache = self._oldValueCache
	table.clear(newValueCache)

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find values that changed or were not previously present
	for inKey, inValue in pairs(inputTable) do
		-- check if the value is new or changed
		local oldCachedValues = oldValueCache[inValue]
		local shouldRecalculate = oldCachedValues == nil

		-- get a cached value and its dependency/meta data if available
		local value, valueData, meta

		if type(oldCachedValues) == "table" and #oldCachedValues > 0 then
			local valueInfo = table.remove(oldCachedValues, #oldCachedValues)
			value = valueInfo.value
			valueData = valueInfo.valueData
			meta = valueInfo.meta

			if #oldCachedValues <= 0 then
				oldValueCache[inValue] = nil
			end
		elseif oldCachedValues ~= nil then
			oldValueCache[inValue] = nil
			shouldRecalculate = true
		end

		if valueData == nil then
			valueData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
		end

		-- check if the value's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(valueData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end

		-- recalculate the output value if necessary
		if shouldRecalculate then
			valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet
			table.clear(valueData.dependencySet)

			local processOK, newOutValue, newMetaValue = captureDependencies(
				valueData.dependencySet,
				self._processor,
				inValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForValues")
				end

				-- pass the old value to the destructor if it exists
				if value ~= nil then
					local destructOK, err = xpcall(self._destructor or cleanup, parseError, value, meta)
					if not destructOK then
						logErrorNonFatal("forValuesDestructorError", err)
					end
				end

				-- store the new value and meta data
				value = newOutValue
				meta = newMetaValue
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet

				logErrorNonFatal("forValuesProcessorError", newOutValue)
			end
		end


		-- store the value and its dependency/meta data
		local newCachedValues = newValueCache[inValue]
		if newCachedValues == nil then
			newCachedValues = {}
			newValueCache[inValue] = newCachedValues
		end

		table.insert(newCachedValues, {
			value = value,
			valueData = valueData,
			meta = meta,
		})

		outputValues[inKey] = value


		-- save dependency values and add to main dependency set
		for dependency in pairs(valueData.dependencySet) do
			valueData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find values that were removed
	-- for tables of data, we just need to check if it's still in the cache
	for _oldInValue, oldCachedValueInfo in pairs(oldValueCache) do
		for _, valueInfo in ipairs(oldCachedValueInfo) do
			local oldValue = valueInfo.value
			local oldMetaValue = valueInfo.meta

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldValue, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forValuesDestructorError", err)
			end

			didChange = true
		end

		table.clear(oldCachedValueInfo)
	end

	self._outputTable = outputValues

	return didChange
end

local function ForValues<VI, VO, M>(
	inputTable: PubTypes.CanBeState<{ [any]: VI }>,
	processor: (VI) -> (VO, M?),
	destructor: (VO, M?) -> ()?
): Types.ForValues<VI, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForValues",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_outputTable = {},
		_valueCache = {},
		_oldValueCache = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForValues]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXa7bd0259058c4162b252806b5198cd66">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Observer</string>
									<string name="ScriptGuid">{637e002a-9795-47c0-9a81-3817ff7db318}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new state object which can listen for updates on another state
	object.

	FIXME: enabling strict types here causes free types to leak
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local initDependency = require(Package.Dependencies.initDependency)

type Set<T> = {[T]: any}

local class = {}
local CLASS_METATABLE = {__index = class}

-- Table used to hold Observer objects in memory.
local strongRefs: Set<Types.Observer> = {}

--[[
	Called when the watched state changes value.
]]
function class:update(): boolean
	for _, callback in pairs(self._changeListeners) do
		task.spawn(callback)
	end
	return false
end

--[[
	Adds a change listener. When the watched state changes value, the listener
	will be fired.

	Returns a function which, when called, will disconnect the change listener.
	As long as there is at least one active change listener, this Observer
	will be held in memory, preventing GC, so disconnecting is important.
]]
function class:onChange(callback: () -> ()): () -> ()
	local uniqueIdentifier = {}

	self._numChangeListeners += 1
	self._changeListeners[uniqueIdentifier] = callback

	-- disallow gc (this is important to make sure changes are received)
	strongRefs[self] = true

	local disconnected = false
	return function()
		if disconnected then
			return
		end
		disconnected = true
		self._changeListeners[uniqueIdentifier] = nil
		self._numChangeListeners -= 1

		if self._numChangeListeners == 0 then
			-- allow gc if all listeners are disconnected
			strongRefs[self] = nil
		end
	end
end

local function Observer(watchedState: PubTypes.Value<any>): Types.Observer
	local self = setmetatable({
		type = "State",
		kind = "Observer",
		dependencySet = {[watchedState] = true},
		dependentSet = {},
		_changeListeners = {},
		_numChangeListeners = 0,
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the watched state's dependent set
	watchedState.dependentSet[self] = true

	return self
end

return Observer]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9df78a8c7ece4c6887425377d1b9ee80">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Value</string>
									<string name="ScriptGuid">{765f2440-4fc8-40c2-9d9e-917453f02da2}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs and returns objects which can be used to model independent
	reactive state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local isSimilar = require(Package.Utility.isSimilar)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the value currently stored in this State object.
	The state object will be registered as a dependency unless `asDependency` is
	false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Updates the value stored in this State object.

	If `force` is enabled, this will skip equality checks and always update the
	state object and any dependents - use this with care as this can lead to
	unnecessary updates.
]]
function class:set(newValue: any, force: boolean?)
	local oldValue = self._value
	if force or not isSimilar(oldValue, newValue) then
		self._value = newValue
		updateAll(self)
	end
end

local function Value<T>(initialValue: T): Types.State<T>
	local self = setmetatable({
		type = "State",
		kind = "Value",
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_value = initialValue
	}, CLASS_METATABLE)

	initDependency(self)

	return self
end

return Value]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3c997589c52a4128b2d665635031ab23">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">unwrap</string>
									<string name="ScriptGuid">{d1d99485-c5bf-4689-aeb9-c0936203f793}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A common interface for accessing the values of state objects or constants.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local xtypeof = require(Package.Utility.xtypeof)

local function unwrap<T>(item: PubTypes.CanBeState<T>, useDependency: boolean?): T
	return if xtypeof(item) == "State" then (item :: PubTypes.StateObject<T>):get(useDependency) else (item :: T)
end

return unwrap]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX2b0291b455394b11904de40e869290e2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Types</string>
								<string name="ScriptGuid">{0b148acf-cf99-4ca9-961d-b330153ded6e}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores common type information used internally.

	These types may be used internally so Fusion code can type-check, but
	should never be exposed to public users, as these definitions are fair game
	for breaking changes.
]]

local Package = script.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}

--[[
	General use types
]]

-- A symbol that represents the absence of a value.
export type None = PubTypes.Symbol & {
	-- name: "None" (add this when Luau supports singleton types)
}

-- Stores useful information about Luau errors.
export type Error = {
	type: string, -- replace with "Error" when Luau supports singleton types
	raw: string,
	message: string,
	trace: string
}

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type State<T> = PubTypes.Value<T> & {
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type Computed<T> = PubTypes.Computed<T> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_callback: () -> T,
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs<KI, VI, KO, VO, M> = PubTypes.ForPairs<KO, VO> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (KI, VI) -> (KO, VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [KI]: VI }>,
	_oldInputTable: { [KI]: VI },
	_outputTable: { [KO]: VO },
	_oldOutputTable: { [KO]: VO },
	_keyIOMap: { [KI]: KO },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForKeys<KI, KO, M> = PubTypes.ForKeys<KO, any> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (KI) -> (KO),
	_destructor: (KO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [KI]: KO }>,
	_oldInputTable: { [KI]: KO },
	_outputTable: { [KO]: any },
	_keyOIMap: { [KO]: KI },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForValues<VI, VO, M> = PubTypes.ForValues<any, VO> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (VI) -> (VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [VI]: VO }>,
	_outputTable: { [any]: VI },
	_valueCache: { [VO]: any },
	_oldValueCache: { [VO]: any },
	_meta: { [VO]: M? },
	_valueData: {
		[VI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object which follows another state object using tweens.
export type Tween<T> = PubTypes.Tween<T> & {
	_goalState: State<T>,
	_tweenInfo: TweenInfo,
	_prevValue: T,
	_nextValue: T,
	_currentValue: T,
	_currentTweenInfo: TweenInfo,
	_currentTweenDuration: number,
	_currentTweenStartTime: number,
	_currentlyAnimating: boolean
}

-- A state object which follows another state object using spring simulation.
export type Spring<T> = PubTypes.Spring<T> & {
	_speed: PubTypes.CanBeState<number>,
	_speedIsState: boolean,
	_lastSpeed: number,
	_damping: PubTypes.CanBeState<number>,
	_dampingIsState: boolean,
	_lastDamping: number,
	_goalState: State<T>,
	_goalValue: T,
	_currentType: string,
	_currentValue: T,
	_springPositions: {number},
	_springGoals: {number},
	_springVelocities: {number}
}

-- An object which can listen for updates on another state object.
export type Observer = PubTypes.Observer & {
	_changeListeners: Set<() -> ()>,
	_numChangeListeners: number
}

return nil]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX34072e77e97b46fa9d9ff9eef2e0f599">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Utility</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX917dadb98b224244899217758c733fb8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">None</string>
									<string name="ScriptGuid">{bd642e7d-a69f-412f-892d-5f09f4a0d9c7}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A symbol for representing nil values in contexts where nil is not usable.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

return {
	type = "Symbol",
	name = "None"
} :: Types.None]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXfb1ee6ccfa1d49cf9c048aaff16b4d4b">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">cleanup</string>
									<string name="ScriptGuid">{fc4ddd9e-bc15-40b8-a967-424d8c324a5a}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Cleans up the tasks passed in as the arguments.
	A task can be any of the following:

	- an Instance - will be destroyed
	- an RBXScriptConnection - will be disconnected
	- a function - will be run
	- a table with a `Destroy` or `destroy` function - will be called
	- an array - `cleanup` will be called on each item
]]

local function cleanupOne(task: any)
	local taskType = typeof(task)

	-- case 1: Instance
	if taskType == "Instance" then
		task:Destroy()

	-- case 2: RBXScriptConnection
	elseif taskType == "RBXScriptConnection" then
		task:Disconnect()

	-- case 3: callback
	elseif taskType == "function" then
		task()

	elseif taskType == "table" then
		-- case 4: destroy() function
		if typeof(task.destroy) == "function" then
			task:destroy()

		-- case 5: Destroy() function
		elseif typeof(task.Destroy) == "function" then
			task:Destroy()

		-- case 6: array of tasks
		elseif task[1] ~= nil then
			for _, subtask in ipairs(task) do
				cleanupOne(subtask)
			end
		end
	end
end

local function cleanup(...: any)
	for index = 1, select("#", ...) do
		cleanupOne(select(index, ...))
	end
end

return cleanup]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3de97fae0bbd41239ee9781d50ba2e37">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">doNothing</string>
									<string name="ScriptGuid">{7845d0b9-b446-43c4-ad6d-1c6457aafc25}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	An empty function. Often used as a destructor to indicate no destruction.
]]

local function doNothing(...: any)
end

return doNothing]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXc1b6bc017be244d0b61308dd908e0abe">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">isSimilar</string>
									<string name="ScriptGuid">{2b3f3f2a-eaea-4a8f-8bbc-fec77e57143f}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
--[[
    Returns true if A and B are 'similar' - i.e. any user of A would not need
    to recompute if it changed to B.
]]

local function isSimilar(a: any, b: any): boolean
    -- HACK: because tables are mutable data structures, don't make assumptions
    -- about similarity from equality for now (see issue #44)
    if typeof(a) == "table" then
        return false
    else
        return a == b
    end
end

return isSimilar]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX79ca210b3b0e49adb80280ade688da1d">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">needsDestruction</string>
									<string name="ScriptGuid">{44abb273-6539-43cd-a9e2-853e1c85fbd3}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
    Returns true if the given value is not automatically memory managed, and
    requires manual cleanup.
]]

local function needsDestruction(x: any): boolean
    return typeof(x) == "Instance"
end

return needsDestruction]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1e5b87dbbc17458e8ca29ae38ffa4645">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">restrictRead</string>
									<string name="ScriptGuid">{608d75e4-ff84-46d2-8c53-40b0d6ee93cd}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Restricts the reading of missing members for a table.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)

type table = {[any]: any}

local function restrictRead(tableName: string, strictTable: table): table
	-- FIXME: Typed Luau doesn't recognise this correctly yet
	local metatable = getmetatable(strictTable :: any)

	if metatable == nil then
		metatable = {}
		setmetatable(strictTable, metatable)
	end

	function metatable:__index(memberName)
		logError("strictReadError", nil, tostring(memberName), tableName)
	end

	return strictTable
end

return restrictRead]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0c4f9140af6149cb839e30ef9ffffaca">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">xtypeof</string>
									<string name="ScriptGuid">{4a2058d7-c02b-4d2f-9d87-9ee579b2969a}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Extended typeof, designed for identifying custom objects.
	If given a table with a `type` string, returns that.
	Otherwise, returns `typeof()` the argument.
]]

local function xtypeof(x: any)
	local typeString = typeof(x)

	if typeString == "table" and typeof(x.type) == "string" then
		return x.type
	else
		return typeString
	end
end

return xtypeof]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXd9e97a0c31f64fcbbc3d98873ea1415c">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">flamenco687_maid@3.2.2</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX3d554f51477144128f8023f3a5446201">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">maid</string>
							<string name="ScriptGuid">{1459068b-db82-4f6d-901c-62a411fbb317}</string>
							<ProtectedString name="Source"><![CDATA[-- finobinos - Original author - 16 October 2021
-- flamenco687 - Modified for personal use - 1 November 2021

--[[
	-- Static methods:

	Maid.new() --> table
	Maid.IsMaid(self : any) --> boolean

	-- Instance methods:

	Maid:GiveTask(task : table | function | RBXScriptConnection | Instance) --> task
	Maid:Cleanup() --> ()
	Maid:EndTask(task: table | function | RBXScriptConnection | Instanceble) --> ()
	Maid:RemoveTask(task: table | function | RBXScriptConnection | Instance) --> ()
	Maid:LinkToInstance(instance: Instance) --> (instance, ManualConnection)
		ManualConnection:Disconnect() --> ()
		ManualConnection:IsConnected() --> boolean
	Maid:Destroy() --> ()
]]

--[=[
	@class Maid
	Maids track tasks and clean them when needed.

	For e.g:
	```lua
	local maid = Maid.new()
	local connection = workspace.ChildAdded:Connect(function()

	end)
	maid:GiveTask(connection)
	maid:Cleanup()

	-- Connections aren't necessarily immediately disconnected when `Disconnect` is called on the.
	-- Much reliable to check in the next engine execution step:
	task.defer(function()
		print(connection.Connected) --> false
	end)
	```
]=]

local Maid = {}
Maid.__index = Maid

local Players = game:GetService("Players")

local LocalConstants = {
	ErrorMessages = {
		InvalidArgument = "Invalid argument#%d to %s: expected %s, got %s",
	},
}

local function IsInstanceDestroyed(instance)
	-- This function call is used to determine if an instance is ALREADY destroyed,
	-- and has been edited to be more reliable but still quite hacky due to Roblox
	-- not giving us a method to determine if an instance is already destroyed
	local _, response = pcall(function()
		instance.Parent = instance
	end)

	return (response:find("locked") and response:find("NULL") or nil) ~= nil
end

local function DisconnectTask(task)
	if typeof(task) == "function" then
		task()
	elseif typeof(task) == "RBXScriptConnection" then
		-- Task was a RBXScriptConneciton or a table with a Disconnect method
		task:Disconnect()
	else
		if task.Destroy then
			task:Destroy()
		else
			task:Disconnect()
		end
	end
end

--[=[
	A constructor method which creates a new maid.

	@return Maid 
]=]

function Maid.new()
	return setmetatable({
		_tasks = {},
	}, Maid)
end

--[=[
	A method which is used to check if the given argument is a maid or not.

	@param self any 
	@return boolean 
]=]

function Maid.IsMaid(self)
	return getmetatable(self) == Maid
end

--[=[
	Adds a task for the maid to cleanup. Note that `table` must have a `Destroy` or `Disconnect` method.

	@tag Maid
	@param task function | RBXScriptConnection | table | Instance
	@return task
]=]

function Maid:GiveTask(task)
	assert(
		typeof(task) == "function"
			or typeof(task) == "RBXScriptConnection"
			or typeof(task) == "table" and (typeof(task.Destroy) == "function" or typeof(task.Disconnect) == "function")
			or typeof(task) == "Instance",

		LocalConstants.ErrorMessages.InvalidArgument:format(
			1,
			"Maid:GiveTask()",
			"function or RBXScriptConnection or Instance or table with Destroy or Disconnect method",
			typeof(task)
		)
	)

	self._tasks[task] = task

	return task
end

--[=[
	Removes the task so that it will not be cleaned up. 

	@tag Maid
	@param task function | RBXScriptConnection | table | Instance 
]=]

function Maid:RemoveTask(task)
	self._tasks[task] = nil
end

--[=[
	Cleans up all the added tasks.
	@tag Maid

	| Task      | Type                          |
	| ----------- | ------------------------------------ |
	| `function`  | The function will be called.  |
	| `table`     | Any `Destroy` or `Disconnect` method in the table will be called. |
	| `Instance`    | The instance will be destroyed. |
	| `RBXScriptConnection`    | The connection will be disconnected. |
]=]

function Maid:Cleanup()
	-- Next allows us to easily traverse the table accounting for more values being added. This allows us to clean
	-- up tasks spawned by the cleaning up of current tasks.

	local tasks = self._tasks
	local key, task = next(tasks)

	while task do
		tasks[key] = nil

		DisconnectTask(task)

		key, task = next(tasks)
	end
end

--[=[
	@tag Maid

	Disconnect a specific task

	@param task -- Task to disconnect
]=]

function Maid:EndTask(task)
	self._tasks[task] = nil
	DisconnectTask(task)
end

--[=[
	@tag Maid

	Destroys the maid by first cleaning up all tasks, and then setting all the keys in it to `nil`
	and lastly, sets the metatable of the maid to `nil`.

	:::warning
	Trivial errors will occur if your code unintentionally works on a destroyed maid, only call this method when you're done working with the maid.
	:::
]=]

function Maid:Destroy()
	self:Cleanup()

	for key, _ in pairs(self) do
		self[key] = nil
	end

	setmetatable(self, nil)
end

local ManualConnection = {}
ManualConnection.__index = ManualConnection

do
	function ManualConnection.new()
		return setmetatable({ _isConnected = true }, ManualConnection)
	end

	function ManualConnection:Disconnect()
		self._isConnected = false
	end

	function ManualConnection:IsConnected()
		return self._isConnected
	end
end

--[=[
	Links the given instance to the maid so that the maid will clean up all the tasks once the instance has been destroyed
	via `Instance:Destroy`. The connection returned by this maid contains the following methods:

	| Methods      | Description                          |
	| ----------- | ------------------------------------ |
	| `Disconnect`  | The connection will be disconnected and the maid will unlink to the instance it was linked to.  |
	| `IsConnected` | Returns a boolean indicating if the connection has been disconnected. |

	Note that the maid will still unlink to the given instance if it has been cleaned up!

	@param instance Instance
	@return Connection 
]=]

function Maid:LinkToInstance(instance)
	assert(
		typeof(instance) == "Instance",
		LocalConstants.ErrorMessages.InvalidArgument:format(1, "Maid:LinkToInstance()", "Instance", typeof(instance))
	)

	local manualConnection = ManualConnection.new()
	self:GiveTask(manualConnection)

	local function TrackInstanceConnectionForCleanup(mainConnection)
		while mainConnection.Connected and not instance.Parent and manualConnection:IsConnected() do
			task.wait()
		end

		if not instance.Parent and manualConnection:IsConnected() then
			self:Cleanup()
		end
	end

	local mainConnection
	mainConnection = self:GiveTask(instance:GetPropertyChangedSignal("Parent"):Connect(function()
		if not instance.Parent then
			task.defer(function()
				if not manualConnection:IsConnected() then
					return
				end

				-- If the connection has also been disconnected, then its
				-- guaranteed that the instance has been destroyed through
				-- Destroy():
				if not mainConnection.Connected then
					self:Cleanup()
				else
					-- The instance was just parented to nil:
					TrackInstanceConnectionForCleanup(mainConnection)
				end
			end)
		end
	end))
	self:GiveTask(mainConnection)

	-- Special case for players as they are destroyed late when they leave:
	if instance:IsA("Player") then
		self:GiveTask(Players.PlayerRemoving:Connect(function(playerRemoved)
			if instance == playerRemoved and manualConnection:IsConnected() then
				self:Cleanup()
			end
		end))
	end

	if not instance.Parent then
		task.spawn(TrackInstanceConnectionForCleanup, mainConnection)
	end

	if IsInstanceDestroyed(instance) then
		self:Cleanup()
	end

	return manualConnection
end

return Maid]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXd86405ca73f447fbb469bdf62c2daad7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">wally</string>
								<string name="ScriptGuid">{c5f5644c-d3c2-46dd-b8f2-22d88fa985c4}</string>
								<ProtectedString name="Source"><![CDATA[return {
	package = {
		authors = {"finobinos", "flamenco687"},
		description = "Maid class",
		license = "Apache-2.0",
		name = "flamenco687/maid",
		realm = "shared",
		registry = "https://github.com/UpliftGames/wally-index",
		version = "3.2.2",
	},
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX8dad9c93f24d4a3caa920b69876e5d5a">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Interface</string>
				<string name="ScriptGuid">{8e16acb6-74c1-4030-b955-f789926940a3}</string>
				<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Wednesday September 6th 2023 2:21:48 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Tuesday July 9th 2024 10:58:37 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--[[
Interface

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = Interface.TopLevel('foo')
   

DESCRIPTION

    A detailed description of the module.

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of Interface.

--// Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")

--// Modules
local Fusion = require(ReplicatedStorage.BoomBoxPackages.Fusion)
local Maid = require(ReplicatedStorage.BoomBoxPackages.Maid)

--// Types
type Connections = { [string]: RBXScriptConnection }

--// Class
local Interface = {}
Interface.__index = Interface
Interface.ClassName = "Interface"

--// Variables
local PagesFolder = script.Pages
local Handlers = script.Handlers

local Handler_Interface = require(Handlers.Handlers_Interface)

local Pages = {
	["Root"] = require(PagesFolder.Root),
}

local function createScreenGui()
	local ScreenGui = Instance.new("ScreenGui")
	ScreenGui.Parent = Players.LocalPlayer.PlayerGui
	ScreenGui.DisplayOrder = 5
	ScreenGui.IgnoreGuiInset = false
	ScreenGui.ResetOnSpawn = false
	ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	Handler_Interface:Set("ScreenGui", ScreenGui)

	return ScreenGui
end

function Interface.new()
	local info = {
		Handler = Handler_Interface,
		Connections = {},
	}

	setmetatable(info, Interface):Init()
	return info
end

function Interface:ToggleBlur(Blur: BlurEffect, Active: boolean)
	if Blur.Parent == nil then
		self.Blur = Instance.new("BlurEffect")
		self.Blur.Size = 0
		self.Blur.Parent = game.Lighting
		Blur = self.Blur
	end
end

function Interface:Init()
	self.Blur = Instance.new("BlurEffect")
	self.Blur.Size = 0
	self.Blur.Parent = game.Lighting

	self.Trees = {}
	self.ScreenGui = createScreenGui()
	self.Connections = Maid.new()

	self:signals()
	self:mountScreen("Root")
end

function Interface:signals()
	Handler_Interface:SubscribeToState("Page", function(Page: string, Active: boolean, ToggleBlur: boolean)
		if ToggleBlur then
			self:ToggleBlur(self.Blur, Active)
		end

		if Page == "Store" then
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, not Active)
		end
	end)
end

function Interface:connections()
	Handler_Interface.UnmountScreen.Event:Connect(function(ScreenName)
		self:unmountScreen(ScreenName)
	end)
	Handler_Interface.MountScreen.Event:Connect(function(ScreenName)
		self:mountScreen(ScreenName)
	end)
end

function Interface:unmountSafeGuard(ScreenName)
	local ActiveTree = self.Trees[ScreenName]
	if ActiveTree then
		return ActiveTree
	end
	return false
end

function Interface:mountSafeGuard(ScreenName)
	local Page = Pages[ScreenName]
	local ActiveTree = self.Trees[ScreenName]
	if Page and not ActiveTree then
		return true
	end
	return false
end

function Interface:mountScreen(ScreenName, props, Cleanup)
	if self:mountSafeGuard(ScreenName) then
		self.Trees[ScreenName] = Pages[ScreenName](props or {}, Cleanup or function()
			print("Cleaning up " .. ScreenName)
		end)
		self.Trees[ScreenName].Parent = self.ScreenGui
	end
end

function Interface:unmountScreen(ScreenName)
	local ActiveTree = self.Trees[ScreenName]
	if self:unmountSafeGuard(ScreenName) then
		ActiveTree:Destroy()
		self.Trees[ScreenName] = nil
	end
end

function Interface:disconnect()
	local Connections: typeof(Maid.new()) = self.Connections
end

function Interface:destroy()
	self:Disconnect()

	setmetatable(self, nil)
	table.clear(self)
	table.freeze(self)
end

return Interface.new()]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX591f9c56063e45fbbe6ee6a4f4d156e0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Components</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXbc3789e928fa45fa864fe6d2b9c2134c">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">AudioPlayer</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXe31867d12a2a480085f932e3bd76b027">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AudioControls</string>
							<string name="ScriptGuid">{7e8f9c63-b62e-4469-8263-3e1a5dac6b78}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local Like = require(script.Like)
local Skip = require(script.Skip)
local Play = require(script.Play)
local Queue = require(script.Queue)
local Rewind = require(script.Rewind)
local Volume = require(script.Volume)
local Shuffle = require(script.Shuffle)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type AudioControlsProps = {}

return function(props: AudioControlsProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local AudioControls = New("Frame")({
		Name = "AudioControls",
		AnchorPoint = Vector2.new(0, 1),
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.new(0, 0, 1, -15),
		Size = UDim2.new(1, 0, 0.0628, 25),

		[Children] = {
			Like({}),
			Skip({}),
			Play({}),
			Queue({}),
			Rewind({}),
			Volume({}),
			Shuffle({}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0, 5),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Bottom,
			}),
		},
	})

	return AudioControls
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX73454a0d5491498f8c13d7498cb30411">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Like</string>
								<string name="ScriptGuid">{f65c0ba0-c8be-4447-98fc-1ecb9fa4d08e}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PlayProps = {}

return function(props: PlayProps)
	--// Value States
	local Active = Value(true)

	local Play = ImageButton({
		Name = "Play",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 3,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		Image = "",
		BackgroundTransparency = 1,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,
		AspectRatio = 1.2,

		OnClick = function()
			local Liked = Handler_Interface:GetState("PlayingLiked")

			Liked:set(not Liked:get())

			local Song = Handler_Interface:Get("Sound")

			if not Song then
				return
			end

			local Payload = {
				asset_id = Song.asset_id,
			}

			Handler_Interface:Fire("LikeEvent", Payload, Liked:get())
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = Computed(function()
					return Handler_Interface:Get("PlayingLiked") and Images.Icons.LikedImage
						or Images.Icons.UnlikedImage
				end),
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.5, 0.5),
			}),
		},
	})

	return Play
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5a46568fcec742b2810f0bf56167bab4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Play</string>
								<string name="ScriptGuid">{30ebd5cb-ee4a-4410-9f99-fc09e79ef638}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PlayProps = {}

return function(props: PlayProps)
	--// Value States
	local Active = Value(true)

	local Play = ImageButton({
		Name = "Play",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 1,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", 0)

			Handler_Interface:Set("AutoPlay", true)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = Computed(function()
					return Handler_Interface:Get("SoundPlaying") and "rbxassetid://18935458228"
						or "rbxassetid://18935457772"
				end),
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.5, 0.5),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),
		},
	})

	return Play
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXf3b4a758c40f4cde99b36cc548eec3ed">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Queue</string>
								<string name="ScriptGuid">{d0383d65-0a57-43cd-ba14-c50462fff1f1}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type QueueProps = {}

return function(props: QueueProps)
	--// Value States
	local Active = Value(true)

	local Queue = ImageButton({
		Name = "Queue",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -3,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 1,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Set("Page", "Queue")
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = Images.Icons.Queue,
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.5, 0.5),
			}),
		},
	})

	return Queue
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX01226607df984203b3ec7071734bd568">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Rewind</string>
								<string name="ScriptGuid">{fe512f39-bc6a-4a3f-8bb1-cbb9b2d1cd99}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type RewindProps = {}

return function(props: RewindProps)
	--// Value States
	local Active = Value(true)

	local Rewind = ImageButton({
		Name = "Rewind",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -1,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", -1)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935457399",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.44, 0.294),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 1.5,
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),
		},
	})

	return Rewind
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX52ac64eafbd04d9d852ad6a7b509ff04">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Shuffle</string>
								<string name="ScriptGuid">{3854dc5c-85ec-43dd-b2d8-8eddaac654f5}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type ShuffleProps = {}

return function(props: ShuffleProps)
	--// Value States
	local Active = Value(true)

	local Shuffle = ImageButton({
		Name = "Shuffle",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -2,

		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		Image = "",
		BackgroundTransparency = 1,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,
		AspectRatio = 1,

		OnClick = function()
			Handler_Interface:Set("Shuffling", not Handler_Interface:Get("Shuffling"))
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = Images.Icons.Shuffle,
				AnchorPoint = Vector2.new(0.5, 0.5),
				ImageTransparency = Tween(
					Computed(function()
						return Handler_Interface:Get("Shuffling") and 0 or 0.5
					end),
					Tweens.Fast
				),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.5, 0.5),
			}),
		},
	})

	return Shuffle
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX582d0ecc2d5744d9a5b49423728faf0d">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Skip</string>
								<string name="ScriptGuid">{3cf8c12c-2fbc-476e-a9c0-1f1e50ebfd07}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SkipProps = {}

return function(props: SkipProps)
	--// Value States
	local Active = Value(true)

	local Skip = ImageButton({
		Name = "Skip",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 2,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", 1)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935457202",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.44, 0.294),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 1.5,
					}),
				},
			}),
		},
	})

	return Skip
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6015aef6570f4e1db4174ac13101788e">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Volume</string>
								<string name="ScriptGuid">{320c3680-05b1-489c-bd51-4f3af3029b85}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type VolumeBarProps = {}

return function(props: VolumeBarProps)
	--// Value States
	local Active = Value(false)
	local Dragging = Value(false)

	--// Refs
	local MarkerRef = Value()
	local ProgressBarRef = Value()

	local VolumeBar = New("Frame")({
		Name = "VolumeBarContainer",
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 4,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.2, 1),

		Visible = Computed(function()
			return Handler_Interface:Get("PlayerVisible")
		end),

		[Children] = {
			New("ImageButton")({
				[Ref] = ProgressBarRef,
				Name = "VolumeBar",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 0.8,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 4,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.new(1, 0, 0, 5),

				[OnEvent("MouseButton1Click")] = function()
					local Mouse = Players.LocalPlayer:GetMouse()
					local ProgressBar = ProgressBarRef:get() :: ImageButton
					local SoundInstance = Handler_Interface:Get("SoundInstance") :: Sound

					local ClickedPercent = math.clamp(
						(Vector2.new(Mouse.X, Mouse.Y) - ProgressBar.AbsolutePosition).X,
						0,
						ProgressBar.AbsoluteSize.X
					) / ProgressBar.AbsoluteSize.X

					Handler_Interface:Set("VolumePercent", ClickedPercent)
					Handler_Interface:Set("Volume", ClickedPercent * Handler_Interface:Get("MaxVolume"))
					SoundInstance.Volume = ClickedPercent * Handler_Interface:Get("MaxVolume")
				end,

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
					}),

					New("Frame")({
						Name = "VolumeBarFill",
						AnchorPoint = Vector2.new(0, 1),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0, 1),
						Size = UDim2.fromScale(0.5, 1),

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
							}),

							New("ImageButton")({
								[Ref] = MarkerRef,
								Name = "ProgressMark",
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(1, 0.5),
								Size = UDim2.fromOffset(10, 10),

								[OnEvent("MouseButton1Down")] = function(Temp, Temp2)
									Dragging:set(true)

									local Connection
									local ImageButton = MarkerRef:get() :: ImageButton

									local Mouse = Players.LocalPlayer:GetMouse()
									local ProgressBar = ProgressBarRef:get() :: ImageButton
									local SoundInstance = Handler_Interface:Get("SoundInstance") :: Sound

									Connection = UserInputService.InputEnded:Connect(function(input)
										if input.UserInputType == Enum.UserInputType.MouseButton1 then
											Connection:Disconnect()
											Dragging:set(false)
											RunService:UnbindFromRenderStep("Dragging")
										end
									end)

									RunService:BindToRenderStep("Dragging", 0, function(delta: number)
										local ClickedPercent = math.clamp(
											(Vector2.new(Mouse.X, Mouse.Y) - ProgressBar.AbsolutePosition).X,
											0,
											ProgressBar.AbsoluteSize.X
										) / ProgressBar.AbsoluteSize.X

										ImageButton.Parent.Size = UDim2.fromScale(ClickedPercent, 1)
										Handler_Interface:Set("VolumePercent", ClickedPercent)
										Handler_Interface:Set(
											"Volume",
											ClickedPercent * Handler_Interface:Get("MaxVolume")
										)

										SoundInstance.Volume = ClickedPercent * Handler_Interface:Get("MaxVolume")
									end)
								end,

								[OnEvent("MouseButton1Up")] = function(Temp, Temp2)
									Dragging:set(false)
									RunService:UnbindFromRenderStep("Dragging")
								end,

								[Children] = {
									New("UIAspectRatioConstraint")({
										Name = "UIAspectRatioConstraint",
									}),

									New("UICorner")({
										Name = "UICorner",
										CornerRadius = UDim.new(1, 0),
									}),
								},
							}),
						},
					}),

					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 8.43,
					}),
				},
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),
		},
	})

	return VolumeBar
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX5b4e440ac1e04a819730b6cd34bfaf60">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AudioControlsVertical</string>
							<string name="ScriptGuid">{38a64716-aaed-470c-9a34-cda813761443}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
	ListPadding = 0.1,
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local Play = require(script.Play)
local Skip = require(script.Skip)
local Rewind = require(script.Rewind)

local AudioScapeButton = require(LocalComponents.AudioscapeButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type AudioControlsProps = {}

return function(props: AudioControlsProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local AudioControls = New("Frame")({
		Name = "AudioControls",
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.5, 0.5),
		Size = UDim2.fromScale(1, 1),

		[Children] = {
			AudioScapeButton({}),
			Play({}),
			Skip({}),
			Rewind({}),

			New("UIPadding")({
				Name = "UIPadding",
				PaddingBottom = UDim.new(Settings.ListPadding, 0),
				PaddingLeft = UDim.new(Settings.ListPadding, 0),
				PaddingRight = UDim.new(Settings.ListPadding, 0),
				PaddingTop = UDim.new(Settings.ListPadding, 0),
			}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0, 5),
				FillDirection = Enum.FillDirection.Vertical,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),
		},
	})

	return AudioControls
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXde8d487a83194638bba0c276f376514f">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Play</string>
								<string name="ScriptGuid">{3e137c11-8975-4a19-85f1-9b9cca1b3837}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PlayProps = {}

return function(props: PlayProps)
	--// Value States
	local Active = Value(true)

	local Play = ImageButton({
		Name = "Play",
		Active = Handler_Interface:GetState("PlayerHidden"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 1,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(1, 0.25),

		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", 0)
			Handler_Interface:Set("AutoPlay", true)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = Computed(function()
					return Handler_Interface:Get("SoundPlaying") and "rbxassetid://18935458228"
						or "rbxassetid://18935457772"
				end),
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.5, 0.5),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),
		},
	})

	return Play
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXb11ec7954b9b406ab808bb65f9b884fc">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Rewind</string>
								<string name="ScriptGuid">{3d7e9b3c-0158-4fa8-8267-7e0bd45c5a88}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type RewindProps = {}

return function(props: RewindProps)
	--// Value States
	local Active = Value(true)

	local Rewind = ImageButton({
		Name = "Rewind",
		Active = Handler_Interface:GetState("PlayerHidden"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -1,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(1, 0.25),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", -1)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935457399",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.44, 0.294),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 1.5,
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),
		},
	})

	return Rewind
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5b14feb5363542d99f62cd6f108c7e5c">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Skip</string>
								<string name="ScriptGuid">{857d75c3-1310-46c6-a7ef-08038422f234}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SkipProps = {}

return function(props: SkipProps)
	--// Value States
	local Active = Value(true)

	local Skip = ImageButton({
		Name = "Skip",
		Active = Handler_Interface:GetState("PlayerHidden"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 2,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(1, 0.25),

		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", 1)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935457202",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.44, 0.294),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 1.5,
					}),
				},
			}),
		},
	})

	return Skip
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX9d8c005379b4459c9dcec51032ed8861">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AudioscapeButton</string>
							<string name="ScriptGuid">{4f022fd8-3b91-4787-b796-96132f00a9d2}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
	Sizing = 0.25,
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type AudioscapeButtonProps = {}

return function(props: AudioscapeButtonProps)
	local ShowTooltip = Value(false)
	local Active = Value(not Handler_Interface:Get("PlayerVisible"))

	Handler_Interface:SubscribeToState("PlayerVisible", function(visible)
		Active:set(not visible)
	end)

	local AudioscapeButton = ImageButton({
		Name = "AudioScape",
		Active = Active,
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Size = UDim2.fromScale(1, Settings.Sizing),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,
		Position = UDim2.fromScale(0.5, 0.5),
		AnchorPoint = Vector2.new(0.5, 0.5),
		LayoutOrder = -10,

		OnClick = function()
			Handler_Interface:Set("PlayerVisible", true)
			Handler_Interface:Set("PlayerHidden", false)
		end,

		OnHover = function()
			ShowTooltip:set(true)
		end,
		OnLeave = function()
			ShowTooltip:set(false)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935312391",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.6, 0.52),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),

			Computed(function()
				if ShowTooltip:get() then
					return New("TextLabel")({
						Name = "Tooltip",
						BackgroundTransparency = 0.5,
						BackgroundColor3 = Color3.new(0, 0, 0),
						AnchorPoint = Vector2.new(1, 0),
						Position = UDim2.fromScale(0, 0),
						Size = UDim2.fromScale(4, 1),
						Text = "Expand",
						TextScaled = true,
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextSize = 14,
						Font = Enum.Font.GothamSemibold,
						TextXAlignment = Enum.TextXAlignment.Center,
						TextYAlignment = Enum.TextYAlignment.Center,
						ZIndex = 2,

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),
						},
					})
				end
				return {}
			end, function() end),
		},
	})

	return AudioscapeButton
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXccfe45383dfd43f0ba49dd25f419a852">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Buttons</string>
							<string name="ScriptGuid">{5af618a5-e59c-473c-9428-d94ab5b74789}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type ButtonsProps = {}

return function(props: ButtonsProps)
	--// Value States
	local Active = Value(true)
	local Minimize = Value(false)
	local Page = Handler_Interface:GetState("Page")

	local Buttons = New("Frame")({
		Name = "Buttons",
		AnchorPoint = Vector2.new(1, 0),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 2,
		Position = UDim2.fromScale(1, 0),
		Size = UDim2.fromScale(0.228, 0.333),

		[Children] = {
			ImageButton({
				Active = Active,
				Name = "Search",
				BackgroundTransparency = 0,
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Position = UDim2.fromScale(0.873, 0.06),
				Size = UDim2.fromScale(0.556, 1.11),
				Image = "",
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				AnimationSpeed = 0.1,

				OnClick = function()
					Handler_Interface:Set("SearchTab", "Library")
					Page:set("Search")
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = "rbxassetid://18935266802",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.5, 0.5),
					}),

					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
					}),
				},
			}),
			ImageButton({
				Active = Active,
				Name = "Favorites",
				Visible = false,
				BackgroundTransparency = 0,
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 3,
				Position = UDim2.fromScale(0.873, 0.06),
				Size = UDim2.fromScale(0.556, 1.11),
				Image = "",
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				AnimationSpeed = 0.1,

				OnClick = function()
					Handler_Interface:Set("SearchTab", "Favorites")
					Page:set("Search")
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = Images.Icons.LikedImage,
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.5, 0.5),
					}),

					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
					}),
				},
			}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0, 5),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Right,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 2,
			}),

			ImageButton({
				Active = Active,
				Name = "Minimize",
				Visible = false,
				BackgroundTransparency = 0,
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 3,
				Position = UDim2.fromScale(0.873, 0.06),
				Size = UDim2.fromScale(0.556, 1.11),
				Image = "",
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				AnimationSpeed = 0.1,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = "rbxassetid://18935269593",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.5, 0.5),
					}),

					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
					}),
				},
			}),
		},
	})

	return Buttons
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXf2ececabe14c42a7aca0c8e9a1d024d5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Playing</string>
							<string name="ScriptGuid">{c841ac85-b111-48a1-8fa3-7c90c1a4c77f}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local SongInfo = require(script.SongInfo)
local AudioscapeButtonMaximized = require(script.AudioscapeButtonMaximized)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PlayingProps = {}

return function(props: PlayingProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	local Playing = New("Frame")({
		Name = "Playing",
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 2,
		Size = UDim2.fromScale(0.5, 0.4),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0, 5),
				FillDirection = Enum.FillDirection.Horizontal,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			SongInfo({}),
			AudioscapeButtonMaximized({}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 2,
			}),
		},
	})

	return Playing
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX91bee15d565c4bc5aea5dbbecfb61226">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">AudioscapeButtonMaximized</string>
								<string name="ScriptGuid">{f8190dba-88ff-4d0a-9a2a-47af689b23b8}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type AudioscapeButtonProps = {}

return function(props: AudioscapeButtonProps)
	local ShowTooltip = Value(false)

	local AudioscapeButton = ImageButton({
		Name = "AudioScape",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -1,
		Size = UDim2.fromScale(0.667, 1.682),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,
		Position = UDim2.fromScale(0.5, 0.5),
		AnchorPoint = Vector2.new(0.5, 0.5),

		OnClick = function()
			-- Handler_Interface:Set("PlayerVisible", false)
			-- Handler_Interface:Set("PlayerHidden", true)
		end,

		OnHover = function()
			ShowTooltip:set(true)
		end,
		OnLeave = function()
			ShowTooltip:set(false)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935312391",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.6, 0.52),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),

			Computed(function()
				if ShowTooltip:get() then
					return New("TextLabel")({
						Name = "Tooltip",
						BackgroundTransparency = 0.5,
						BackgroundColor3 = Color3.new(0, 0, 0),
						AnchorPoint = Vector2.new(0.5, 1),
						Position = UDim2.fromScale(0.5, 0),
						Size = UDim2.fromScale(3, 1),
						Text = "Join the Audioscape group to add this player to your game!",
						TextScaled = true,
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextSize = 14,
						Font = Enum.Font.GothamSemibold,
						TextXAlignment = Enum.TextXAlignment.Center,
						TextYAlignment = Enum.TextYAlignment.Center,
						ZIndex = 2,

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("UIPadding")({
								Name = "UIPadding",
								PaddingBottom = UDim.new(0, 5),
								PaddingLeft = UDim.new(0, 5),
								PaddingRight = UDim.new(0, 5),
								PaddingTop = UDim.new(0, 5),
							}),
						},
					})
				end
				return {}
			end, function() end),
		},
	})

	return AudioscapeButton
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6e585ae3c80241558285f519fe29a3d5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SongInfo</string>
								<string name="ScriptGuid">{d026377a-fc51-4bf5-a19f-f5542b2b10c0}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Capitalize = require(Util.Capitalize)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SongInfoProps = {
	["asset_ageGuidelines"]: string,
	["asset_assetGenres"]: string,
	["asset_assetSubTypes"]: string,
	["asset_audioDetails_artist"]: string,
	["asset_audioDetails_audioType"]: string,
	["asset_audioDetails_musicAlbum"]: string,
	["asset_audioDetails_musicGenre"]: string,
	["asset_audioDetails_soundEffectCategory"]: string,
	["asset_audioDetails_soundEffectSubcategory"]: string,
	["asset_audioDetails_tags"]: string,
	["asset_audioDetails_title"]: string,
	["asset_createdUtc"]: string,
	["asset_creatingUniverseId"]: string,
	["asset_description"]: string,
	["asset_description_feature_extraction_Album"]: string,
	["asset_description_feature_extraction_Album Info"]: string,
	["asset_description_feature_extraction_BPM"]: number,
	["asset_description_feature_extraction_Courtesy of"]: string,
	["asset_description_feature_extraction_Duration"]: string,
	["asset_description_feature_extraction_Genre"]: string,
	["asset_description_feature_extraction_Key"]: string,
	["asset_description_feature_extraction_Library"]: string,
	["asset_duration"]: number,
	["asset_hasScripts"]: string,
	["asset_id"]: number,
	["asset_isAssetHashApproved"]: string,
	["asset_isEndorsed"]: string,
	["asset_name"]: string,
	["asset_socialLinks"]: string,
	["asset_typeId"]: number,
	["asset_updatedUtc"]: string,
	["asset_visibilityStatus"]: number,
	["creator_id"]: number,
	["creator_isVerifiedCreator"]: string,
	["creator_latestGroupUpdaterUserId"]: string,
	["creator_latestGroupUpdaterUserName"]: string,
	["creator_name"]: string,
	["creator_type"]: number,
	["product_isForSaleOrIsPublicDomain"]: string,
	["product_price"]: number,
	["product_productId"]: number,
	["voting_canVote"]: string,
	["voting_downVotes"]: number,
	["voting_hasVoted"]: string,
	["voting_showVotes"]: string,
	["voting_upVotePercent"]: number,
	["voting_upVotes"]: number,
	["voting_userVote"]: string,
	["voting_voteCount"]: number,
}

return function(props: SongInfoProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local SongInfo = New("Frame")({
		Name = "SongInfo",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 2,
		Position = UDim2.fromScale(0.667, 0),
		Size = Tween(
			Computed(function()
				return Handler_Interface:Get("PlayerVisible") and UDim2.fromScale(1.8, 1) or UDim2.fromScale(0, 1)
			end),
			Tweens.Fast
		),

		[Children] = {
			New("TextLabel")({
				Name = "SongTitle",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = Computed(function()
					local CurrentSound = Handler_Interface:Get("Sound")
					if
						CurrentSound
						and typeof(CurrentSound) == "table"
						and CurrentSound["asset_audioDetails_title"]
					then
						return CurrentSound["asset_audioDetails_title"]
					end

					return "Unknown Title"
				end),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextTransparency = Tween(
					Computed(function()
						return Handler_Interface:Get("PlayerVisible") and 0 or 1
					end),
					Tweens.Fast
				),
				TextXAlignment = Enum.TextXAlignment.Left,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(1, 0.6),
			}),

			New("TextLabel")({
				Name = "SongAlbum",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = Computed(function()
					local CurrentSound = Handler_Interface:Get("Sound")
					if
						CurrentSound
						and typeof(CurrentSound) == "table"
						and CurrentSound["asset_audioDetails_musicAlbum"]
					then
						return Capitalize(CurrentSound["asset_audioDetails_musicAlbum"]:lower())
					end

					return "Unknown Album"
				end),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextTransparency = Tween(
					Computed(function()
						return Handler_Interface:Get("PlayerVisible") and 0.5 or 1
					end),
					Tweens.Fast
				),
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(5.48e-07, 0.722),
				Size = UDim2.fromScale(0.75, 0.7),
				[Children] = {
					New("UITextSizeConstraint")({
						Name = "UITextSizeConstraint",
						MaxTextSize = 15,
					}),
				},
			}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0, -2),
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),
		},
	})

	return SongInfo
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX863485d3dc3046b1866ca2c595b3282d">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TimeBar</string>
							<string name="ScriptGuid">{88c9eb77-392e-46c1-8fab-d52efe268e7c}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

local function ConvertSecondsToMinutes(Seconds: number): string
	local Minutes = math.floor(Seconds / 60)
	Seconds = math.floor(Seconds % 60)

	return string.format("%d:%02d", Minutes, Seconds)
end

type TimeBarProps = {}

return function(props: TimeBarProps)
	--// Value States
	local Active = Value(false)
	local Dragging = Value(false)

	local MarkerRef = Value()
	local ProgressBarRef = Value()

	local TimeBar = New("Frame")({
		[Ref] = ProgressBarRef,
		Name = "TimeBar",
		AnchorPoint = Vector2.new(0.5, 1),
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 0.9,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.5, 1),
		Size = UDim2.new(1, 0, 0, 5),
		Visible = Computed(function()
			return Handler_Interface:Get("PlayerVisible")
		end),

		[Children] = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("TextLabel")({
				Name = "Elapsed",
				FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json"),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextSize = 14,
				AnchorPoint = Vector2.new(0, 1),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.new(0, 10, -1, 0),
				Size = UDim2.fromOffset(5, 2),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 3.2,
					}),
				},
			}),

			New("TextLabel")({
				Name = "Duration",
				FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json"),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextSize = 14,
				AnchorPoint = Vector2.new(1, 1),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.new(1, -10, -1, 0),
				Size = UDim2.fromOffset(5, 2),
				Text = Computed(function()
					return ConvertSecondsToMinutes(Handler_Interface:Get("Length"))
				end),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 3.2,
					}),
				},
			}),

			New("Frame")({
				Name = "TimeBarFill",
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(0.5, 1),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageButton")({
						[Ref] = MarkerRef,
						Name = "ProgressMark",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(1, 0.5),
						Size = UDim2.fromScale(2, 2),

						[OnEvent("MouseButton1Down")] = function(Temp, Temp2)
							Dragging:set(true)

							local Connection
							local ImageButton = MarkerRef:get() :: ImageButton

							local Mouse = Players.LocalPlayer:GetMouse()
							local ProgressBar = ProgressBarRef:get() :: ImageButton
							local SoundInstance = Handler_Interface:Get("SoundInstance") :: Sound

							Connection = UserInputService.InputEnded:Connect(function(input)
								if input.UserInputType == Enum.UserInputType.MouseButton1 then
									Connection:Disconnect()
									Dragging:set(false)
									RunService:UnbindFromRenderStep("Dragging")
								end
							end)

							RunService:BindToRenderStep("Dragging", 0, function(delta: number)
								local ClickedPercent = math.clamp(
									(Vector2.new(Mouse.X, Mouse.Y) - ProgressBar.AbsolutePosition).X,
									0,
									ProgressBar.AbsoluteSize.X
								) / ProgressBar.AbsoluteSize.X

								ImageButton.Parent.Size = UDim2.fromScale(ClickedPercent, 1)
								SoundInstance.TimePosition = SoundInstance.TimeLength * ClickedPercent
							end)
						end,
						[OnEvent("MouseButton1Up")] = function(Temp, Temp2)
							Dragging:set(false)
							RunService:UnbindFromRenderStep("Dragging")
						end,

						[Children] = {
							New("UIAspectRatioConstraint")({
								Name = "UIAspectRatioConstraint",
							}),

							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(1, 0),
							}),
						},
					}),
				},
			}),
		},
	})

	local function Monitor()
		local Sound = Handler_Interface:Get("Sound")
		local SoundInstance = Handler_Interface:Get("SoundInstance") :: Sound

		if not Sound then
			repeat
				task.wait()
			until Handler_Interface:Get("Sound")
		end

		RunService:UnbindFromRenderStep("SongProgress")

		TimeBar.Duration.Text = ConvertSecondsToMinutes(SoundInstance.TimeLength)

		RunService:BindToRenderStep("SongProgress", 0, function(delta: number)
			if Dragging:get() then
				return
			end

			local TimeBarFill = TimeBar.TimeBarFill :: Frame

			TimeBar.Elapsed.Text = ConvertSecondsToMinutes(SoundInstance.TimePosition)
			TimeBarFill.Size = UDim2.fromScale(SoundInstance.TimePosition / SoundInstance.TimeLength, 1)
		end)
	end

	Observer(Handler_Interface:GetState("Length")):onChange(Monitor)

	task.spawn(Monitor)

	return TimeBar
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX93128b3b30414a99a69dd21287cb27f2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Base</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX3379c2b4cef147d897f2b8cbfc63e3f2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ImageButton</string>
							<string name="ScriptGuid">{79106c03-555e-4ed1-a737-c3e85c58aacb}</string>
							<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Wednesday October 4th 2023 4:02:12 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 9:11:10 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)

--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Base",
}

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type ImageButtonProps = {
	Active: any?,
	Name: string?,
	Image: string?,
	ZIndex: number?,
	Visible: boolean?,
	ShrinkSize: number?,
	GrowthSize: number?,
	FrameZIndex: number?,
	AspectRatio: number?,
	AnimationSpeed: number?,

	Size: UDim2,
	Position: UDim2?,
	ImageColor3: Color3?,
	LayoutOrder: number?,
	AnchorPoint: Vector2?,
	BackgroundColor3: Color3?,
	BackgroundTransparency: number?,
	RootBackgroundTransparency: number?,

	Ref: Fusion.Value<nil>?,
	OnHover: () -> any?,
	OnLeave: () -> any?,
	OnClick: () -> any?,
	Children: {}?,
}

return function(props: ImageButtonProps)
	--// Value States
	local Active = props.Active or Value(false)
	local Hovering = Value(false)
	local Clicking = Value(false)

	--// Debugging
	if Interface_Settings.BaseDebug then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local ImageButton = New("Frame")({

		[Cleanup] = {},
		[Ref] = props.Ref or nil,
		Name = props.Name or "Button",
		LayoutOrder = props["LayoutOrder"] or 1,

		ZIndex = props["FrameZIndex"] or 1,
		BackgroundTransparency = props["RootBackgroundTransparency"] or 1,
		BackgroundColor3 = props.BackgroundColor3 or Color3.new(1, 1, 1),
		Size = props.Size,
		AnchorPoint = props.AnchorPoint or Vector2.new(0, 0),
		Position = props.Position or UDim2.fromScale(0.5, 0.5),
		Visible = if props["Visible"] ~= nil then props["Visible"] else true,
		[Children] = {
			Computed(function()
				if props["AspectRatio"] then
					return New("UIAspectRatioConstraint")({
						AspectRatio = props["AspectRatio"] or 1,
					})
				end

				return {}
			end, function(a0: Instance)
				-- a0:Destroy()
			end),
			New("ImageButton")({
				[OnEvent("MouseButton1Click")] = function()
					Sounds:Play("Click")

					if props.OnClick then
						props.OnClick()
					end

					Clicking:set(true)
					task.delay(0.25, function()
						Hovering:set(false)
						Clicking:set(false)
					end)
				end,
				[OnEvent("MouseEnter")] = function()
					Hovering:set(true)
					if props.OnHover then
						props.OnHover()
					end
				end,
				[OnEvent("MouseLeave")] = function()
					Hovering:set(false)
					if props.OnLeave then
						props.OnLeave()
					end
				end,

				ZIndex = props["ZIndex"] or 1,
				Name = props.Name or "Button",
				Image = props.Image or "rbxassetid://13190836263",
				ImageColor3 = props.ImageColor3 or Color3.new(1, 1, 1),
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundTransparency = props.BackgroundTransparency or 1,
				BackgroundColor3 = props.BackgroundColor3 or Color3.new(1, 1, 1),
				Position = UDim2.fromScale(0.5, 0.5),
				Size = Tween(
					Computed(function()
						if Clicking:get() then
							local ShrinkSize = props["ShrinkSize"] or 0.75

							return UDim2.fromScale(ShrinkSize, ShrinkSize)
						end
						if Hovering:get() then
							return UDim2.fromScale(props["GrowthSize"] or 1.25, props["GrowthSize"] or 1.25)
						end
						return Active:get() and UDim2.fromScale(1, 1) or UDim2.fromScale(0, 0)
					end),
					Tweens.modifyTween("Toon", {
						EasingDirection = Enum.EasingDirection.Out,
						Time = props["AnimationSpeed"] or Tweens.Toon.Time,
					})
				),

				ImageTransparency = Tween(
					Computed(function()
						return Active:get() and 0 or 1
					end),
					Tweens.modifyTween("Toon", {
						EasingDirection = Enum.EasingDirection.Out,
						Time = props["AnimationSpeed"] or Tweens.Toon.Time,
					})
				),

				[Children] = {
					props["Children"],
				},
			}),
		},
	})

	return ImageButton
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXb7e16255027841159fde73307df06326">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">InputLabel</string>
							<string name="ScriptGuid">{3acf200d-9138-4e8a-9c06-77dd451a20b2}</string>
							<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Tuesday October 3rd 2023 12:38:13 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 10:31:38 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local _Players = game:GetService("Players")
local _RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local _Sounds = require(Util.Sounds)
local _Images = require(Util.Images)
local UIStroke = require(Util.UIStroke)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)

--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "CharacterCreation",
}

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type InputLabelProps = {
	LabelName: string,

	Size: UDim2?,
	Image: string?,
	Position: UDim2?,
	AnchorPoint: Vector2?,
	TextXAlignment: Enum.TextXAlignment?,
}

return function(props: InputLabelProps)
	--// Value States
	local Active = Value(false)
	local HasText = Value(false)
	local InputFocused = Value(false)

	--// Ref
	local TextBoxRef = Value()

	--// Signals
	-- local ToggleAnimationConnection = Interface_Handler.ToggleAnimation.Event:Connect(
	-- 	function(Page: string, Animate: boolean)
	-- 		if Page == Settings.Page then
	-- 			Active:set(Animate or false)
	-- 		end
	-- 	end
	-- )

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local InputLabel = New("Frame")({
		[Cleanup] = { --[[ToggleAnimationConnection]]
		},
		BackgroundTransparency = 1,
		Size = props["Size"] or UDim2.fromScale(0.25, 0.25),
		AnchorPoint = props["AnchorPoint"] or Vector2.new(0.5, 0.5),
		Position = props["Position"] or UDim2.fromScale(0.5, 0.5),
		[Children] = {
			New("ImageLabel")({
				Name = "InputLabel",
				Image = props["Image"] or "rbxassetid://13190703913",
				BackgroundTransparency = 1,
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.fromScale(0.5, 0.5),
				Size = Tween(
					Computed(function()
						return Active:get() and UDim2.fromScale(1, 1) or UDim2.fromScale(0, 0)
					end),
					Tweens.modifyTween("Toon", {
						EasingDirection = Enum.EasingDirection.Out,
					})
				),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "1",
						AspectRatio = 2.55,
					}),

					New("TextBox")({
						[Ref] = TextBoxRef,
						Name = "Input",
						-- CursorPosition = -1,
						FontFace = Font.new("rbxasset://fonts/families/FredokaOne.json"),
						Text = "",
						TextColor3 = Color3.fromRGB(70, 70, 70),
						TextScaled = true,
						TextSize = 14,
						TextWrapped = true,
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundTransparency = 1,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.742, 0.35),
						TextXAlignment = props["TextXAlignment"] or Enum.TextXAlignment.Left,
						[OnEvent("Focused")] = function()
							InputFocused:set(true)
						end,
						[OnEvent("FocusLost")] = function()
							InputFocused:set(false)
							HasText:set(#TextBoxRef:get().Text > 0)
						end,
					}),

					Computed(function()
						if props.LabelName then
							return New("TextLabel")({
								Name = props.LabelName .. "Label",
								FontFace = Font.new("rbxasset://fonts/families/FredokaOne.json"),
								Text = props.LabelName,
								TextColor3 = Tween(
									Computed(function()
										local ActiveStateSize = Color3.new(1, 1, 1)
										if HasText:get() then
											return ActiveStateSize
										end

										return InputFocused:get() and ActiveStateSize or Color3.new(0.85, 0.85, 0.85)
									end),
									Tweens.modifyTween("Toon", {
										EasingDirection = Enum.EasingDirection.Out,
									})
								),
								TextScaled = true,
								TextSize = Tween(
									Computed(function()
										local ActiveStateSize = 5
										if HasText:get() then
											return ActiveStateSize
										end
										return InputFocused:get() and ActiveStateSize or 14
									end),
									Tweens.Default
								),
								TextWrapped = true,
								TextXAlignment = props["TextXAlignment"] or Enum.TextXAlignment.Left,
								BackgroundTransparency = 1,
								AnchorPoint = Vector2.new(1, 0.5),
								Position = Tween(
									Computed(function()
										local ActiveStateSize = UDim2.fromScale(0.3, -0.2)
										if HasText:get() then
											return ActiveStateSize
										end

										return InputFocused:get() and ActiveStateSize or UDim2.fromScale(0.65, 0.5)
									end),
									Tweens.modifyTween("Toon", {
										EasingDirection = Enum.EasingDirection.Out,
									})
								),
								Size = Tween(
									Computed(function()
										local ActiveStateSize = UDim2.fromScale(0.25, 0.25)
										if HasText:get() then
											return ActiveStateSize
										end

										return InputFocused:get() and ActiveStateSize or UDim2.fromScale(0.5, 0.5)
									end),
									Tweens.modifyTween("Toon", {
										EasingDirection = Enum.EasingDirection.Out,
									})
								),

								[Children] = {
									New("UIStroke")({
										Name = "1",
										Color = Color3.fromRGB(84, 175, 255),
										LineJoinMode = Enum.LineJoinMode.Miter,
										Transparency = Tween(
											Computed(function()
												if HasText:get() then
													return 0
												end

												return InputFocused:get() and 0 or 1
											end),
											Tweens.Default
										),
										Thickness = Tween(
											Computed(function()
												if HasText:get() then
													return UIStroke(1)
												end

												return InputFocused:get() and UIStroke(3) or 0
											end),
											Tweens.Default
										),
									}),
								},
							})
						end

						return {}
					end, function()
						return {}
					end),
				},
			}),
		},
	})

	return InputLabel
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX32bc56a5b54e4227928ecec53a337116">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TextLabel</string>
							<string name="ScriptGuid">{851ae386-0167-4987-997d-afafb7a36009}</string>
							<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Wednesday October 4th 2023 4:02:12 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 9:12:03 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)

--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Base",
}

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type TextLabelProps = {
	Active: any?,
	Name: string?,
	Text: string?,

	Size: UDim2,
	Position: UDim2?,
	AnchorPoint: Vector2?,

	Children: {},
}

return function(props: TextLabelProps)
	--// Value States
	local Active = props["Active"] or Value(false)
	local Hovering = Value(false)
	local Clicking = Value(false)

	--// Signals
	-- local ToggleAnimationConnection = Interface_Handler.ToggleAnimation.Event:Connect(
	-- 	function(Page: string, Animate: boolean)
	-- 		if Page == Settings.Page then
	-- 			Active:set(Animate or false)
	-- 		end
	-- 	end
	-- )

	--// Debugging
	if Interface_Settings.BaseDebug:get() == true then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local TextLabel = New("Frame")({
		[Cleanup] = { --[[ToggleAnimationConnection]]
		},
		BackgroundTransparency = 1,
		Size = props.Size,
		AnchorPoint = props["AnchorPoint"] or Vector2.new(0, 0),
		Position = props["Position"] or UDim2.fromScale(0.5, 0.5),
		[Children] = {
			New("ImageLabel")({
				Name = "NameLabelQCS",
				Image = "rbxassetid://14962576335",
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.fromScale(0.5, 0.5),
				Size = Tween(
					Computed(function()
						if Clicking:get() then
							return UDim2.fromScale(0.75, 0.75)
						end
						if Hovering:get() then
							return UDim2.fromScale(1.25, 1.25)
						end
						return Active:get() and UDim2.fromScale(1, 1) or UDim2.fromScale(0, 0)
					end),
					Tweens.modifyTween("Toon", {
						EasingDirection = Enum.EasingDirection.Out,
					})
				),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 2.26,
					}),

					New("TextLabel")({
						Name = "Label",
						FontFace = Font.new("rbxasset://fonts/families/FredokaOne.json"),
						Text = props["Text"] or "Empty",
						TextColor3 = Color3.fromRGB(0, 0, 0),
						TextScaled = true,
						TextSize = 14,
						TextWrapped = true,
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.115, 0.24),
						Size = UDim2.fromScale(0.779, 0.38),
					}),
				},
			}),
		},
	})

	return TextLabel
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXf942b8d20ada4a068a233be52fe237e3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Queue</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX101513178147438a919e12dbf5eb2aa9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Favorites</string>
							<string name="ScriptGuid">{cf41ff7a-7baf-44e3-81f9-7204dcd195b3}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local TimeSorter = require(Util.TimeSorter)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local SearchResult = require(script.SearchResult)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultsProps = {}

return function(props: SearchResultsProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local SearchResults = New("ScrollingFrame")({
		[Ref] = Handler_Interface:GetState("FavoritesResultsCanvasRef"),
		Name = "Results",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.0249, 0.2),
		Size = UDim2.fromScale(0.95, 0.799),
		Visible = true,

		ScrollBarThickness = 1,
		AutomaticCanvasSize = Enum.AutomaticSize.Y,

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),

			-- SearchResult({
			-- 	asset_audioDetails_artist = "Test",
			-- 	asset_audioDetails_musicAlbum = "Tes2",
			-- 	asset_audioDetails_title = "Song",
			-- 	asset_description = "Desc",
			-- 	asset_duration = 50,
			-- 	asset_id = 123124142,
			-- 	asset_name = "string",
			-- }),

			Computed(function()
				local SearchTab = Handler_Interface:Get("SearchTab") :: string
				local FavoritesResults = Handler_Interface:Get("FavoritesResults")

				local SongCount = 1
				local SongResultList = {}

				for Index, Song in FavoritesResults do
					Song.Index = SearchTab == "Library" and Index or SongCount
					Song.Dark = SongCount % 2 == 0

					local Current = SearchResult(Song)

					table.insert(SongResultList, Current)

					SongCount += 1
				end

				return SongResultList
			end, function() end),
		},
	})

	return SearchResults
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX33e3cf63089c4e01b52f5a36ed2d05d9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SearchResult</string>
								<string name="ScriptGuid">{7c8c3ac5-596a-4e78-81bf-d4d516ac3c2b}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultProps = {
	["asset_ageGuidelines"]: string,
	["asset_assetGenres"]: string,
	["asset_assetSubTypes"]: string,
	["asset_audioDetails_artist"]: string,
	["asset_audioDetails_audioType"]: string,
	["asset_audioDetails_musicAlbum"]: string,
	["asset_audioDetails_musicGenre"]: string,
	["asset_audioDetails_soundEffectCategory"]: string,
	["asset_audioDetails_soundEffectSubcategory"]: string,
	["asset_audioDetails_tags"]: string,
	["asset_audioDetails_title"]: string,
	["asset_createdUtc"]: string,
	["asset_creatingUniverseId"]: string,
	["asset_description"]: string,
	["asset_description_feature_extraction_Album"]: string,
	["asset_description_feature_extraction_Album Info"]: string,
	["asset_description_feature_extraction_BPM"]: number,
	["asset_description_feature_extraction_Courtesy of"]: string,
	["asset_description_feature_extraction_Duration"]: string,
	["asset_description_feature_extraction_Genre"]: string,
	["asset_description_feature_extraction_Key"]: string,
	["asset_description_feature_extraction_Library"]: string,
	["asset_duration"]: number,
	["asset_hasScripts"]: string,
	["asset_id"]: number,
	["asset_isAssetHashApproved"]: string,
	["asset_isEndorsed"]: string,
	["asset_name"]: string,
	["asset_socialLinks"]: string,
	["asset_typeId"]: number,
	["asset_updatedUtc"]: string,
	["asset_visibilityStatus"]: number,
	["creator_id"]: number,
	["creator_isVerifiedCreator"]: string,
	["creator_latestGroupUpdaterUserId"]: string,
	["creator_latestGroupUpdaterUserName"]: string,
	["creator_name"]: string,
	["creator_type"]: number,
	["product_isForSaleOrIsPublicDomain"]: string,
	["product_price"]: number,
	["product_productId"]: number,
	["voting_canVote"]: string,
	["voting_downVotes"]: number,
	["voting_hasVoted"]: string,
	["voting_showVotes"]: string,
	["voting_upVotePercent"]: number,
	["voting_upVotes"]: number,
	["voting_userVote"]: string,
	["voting_voteCount"]: number,

	Liked: boolean,
	Index: number,
	Dark: boolean,
}

return function(props: SearchResultProps)
	--// Value States
	local Active = Value(true)
	local Liked = Value(true)

	-- local LikedImage = "rbxassetid://18952672240"
	local LikedImage = "rbxassetid://70543506632381"
	local UnlikedImage = "rbxassetid://18925349461"
	-- local UnlikedImage = "rbxassetid://18925349461"

	local SearchResult = ImageButton({
		Active = Active,
		GrowthSize = 1.025,
		ShrinkSize = 0.95,
		AnimationSpeed = 0.2,
		Name = "SearchResult",
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = props["Index"] or 1,
		Size = UDim2.new(1, 0, 0, 35),
		BackgroundTransparency = props["Dark"] and 1 or 0,
		Image = "",

		Visible = Computed(function()
			return Liked:get()
		end),

		OnClick = function()
			Handler_Interface:Fire("PlaySound", props)
		end,

		Children = {
			ImageButton({
				Active = Active,
				GrowthSize = 1.1,
				ShrinkSize = 0.5,
				AspectRatio = 1.2,
				AnimationSpeed = 0.2,
				AnchorPoint = Vector2.new(1, 0.5),

				Name = "Like",
				Image = Computed(function()
					return Liked:get() and LikedImage or UnlikedImage
				end),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Size = UDim2.fromScale(0.6, 0.6),

				ImageColor3 = Computed(function()
					return Liked:get() and Handler_Interface:Get("DefaultAccentColor") or Color3.fromRGB(255, 255, 255)
				end),

				OnClick = function()
					Liked:set(false)
					Handler_Interface:Fire("LikeEvent", props, false)
				end,
			}),

			ImageButton({
				Active = Active,
				GrowthSize = 1.1,
				ShrinkSize = 0.5,
				AnimationSpeed = 0.2,

				Name = "AddToQueue",
				Image = "rbxassetid://18925349301",
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(0.6, 0.6),
				ImageColor3 = Computed(function()
					return Handler_Interface:Get("DefaultAccentColor")
				end),

				OnClick = function()
					Handler_Interface:Fire("AddToQueue", props)
				end,

				AspectRatio = 1,
			}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = props["asset_audioDetails_title"] or "Unknown",
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Size = UDim2.fromScale(0.7, 0.8),

				[Children] = {
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 5),
						PaddingRight = UDim.new(0.1, 0),
					}),
				},
			}),
		},
	})

	return SearchResult
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX9617ff58c04140acb0854dd427c8c99a">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PillsContainer</string>
							<string name="ScriptGuid">{77ac3570-7b86-41fc-af62-93467f5fc8c0}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Genres = require(Util.Genres)
local Search = require(Util.Search)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Queue",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Queue

local Pill = require(script.Pill)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PillsContainerProps = {}

return function(props: PillsContainerProps)
	--// Value States
	local Active = Value(false)
	local ParentalRef = Value(nil)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local PillsContainer = New("Frame")({
		[Ref] = ParentalRef,
		Name = "Pills",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -2,
		Size = UDim2.fromScale(0.998, 0.1),

		Visible = Computed(function()
			if Handler_Interface:Get("QueueTab") == "Favorites" then
				return true
			end

			return false
		end),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				VerticalFlex = Enum.UIFlexAlignment.SpaceBetween,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("Frame")({
				Name = "BottomSeparator",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.new(1, 0, 0, 1),
			}),

			New("Frame")({
				Name = "TopSeparator",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = -2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.new(1, 0, 0, 2),
			}),

			New("Frame")({
				Name = "PillsContainer",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0, -0.16),
				Size = UDim2.fromScale(1, 1),

				[Children] = {
					New("UIFlexItem")({
						Name = "UIFlexItem",
						FlexMode = Enum.UIFlexMode.Fill,
					}),
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 10),
					}),
					Computed(function()
						local KeyboardDetected = Handler_Interface:Get("KeyboardDetected")
						-- AutomaticCanvasSize = Enum.AutomaticSize.X,
						-- CanvasSize = UDim2.fromScale(2, 1),
						-- ScrollingDirection = Enum.ScrollingDirection.X,
						-- ScrollBarThickness = 1,

						return New(KeyboardDetected and "Frame" or "ScrollingFrame")({
							[Ref] = Handler_Interface:GetState("PillsCanvasRef"),

							Name = "Listing",
							Active = true,
							BackgroundColor3 = Color3.fromRGB(255, 255, 255),
							BackgroundTransparency = 1,
							BorderColor3 = Color3.fromRGB(0, 0, 0),
							BorderSizePixel = 0,
							Size = UDim2.fromScale(1, 0.997),

							[Children] = {
								Computed(function()
									local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame
									if PillsCanvasRef and PillsCanvasRef:IsA("ScrollingFrame") then
										PillsCanvasRef.ScrollingDirection = Enum.ScrollingDirection.X
										PillsCanvasRef.AutomaticCanvasSize = Enum.AutomaticSize.X
										PillsCanvasRef.Size = UDim2.new(1, 0, 0, 50)
										PillsCanvasRef.ScrollBarThickness = 0
									end
								end, function() end),

								New("UIListLayout")({
									Name = "UIListLayout",
									Padding = UDim.new(0.02, 0),
									FillDirection = Enum.FillDirection.Horizontal,
									SortOrder = Enum.SortOrder.LayoutOrder,
									VerticalAlignment = Enum.VerticalAlignment.Top,
									HorizontalAlignment = KeyboardDetected and Enum.HorizontalAlignment.Center
										or Enum.HorizontalAlignment.Left,
									Wraps = Computed(function()
										return KeyboardDetected
									end),
								}),

								New("UIPadding")({
									Name = "UIPadding",
									PaddingTop = KeyboardDetected and UDim.new(0, 0) or UDim.new(0.1, 0),
									PaddingBottom = KeyboardDetected and UDim.new(0.2, 0) or UDim.new(0, 0),
								}),

								Computed(function()
									local Parental = ParentalRef:get() :: Frame
									local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame
									local Favorites = Handler_Interface:Get("Favorites") :: { string }

									local PillCount = 0
									local PillComponents = {}

									for _, QueryName in Search.getPillsFromTags(Favorites) do
										PillComponents[QueryName] = Pill({
											Index = PillCount,
											Query = false,
											Text = QueryName,
											-- OnClick = function()
											-- 	local SearchResults =
											-- 		Search.searchSongs(QueryName, Handler_Interface:Get("Favorites"))
											-- 	Handler_Interface:Set("FavoritesResults", SearchResults)

											-- 	local IdStripFromResults = {}

											-- 	for i, v in pairs(Handler_Interface:Get("FavoritesResults")) do
											-- 		table.insert(IdStripFromResults, tonumber(v.asset_id))
											-- 	end

											-- 	Handler_Interface:Fire("InstaQuery", {
											-- 		["filter_value"] = QueryName,
											-- 		["results"] = IdStripFromResults,
											-- 	})
											-- end,
										})

										PillCount += 1
									end

									if #PillComponents > 0 and Parental and PillsCanvasRef then
										local FirstPill = PillComponents[1] :: ImageButton

										Parental.Size = UDim2.new(
											1,
											0,
											0, -- KeyboardDetected and 0 or 0.1,
											KeyboardDetected
													and (math.floor(#PillComponents / 3) * FirstPill.AbsoluteSize.Y) + 30
												or FirstPill.AbsoluteSize.Y + 20
										)

										local InitialSize = Parental.AbsoluteSize
									end

									return PillComponents
								end, function() end),
							},
						})
					end, function() end),

					New("ImageLabel")({
						Name = "ImageLabel",
						Image = "rbxassetid://18925300527",
						AnchorPoint = Vector2.new(1, 0),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(1, 0),
						Size = UDim2.new(-0.159, 100, 0.719, 0),
						Visible = Computed(function()
							return not Handler_Interface:Get("KeyboardDetected")
						end),
					}),
				},
			}),
		},
	})

	return PillsContainer
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXda2e93a9a8e24baa9f78759ec269db21">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Pill</string>
								<string name="ScriptGuid">{65e9a84c-1b1e-4f4f-8c0f-da8a20afe96f}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Tweens = require(Util.Tweens)
local Search = require(Util.Search)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PillProps = {
	Index: number,
	Text: string,
	Query: string,
	Genre: string,
	OnClick: (() -> nil)?,
}

return function(props: PillProps)
	--// Value States
	local Active = Value(true)

	local IsSelected = Handler_Interface:Get("Pill") == props.Text

	local Pill = ImageButton({
		Active = Active,
		Name = "Pill",
		BackgroundColor3 = Computed(function()
			return IsSelected and Handler_Interface:Get("DefaultAccentColor") or Color3.fromRGB(31, 31, 31)
		end),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Size = UDim2.fromOffset(80, 100),
		BackgroundTransparency = 0,
		Image = "",
		GrowthSize = 1.1,
		ShrinkSize = 0.9,
		AnimationSpeed = 0.1,
		LayoutOrder = Computed(function()
			return IsSelected and -1 or props.Index
		end),

		AspectRatio = 3.15,

		OnClick = function()
			local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame

			if IsSelected then
				Handler_Interface:Set("Pill", "")
				Handler_Interface:Set("FavoritesResults", Handler_Interface:Get("Favorites"))
			else
				Handler_Interface:Set("Pill", props.Text)

				local Results = Search.searchFromTag(props.Text, Handler_Interface:Get("Favorites"))

				Handler_Interface:Set(
					"FavoritesResults",
					Search.searchFromTag(props.Text, Handler_Interface:Get("Favorites"))
				)
			end

			local _ = if props["OnClick"] then props["OnClick"]() else nil
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(1, 0),
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				TextColor3 = Computed(function()
					return (
						IsSelected and Luminance(Handler_Interface:Get("DefaultAccentColor"))
						or Color3.fromRGB(255, 255, 255)
					)
				end),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				Text = props.Text,
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.9, 0.9), -- PillTextSize
			}),

			-- New("UIAspectRatioConstraint")({
			-- 	Name = "UIAspectRatioConstraint",
			-- 	AspectRatio = 3.15,
			-- }),
		},
	})

	return Pill
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX03db11b0737d406d91f1a238eb45f401">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">QueueContainer</string>
							<string name="ScriptGuid">{b96bbf55-4548-4921-8f35-b74e0780722a}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local QueueItem = require(script.QueueItem)
local QueueItemLite = require(script.QueueItemLite)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

--// Private Functions
local function registerDynamicScrollingFrame(frame)
	local layout = frame:FindFirstChildWhichIsA("UIListLayout")
	local absoluteContentSize = layout.AbsoluteContentSize
	frame.CanvasSize = UDim2.new(0, 0, 0, absoluteContentSize.Y)
	layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		local absoluteContentSize = layout.AbsoluteContentSize
		local Offset = 50

		frame.CanvasSize = UDim2.new(0, 0, 0, absoluteContentSize.Y + Offset)
	end)
end

type QueueContainerProps = {}

return function(props: QueueContainerProps)
	--// Value States
	local ScrollFrameRef = Value()

	task.spawn(function()
		local ScrollFrame = ScrollFrameRef:get()

		repeat
			ScrollFrame = ScrollFrameRef:get()
			task.wait()
		until ScrollFrame

		registerDynamicScrollingFrame(ScrollFrame)
	end)

	local QueueContainer = New("ScrollingFrame")({
		[Ref] = ScrollFrameRef,
		Name = "QueueContainer",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.0249, 0.2),
		Size = UDim2.fromScale(0.95, 0.799),
		AutomaticCanvasSize = Enum.AutomaticSize.Y,

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),

			Computed(function()
				local Queue = Handler_Interface:Get("Queue")
				local SongResultList = {}

				for Index, Song in Queue do
					Song.Index = Index
					Song.Dark = Index % 2 == 0

					table.insert(SongResultList, QueueItemLite(Song))
				end

				return SongResultList
			end, function() end),
		},
	})

	return QueueContainer
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXe17592770a1d4472bf66262817da8a95">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">QueueItem</string>
								<string name="ScriptGuid">{ca2a3561-8dc9-49e7-8c24-4a0dfb88367c}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Draggable = require(Util.Draggable)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultProps = {
	["asset_ageGuidelines"]: string,
	["asset_assetGenres"]: string,
	["asset_assetSubTypes"]: string,
	["asset_audioDetails_artist"]: string,
	["asset_audioDetails_audioType"]: string,
	["asset_audioDetails_musicAlbum"]: string,
	["asset_audioDetails_musicGenre"]: string,
	["asset_audioDetails_soundEffectCategory"]: string,
	["asset_audioDetails_soundEffectSubcategory"]: string,
	["asset_audioDetails_tags"]: string,
	["asset_audioDetails_title"]: string,
	["asset_createdUtc"]: string,
	["asset_creatingUniverseId"]: string,
	["asset_description"]: string,
	["asset_description_feature_extraction_Album"]: string,
	["asset_description_feature_extraction_Album Info"]: string,
	["asset_description_feature_extraction_BPM"]: number,
	["asset_description_feature_extraction_Courtesy of"]: string,
	["asset_description_feature_extraction_Duration"]: string,
	["asset_description_feature_extraction_Genre"]: string,
	["asset_description_feature_extraction_Key"]: string,
	["asset_description_feature_extraction_Library"]: string,
	["asset_duration"]: number,
	["asset_hasScripts"]: string,
	["asset_id"]: number,
	["asset_isAssetHashApproved"]: string,
	["asset_isEndorsed"]: string,
	["asset_name"]: string,
	["asset_socialLinks"]: string,
	["asset_typeId"]: number,
	["asset_updatedUtc"]: string,
	["asset_visibilityStatus"]: number,
	["creator_id"]: number,
	["creator_isVerifiedCreator"]: string,
	["creator_latestGroupUpdaterUserId"]: string,
	["creator_latestGroupUpdaterUserName"]: string,
	["creator_name"]: string,
	["creator_type"]: number,
	["product_isForSaleOrIsPublicDomain"]: string,
	["product_price"]: number,
	["product_productId"]: number,
	["voting_canVote"]: string,
	["voting_downVotes"]: number,
	["voting_hasVoted"]: string,
	["voting_showVotes"]: string,
	["voting_upVotePercent"]: number,
	["voting_upVotes"]: number,
	["voting_userVote"]: string,
	["voting_voteCount"]: number,

	Liked: boolean,
	Index: number,
	Dark: boolean,
}

return function(props: SearchResultProps)
	--// Value States
	local Active = Value(true)
	local DragRef = Value(nil)

	local CleanUpConnections = {}

	local CurrentQueueIndex = Handler_Interface:Get("QueueIndex")

	--// Component
	local SearchResult = ImageButton({
		[Cleanup] = {
			function()
				for _, Connection: typeof(Draggable.new()) in ipairs(CleanUpConnections) do
					Connection:Disable()
				end
			end,
		},
		Active = Active,
		GrowthSize = 1.025,
		ShrinkSize = 0.95,
		AnimationSpeed = 0.2,
		Name = "SearchResult",
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = props["Index"] or 1,
		Size = UDim2.new(1, 0, 0, 35),
		BackgroundTransparency = props["Dark"] and 1 or 0,
		Image = "",

		OnClick = function()
			Handler_Interface:Set("QueueIndex", props["Index"])
		end,

		Visible = props["Index"] > CurrentQueueIndex,

		Children = {

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			ImageButton({
				Ref = DragRef,
				Active = Active,
				GrowthSize = 1.1,
				ShrinkSize = 0.5,
				AnimationSpeed = 0.2,

				Visible = true,

				Name = "AddToQueue",
				Image = "rbxassetid://18925349301",
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(0.04, 0.533),
				ImageColor3 = Computed(function()
					return Handler_Interface:Get("DefaultAccentColor")
				end),

				OnClick = function() end,

				AspectRatio = 1,
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = props["asset_audioDetails_title"],
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Size = UDim2.fromScale(0.85, 0.8),

				[Children] = {
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 5),
						PaddingRight = UDim.new(0.1, 0),
					}),
				},
			}),
		},
	})

	task.spawn(function()
		local DragRefValue = DragRef:get()
		repeat
			task.wait()
			DragRefValue = DragRef:get()
		until DragRefValue

		local Drag = Draggable.new(DragRefValue, function(Position: UDim2)
			print(DragRefValue)
		end)

		Drag:Enable()

		table.insert(CleanUpConnections, Drag)
	end)

	return SearchResult
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX45f726dbc1364115a409b02dcf89c943">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">QueueItemLite</string>
								<string name="ScriptGuid">{2974f16a-27b8-412a-a7f5-6ef1af3f08c8}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultProps = {
	["asset_audioDetails_artist"]: string,
	["asset_audioDetails_musicAlbum"]: string,
	["asset_audioDetails_title"]: string,
	["asset_description"]: string,
	["asset_duration"]: number,
	["asset_id"]: number,
	["asset_name"]: string,

	Liked: boolean,
	Index: number,
	Dark: boolean,
}

local function WorldToScreen(Mouse, Pos) --This function gets a World Position (Pos) and returns a Vector2 value of the screen coordinates
	local Cam = workspace.CurrentCamera
	local point = Cam.CFrame:PointToObjectSpace(Pos)
	local aspectRatio = Mouse.ViewSizeX / Mouse.ViewSizeY
	local hfactor = math.tan(math.rad(Cam.FieldOfView) / 2)
	local wfactor = aspectRatio * hfactor

	local x = (point.x / point.z) / -wfactor
	local y = (point.y / point.z) / hfactor

	return Vector2.new(Mouse.ViewSizeX * (0.5 + 0.5 * x), Mouse.ViewSizeY * (0.5 + 0.5 * y))
end

return function(props: SearchResultProps)
	--// Value States
	local Active = Value(true)
	local DragRef = Value(nil)
	local Dragging = Value(false)

	local CleanUpConnections = {}
	local CurrentQueueIndex = Handler_Interface:Get("QueueIndex")

	local SearchResult = New("ImageButton")({
		[Ref] = DragRef,
		Name = "SearchResult",
		BackgroundColor3 = Handler_Interface:Get("DefaultAccentColor"),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = props["Index"] or 1,
		Size = UDim2.new(1, 0, 0, 35),
		BackgroundTransparency = props["Dark"] and 1 or 0.9,
		Image = "",

		[OnEvent("MouseButton1Click")] = function()
			local Queue = Handler_Interface:Get("Queue")
			table.remove(Queue, props["Index"])
			Handler_Interface:Set("Sound", props)

			Handler_Interface:Set("Queue", Queue)
		end,
		Visible = props["Index"] > CurrentQueueIndex,
		[Children] = {

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageButton")({
				Visible = true,

				Name = "DragHandle",
				Image = "rbxassetid://18961808481",
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(0.6, 0.6),
				ImageColor3 = Computed(function()
					return Handler_Interface:Get("DefaultAccentColor")
				end),

				[OnEvent("MouseButton1Down")] = function()
					Dragging:set(false)
				end,

				[OnEvent("MouseButton1Down")] = function()
					Dragging:set(true)

					local Button = DragRef:get() :: ImageButton
					local StarterLayoutOrder = Button.LayoutOrder

					local Transparency = Button.BackgroundTransparency

					--// Get Mouse Position and Delta
					local MousePosition = UserInputService:GetMouseLocation()

					local Highlight = New("Frame")({
						Size = UDim2.new(1, 0, 0, 1),
						BackgroundColor3 = Handler_Interface:Get("DefaultAccentColor"),
					})

					Highlight.Parent = Button.Parent

					RunService:BindToRenderStep("Drag", 0, function()
						local Height = Button.AbsoluteSize.Y
						local Delta = UserInputService:GetMouseLocation() - Button.AbsolutePosition
						local MouseDelta = UserInputService:GetMouseLocation() - MousePosition
						local NewLayoutOrder = math.clamp(
							(Button.LayoutOrder + math.floor(Delta.Y / Height)) - 1,
							0,
							#Handler_Interface:Get("Queue") + 1
						)

						Button.BackgroundTransparency = 0
						Button.SongTitle.TextColor3 = Luminance(Button.BackgroundColor3)

						if math.abs(MouseDelta.Y / Height) > 0.5 then
							Highlight.LayoutOrder =
								math.clamp(NewLayoutOrder - 1, 0, #Handler_Interface:Get("Queue") + 1)
						else
							Highlight.LayoutOrder = Button.LayoutOrder
						end

						if not UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
							Handler_Interface:Fire("QueueReorder", {
								["Index"] = StarterLayoutOrder,
								["NewIndex"] = NewLayoutOrder,
							})

							Highlight:Destroy()

							RunService:UnbindFromRenderStep("Drag")
						end
					end)
				end,

				[Children] = {
					New("UIAspectRatioConstraint")({
						AspectRatio = 1,
					}),
				},
			}),

			New("ImageButton")({

				Visible = true,

				Name = "RemoveFromQueue",
				Image = Images.Icons.Remove,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Size = UDim2.fromScale(0.6, 0.6),

				ImageColor3 = Color3.new(1, 1, 1),

				[OnEvent("MouseButton1Click")] = function()
					local CurrentQueue = Handler_Interface:Get("Queue")

					if props["asset_id"] == CurrentQueue[props.Index]["asset_id"] then
						table.remove(CurrentQueue, props["Index"])
						Handler_Interface:Set("Queue", CurrentQueue)
					end
				end,

				[Children] = {
					New("UIAspectRatioConstraint")({
						AspectRatio = 1,
					}),
				},
			}),
			New("TextLabel")({
				Name = "SongTitle",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = props["asset_audioDetails_title"],
				TextColor3 = Handler_Interface:Get("DefaultAccentColor"),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Size = UDim2.fromScale(0.7, 0.8),

				[Children] = {
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 5),
						PaddingRight = UDim.new(0.1, 0),
					}),
				},
			}),

			New("UIPadding")({
				Name = "UIPadding",
				PaddingRight = UDim.new(0.1, 0),
			}),
		},
	})
	return SearchResult
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXaa65b4ead91b4896a16375ec2b929dbb">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">QueueHeader</string>
							<string name="ScriptGuid">{62df8128-6e9a-4dd5-b6b5-c630f68bf50b}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Queue",
	HeaderPadding = 5,
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Queue

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type QueueHeaderProps = {}

return function(props: QueueHeaderProps)
	--// Value States
	local Active = Value(true)

	local SearchBoxRef = Handler_Interface:GetState("SearchBoxRef")

	local QueueHeader = New("Frame")({
		Name = "QueueHeader",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -5,
		Size = UDim2.fromScale(0.998, 0.102),

		[Children] = {
			New("UIPadding")({
				Name = "UIPadding",
				PaddingBottom = UDim.new(0, Settings.HeaderPadding),
				PaddingLeft = UDim.new(0, Settings.HeaderPadding),
				PaddingRight = UDim.new(0, Settings.HeaderPadding),
				PaddingTop = UDim.new(0, Settings.HeaderPadding),
			}),
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			ImageButton({
				Active = Active,
				Name = "BackButton",
				BackgroundColor3 = Color3.fromRGB(206, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.143, 0.769),
				Image = "",
				BackgroundTransparency = 0,
				AnimationSpeed = 0.2,
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				OnClick = function()
					Handler_Interface:Set("Page", "AudioPlayer")
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = "rbxassetid://18925477687",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.2, 0.3),
					}),
				},
			}),

			New("Frame")({
				Name = "Search",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.629, 0.769),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),
					New("UIFlexItem")({
						Name = "UIFlexItem",
						FlexMode = Enum.UIFlexMode.Fill,
					}),

					New("TextLabel")({
						[Ref] = SearchBoxRef,
						Name = "SearchBox",
						FontFace = Font.new(
							"rbxasset://fonts/families/SourceSansPro.json",
							Enum.FontWeight.Bold,
							Enum.FontStyle.Normal
						),
						Text = Computed(function()
							local CurrentAudio = Handler_Interface:Get("Sound")
							return typeof(CurrentAudio) == "table" and CurrentAudio["asset_audioDetails_title"]
								or "Unknown Title"
						end),
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextScaled = true,
						TextSize = 14,
						TextWrapped = true,
						TextXAlignment = Enum.TextXAlignment.Left,
						AnchorPoint = Vector2.new(1, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.967, 0.5),
						Size = UDim2.fromScale(0.723, 0.5),
					}),

					New("Frame")({
						Name = "Icon",
						AnchorPoint = Vector2.new(0, 0.5),
						BackgroundColor3 = Color3.fromRGB(17, 17, 17),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.025, 0.5),
						Size = UDim2.fromScale(0.189, 0.833),

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("ImageLabel")({
								Name = "Icon",
								Image = Images.Icons.Queue,
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.4, 0.4),

								[Children] = {
									New("UIAspectRatioConstraint")({
										Name = "UIAspectRatioConstraint",
									}),
								},
							}),

							New("UIAspectRatioConstraint")({
								Name = "UIAspectRatioConstraint",
							}),
						},
					}),
				},
			}),

			ImageButton({
				Visible = false,
				Active = Active,
				Name = "Clear",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.143, 0.769),
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				AnimationSpeed = 0.2,
				Image = "",
				BackgroundTransparency = 0,
				OnClick = function()
					print("Clearing")
					Handler_Interface:Set("QueueHeaderText", "")
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = "rbxassetid://18925488171",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.3, 0.3),
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 5.38,
				DominantAxis = Enum.DominantAxis.Height,
			}),
		},
	})

	return QueueHeader
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX3092ef738dc345b3aa3a8ad076c19873">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchBar</string>
							<string name="ScriptGuid">{f606dd0a-0eaa-407a-ae3e-53152daf8206}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Search = require(Util.Search)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchBarProps = {}

return function(props: SearchBarProps)
	--// Value States
	local Active = Value(true)

	local LikesSearchBoxRef = Handler_Interface:GetState("LikesSearchBoxRef")

	local SearchBar = New("Frame")({
		Name = "SearchBar",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -5,
		Size = UDim2.fromScale(0.998, 0.102),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			ImageButton({
				Active = Active,
				Name = "BackButton",
				BackgroundColor3 = Color3.fromRGB(206, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.143, 0.769),
				Image = "",
				BackgroundTransparency = 0,
				AnimationSpeed = 0.2,
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				OnClick = function()
					Handler_Interface:Set("Page", "AudioPlayer")
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = "rbxassetid://18925477687",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.2, 0.3),
					}),
				},
			}),

			New("Frame")({
				Name = "Search",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.629, 0.769),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("TextBox")({
						[Ref] = LikesSearchBoxRef,
						Name = "SearchBox",
						CursorPosition = -1,
						FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json"),
						PlaceholderColor3 = Color3.fromRGB(73, 74, 74),
						PlaceholderText = "Input your search",
						Text = Computed(function()
							return Handler_Interface:Get("LikesSearchBarText")
						end),
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextScaled = true,
						TextSize = 14,
						TextWrapped = true,
						TextXAlignment = Enum.TextXAlignment.Left,
						AnchorPoint = Vector2.new(1, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.967, 0.5),
						Size = UDim2.fromScale(0.723, 0.5),
						ClearTextOnFocus = false,

						[OnEvent("Focused")] = function() end,
						[OnEvent("FocusLost")] = function(PressedEnter: string, Element)
							local Text = LikesSearchBoxRef:get().Text
							local FavoritesResultsCanvasRef =
								Handler_Interface:Get("FavoritesResultsCanvasRef") :: ScrollingFrame

							Handler_Interface:Set("LikesSearchBarText", Text)

							if Text ~= "" then
								Handler_Interface:Set(
									"FavoritesResults",
									Search.searchSongs(Text, Handler_Interface:Get("Favorites"))
								)

								FavoritesResultsCanvasRef.CanvasPosition = Vector2.new(0, 0)
							else
								Handler_Interface:Set("FavoritesResults", Handler_Interface:Get("Favorites"))
							end
						end,
					}),

					New("Frame")({
						Name = "Icon",
						AnchorPoint = Vector2.new(0, 0.5),
						BackgroundColor3 = Color3.fromRGB(17, 17, 17),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.025, 0.5),
						Size = UDim2.fromScale(0.189, 0.833),

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("ImageLabel")({
								Name = "Icon",
								Image = "rbxassetid://18935266802",
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.4, 0.4),

								[Children] = {
									New("UIAspectRatioConstraint")({
										Name = "UIAspectRatioConstraint",
									}),
								},
							}),

							New("UIAspectRatioConstraint")({
								Name = "UIAspectRatioConstraint",
							}),
						},
					}),
				},
			}),

			ImageButton({
				Active = Active,
				Name = "Clear",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.143, 0.769),
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				AnimationSpeed = 0.2,
				Image = "",
				BackgroundTransparency = 0,
				OnClick = function()
					local SearchTab = Handler_Interface:Get("SearchTab")

					Handler_Interface:Set("Pill", "NaN")
					Handler_Interface:Set("LikesSearchBarText", "")
					Handler_Interface:Set("GenreBoxSelected", false)

					Handler_Interface:Set("FavoritesResults", Handler_Interface:Get("Favorites"))
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = "rbxassetid://18925488171",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.3, 0.3),
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 5.38,
				DominantAxis = Enum.DominantAxis.Height,
			}),
		},
	})

	return SearchBar
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX625c73e7b3fc44178c092cc430060258">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Tabs</string>
							<string name="ScriptGuid">{7d8b1347-a69e-474a-8244-4fc6fb3c4065}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type TabsProps = {}

return function(props: TabsProps)
	--// Value States
	local Active = Value(true)
	local QueueTab = Handler_Interface:GetState("QueueTab")

	local Tabs = New("Frame")({
		Name = "Tabs",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -10,
		Size = UDim2.fromScale(0.998, 0.102),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("Frame")({
				Name = "TabContainer",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.0238, 0.115),
				Size = UDim2.fromScale(0.939, 0.769),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("Frame")({
						Name = "Underlay",
						BackgroundColor3 = Computed(function()
							return Handler_Interface:Get("DefaultAccentColor")
						end),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Size = UDim2.fromScale(0.5, 1),
						AnchorPoint = Tween(
							Computed(function()
								return QueueTab:get() == "Queue" and Vector2.new(0, 0) or Vector2.new(1, 0)
							end),
							Tweens.Fast
						),

						Position = Tween(
							Computed(function()
								return QueueTab:get() == "Queue" and UDim2.fromScale(0, 0) or UDim2.fromScale(1, 0)
							end),
							Tweens.Fast
						),

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),
						},
					}),

					New("Frame")({
						Name = "Overlay",
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Size = UDim2.fromScale(1, 1),

						[Children] = {
							New("UIListLayout")({
								Name = "UIListLayout",
								FillDirection = Enum.FillDirection.Horizontal,
								SortOrder = Enum.SortOrder.LayoutOrder,
							}),

							ImageButton({
								Active = Active,
								Size = Computed(function()
									if QueueTab:get() == "Queue" then
										return UDim2.fromScale(0.5, 1)
									end

									return UDim2.fromScale(0.5, 1)
								end),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								Image = "",
								AnimationSpeed = 0.2,
								GrowthSize = 1.1,
								ShrinkSize = 0.9,

								OnClick = function()
									QueueTab:set("Queue")
								end,
								Children = {
									New("TextLabel")({
										Name = "Queue",
										FontFace = Font.new(
											"rbxasset://fonts/families/SourceSansPro.json",
											Enum.FontWeight.Bold,
											Enum.FontStyle.Normal
										),
										TextSize = 25,
										TextScaled = true,
										TextWrapped = true,
										Text = "Queue",
										BackgroundColor3 = Color3.fromRGB(255, 255, 255),
										BackgroundTransparency = 1,
										BorderColor3 = Color3.fromRGB(0, 0, 0),
										TextColor3 = Tween(
											Computed(function()
												return QueueTab:get() ~= "Queue" and Color3.new(1, 1, 1)
													or Color3.new(0, 0, 0)
											end),
											Tweens.Fast
										),
										BorderSizePixel = 0,
										Size = UDim2.fromScale(1, 1),
									}),

									New("UIPadding")({
										Name = "UIPadding",
										PaddingBottom = UDim.new(0, 5),
										PaddingLeft = UDim.new(0, 5),
										PaddingRight = UDim.new(0, 5),
										PaddingTop = UDim.new(0, 5),
									}),
								},
							}),

							ImageButton({
								Active = Active,
								Size = Computed(function()
									return UDim2.fromScale(0.5, 1)
								end),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								Image = "",
								AnimationSpeed = 0.2,
								GrowthSize = 1.1,
								ShrinkSize = 0.9,

								AnchorPoint = Vector2.new(0.5, 0),
								Position = UDim2.fromScale(0.5, 0),
								OnClick = function()
									QueueTab:set("Favorites")
								end,
								Children = {
									New("TextLabel")({
										Name = "Favorites",
										FontFace = Font.new(
											"rbxasset://fonts/families/SourceSansPro.json",
											Enum.FontWeight.Bold,
											Enum.FontStyle.Normal
										),
										TextSize = 25,
										TextScaled = true,
										TextWrapped = true,
										Text = "Favorites",
										BackgroundColor3 = Color3.fromRGB(255, 255, 255),
										BackgroundTransparency = 1,
										BorderColor3 = Color3.fromRGB(0, 0, 0),
										TextColor3 = Tween(
											Computed(function()
												return QueueTab:get() == "Queue" and Color3.new(1, 1, 1)
													or Color3.new(0, 0, 0)
											end),
											Tweens.Fast
										),
										BorderSizePixel = 0,
										Size = UDim2.fromScale(1, 1),
									}),

									New("UIPadding")({
										Name = "UIPadding",
										PaddingBottom = UDim.new(0, 5),
										PaddingLeft = UDim.new(0, 5),
										PaddingRight = UDim.new(0, 5),
										PaddingTop = UDim.new(0, 5),
									}),
								},
							}),
						},
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 5.38,
				DominantAxis = Enum.DominantAxis.Height,
			}),
		},
	})

	return Tabs
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXbce3f8b848714f5bab083efe712588aa">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Root</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXc5e60c20ff0641c18793d47c810a52b8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Search</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXb328a5eb5f80495bbb6ed1f797439f42">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GenreBoxes</string>
							<string name="ScriptGuid">{362acaad-5998-4dae-943b-1fdfcb666328}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Genres = require(Util.Genres)
local Luminance = require(Util.Luminance)
local MatteColor = require(Util.MatteColor)
local PastelColor = require(Util.PastelColor)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type GenreBoxesProps = {}

return function(props: GenreBoxesProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local GenreBoxes = New("ScrollingFrame")({
		Name = "GenreBoxes",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.0249, 0.2),
		Size = UDim2.fromScale(0.95, 0.799),
		AutomaticCanvasSize = Enum.AutomaticSize.Y,
		ScrollBarThickness = 1,

		Visible = Computed(function()
			local SearchTab = Handler_Interface:Get("SearchTab") :: string
			local SearchBarText = Handler_Interface:Get("SearchBarText") :: string
			local GenreBoxSelected = Handler_Interface:Get("GenreBoxSelected") :: string

			if SearchTab ~= "Library" then
				return false
			end

			if GenreBoxSelected or #SearchBarText > 0 then
				return false
			end

			return true
		end),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				Wraps = true,
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			New("UIPadding")({
				Name = "UIPadding",
				PaddingBottom = UDim.new(0, 5),
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),

			Computed(function()
				local Temp = {}
				local DisabledGeneres = {
					["Heavy Metal"] = true,
					["Rock Soundtrack"] = true,
					["Dubstep"] = true,
					["Chill Rock"] = true,
					["Chill Electronic"] = true,
					["Chill Orchestral"] = true,
					["Epic Orchestral"] = true,
				}

				for Index, AudioScapeGenre in Handler_Interface:Get("Genres") do
					if DisabledGeneres[AudioScapeGenre] then
						continue
					end

					local BoxColor = MatteColor()

					table.insert(
						Temp,
						New("ImageButton")({
							Name = "GenreBox",
							ImageColor3 = BoxColor,
							BackgroundColor3 = BoxColor,
							BorderColor3 = Color3.fromRGB(0, 0, 0),
							BorderSizePixel = 0,
							Size = UDim2.fromScale(0.32, 1),
							Visible = true,
							[OnEvent("MouseButton1Click")] = function()
								Handler_Interface:Set("GenreBoxSelected", AudioScapeGenre)
								Handler_Interface:Fire("ClientTelemetry", "search", {
									genre = AudioScapeGenre,
								})
							end,

							[Children] = {
								New("UIAspectRatioConstraint")({
									Name = "UIAspectRatioConstraint",
								}),

								New("UICorner")({
									Name = "UICorner",
								}),

								New("UIPadding")({
									Name = "UIPadding",
									PaddingBottom = UDim.new(0.1, 0),
									PaddingLeft = UDim.new(0.1, 0),
									PaddingRight = UDim.new(0.1, 0),
									PaddingTop = UDim.new(0.1, 0),
								}),

								New("TextLabel")({
									Name = "TextLabel",
									FontFace = Font.new(
										"rbxasset://fonts/families/SourceSansPro.json",
										Enum.FontWeight.Bold,
										Enum.FontStyle.Normal
									),
									Text = AudioScapeGenre,
									TextColor3 = Computed(function()
										return Luminance(BoxColor)
									end),
									TextScaled = true,
									TextSize = 14,
									TextWrapped = true,
									TextXAlignment = Enum.TextXAlignment.Left,
									TextYAlignment = Enum.TextYAlignment.Bottom,
									BackgroundColor3 = Color3.fromRGB(255, 255, 255),
									BackgroundTransparency = 1,
									BorderColor3 = Color3.fromRGB(0, 0, 0),
									BorderSizePixel = 0,
									Size = UDim2.fromScale(1, 1),

									[Children] = {
										New("UITextSizeConstraint")({
											Name = "UITextSizeConstraint",
											MaxTextSize = 40,
										}),
									},
								}),
							},
						})
					)
				end

				return Temp
			end, function() end),
		},
	})

	return GenreBoxes
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6c5a9e455a0b44bda757c33379499925">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PillsContainer</string>
							<string name="ScriptGuid">{4365eb84-85ce-4d6d-ba17-189edbc4253a}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Genres = require(Util.Genres)
local Search = require(Util.Search)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local Pill = require(script.Pill)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PillsContainerProps = {}

return function(props: PillsContainerProps)
	--// Value States
	local Active = Value(false)
	local ParentalRef = Value(nil)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local PillsContainer = New("Frame")({
		[Ref] = ParentalRef,
		Name = "Pills",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -2,
		Size = UDim2.fromScale(0.998, 0.1),

		Visible = Computed(function()
			if Handler_Interface:Get("SearchTab") ~= "Library" then
				return true
			end

			return Handler_Interface:Get("GenreBoxSelected") and true or false
		end),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				VerticalFlex = Enum.UIFlexAlignment.SpaceBetween,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("Frame")({
				Name = "BottomSeparator",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.new(1, 0, 0, 1),
			}),

			New("Frame")({
				Name = "TopSeparator",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = -2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.new(1, 0, 0, 2),
			}),

			New("Frame")({
				Name = "PillsContainer",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0, -0.16),
				Size = UDim2.fromScale(1, 1),

				[Children] = {
					New("UIFlexItem")({
						Name = "UIFlexItem",
						FlexMode = Enum.UIFlexMode.Fill,
					}),
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 10),
					}),
					Computed(function()
						local KeyboardDetected = Handler_Interface:Get("KeyboardDetected")
						-- AutomaticCanvasSize = Enum.AutomaticSize.X,
						-- CanvasSize = UDim2.fromScale(2, 1),
						-- ScrollingDirection = Enum.ScrollingDirection.X,
						-- ScrollBarThickness = 1,

						return New(KeyboardDetected and "Frame" or "ScrollingFrame")({
							[Ref] = Handler_Interface:GetState("PillsCanvasRef"),

							Name = "Listing",
							Active = true,
							BackgroundColor3 = Color3.fromRGB(255, 255, 255),
							BackgroundTransparency = 1,
							BorderColor3 = Color3.fromRGB(0, 0, 0),
							BorderSizePixel = 0,
							Size = UDim2.fromScale(1, 0.997),

							[Children] = {
								Computed(function()
									local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame
									if PillsCanvasRef and PillsCanvasRef:IsA("ScrollingFrame") then
										PillsCanvasRef.ScrollingDirection = Enum.ScrollingDirection.X
										PillsCanvasRef.AutomaticCanvasSize = Enum.AutomaticSize.X
										PillsCanvasRef.Size = UDim2.new(1, 0, 0, 50)
										PillsCanvasRef.ScrollBarThickness = 0
									end
								end, function() end),

								New("UIListLayout")({
									Name = "UIListLayout",
									Padding = UDim.new(0.02, 0),
									FillDirection = Enum.FillDirection.Horizontal,
									SortOrder = Enum.SortOrder.LayoutOrder,
									VerticalAlignment = Enum.VerticalAlignment.Top,
									HorizontalAlignment = KeyboardDetected and Enum.HorizontalAlignment.Center
										or Enum.HorizontalAlignment.Left,
									Wraps = Computed(function()
										return KeyboardDetected
									end),
								}),

								New("UIPadding")({
									Name = "UIPadding",
									PaddingTop = KeyboardDetected and UDim.new(0, 0) or UDim.new(0.1, 0),
									PaddingBottom = KeyboardDetected and UDim.new(0.2, 0) or UDim.new(0, 0),
								}),

								Computed(function()
									local Parental = ParentalRef:get() :: Frame
									local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame
									local Emotions = Handler_Interface:Get("Emotions") :: { string }
									local SelectedGenre = Handler_Interface:Get("GenreBoxSelected") :: string?

									local PillCount = 0
									local PillComponents = {}

									if SelectedGenre then
										-- for Index, Emotion in Emotions do
										for Index, Emotion in Emotions do
											table.insert(
												PillComponents,
												Pill({
													Index = PillCount,
													Text = Emotion,
													Genre = SelectedGenre,
												})
											)

											PillCount += 1
										end
									end

									if #PillComponents > 0 and Parental and PillsCanvasRef then
										local FirstPill = PillComponents[1] :: ImageButton

										Parental.Size = UDim2.new(
											1,
											0,
											0, -- KeyboardDetected and 0 or 0.1,
											KeyboardDetected
													and (math.floor(#PillComponents / 3) * FirstPill.AbsoluteSize.Y) + 30
												or FirstPill.AbsoluteSize.Y + 20
										)

										local InitialSize = Parental.AbsoluteSize

										print(InitialSize, math.floor(InitialSize.X / FirstPill.AbsoluteSize.X))
									end

									return PillComponents
								end, function() end),
							},
						})
					end, function() end),

					New("ImageLabel")({
						Name = "ImageLabel",
						Image = "rbxassetid://18925300527",
						AnchorPoint = Vector2.new(1, 0),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(1, 0),
						Size = UDim2.new(-0.159, 100, 0.719, 0),
						Visible = Computed(function()
							return not Handler_Interface:Get("KeyboardDetected")
						end),
					}),
				},
			}),
		},
	})

	return PillsContainer
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX9dfdccf6663c44ceb5219952f0f4e699">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Pill</string>
								<string name="ScriptGuid">{629ba17f-ee8b-4ab0-ae4c-574fb79710ac}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Search = require(Util.Search)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PillProps = {
	Index: number,
	Text: string,
	Genre: string,
	OnClick: (() -> nil)?,
}

return function(props: PillProps)
	--// Value States
	local Active = Value(true)

	local IsSelected = Handler_Interface:Get("Pill") == props.Text

	local Pill = ImageButton({
		Active = Active,
		Name = "Pill",
		BackgroundColor3 = Computed(function()
			return IsSelected and Handler_Interface:Get("DefaultAccentColor") or Color3.fromRGB(31, 31, 31)
		end),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Size = UDim2.fromOffset(80, 100),
		BackgroundTransparency = 0,
		Image = "",
		GrowthSize = 1.1,
		ShrinkSize = 0.9,
		AnimationSpeed = 0.1,
		LayoutOrder = Computed(function()
			return IsSelected and -1 or props.Index
		end),

		AspectRatio = 3.15,

		OnClick = function()
			local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame
			local SearchResultsCanvasRef = Handler_Interface:Get("SearchResultsCanvasRef") :: ScrollingFrame

			if IsSelected then
				Handler_Interface:Set("Pill", "")
				Handler_Interface:Fire("ClientTelemetry", "search", {
					genre = props["Genre"],
				})
			else
				Handler_Interface:Set("Pill", props.Text)
				Handler_Interface:Fire("ClientTelemetry", "search", {
					genre = props["Genre"],
					emotion = props["Text"],
				})
			end

			SearchResultsCanvasRef.CanvasPosition = Vector2.new(0, 0)

			local _ = if props["OnClick"] then props["OnClick"]() else nil
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(1, 0),
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				TextColor3 = Computed(function()
					return (
						IsSelected and Luminance(Handler_Interface:Get("DefaultAccentColor"))
						or Color3.fromRGB(255, 255, 255)
					)
				end),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				Text = props.Text,
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.9, 0.9), -- PillTextSize
			}),

			-- New("UIAspectRatioConstraint")({
			-- 	Name = "UIAspectRatioConstraint",
			-- 	AspectRatio = 3.15,
			-- }),
		},
	})

	return Pill
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXdd96aa0f410d468395c4641fadb2ec85">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchBar</string>
							<string name="ScriptGuid">{5da73d57-814e-485d-b7e0-fe20e1503deb}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Search = require(Util.Search)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchBarProps = {}

return function(props: SearchBarProps)
	--// Value States
	local Active = Value(true)

	local SearchBoxRef = Handler_Interface:GetState("SearchBoxRef")

	local SearchBar = New("Frame")({
		Name = "SearchBar",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -5,
		Size = UDim2.fromScale(0.998, 0.102),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("UIPadding")({
				Name = "UIPadding",

				PaddingLeft = UDim.new(0, 10),
				PaddingRight = UDim.new(0, 10),
			}),

			New("Frame")({
				Name = "Search",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.939, 0.769),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("TextBox")({
						[Ref] = SearchBoxRef,
						Name = "SearchBox",
						CursorPosition = -1,
						FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json"),
						PlaceholderColor3 = Color3.fromRGB(73, 74, 74),
						PlaceholderText = "Input your search",
						Text = Computed(function()
							return Handler_Interface:Get("SearchBarText")
						end),
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextScaled = true,
						TextSize = 14,
						TextWrapped = true,
						TextXAlignment = Enum.TextXAlignment.Left,
						AnchorPoint = Vector2.new(1, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.967, 0.5),
						Size = UDim2.fromScale(0.723, 0.5),
						ClearTextOnFocus = false,

						[OnEvent("Focused")] = function() end,
						[OnEvent("FocusLost")] = function(PressedEnter: string, Element)
							local Text = SearchBoxRef:get().Text

							Handler_Interface:Set("SearchBarText", Text)

							if Handler_Interface:Get("SearchTab") == "Library" then
								Handler_Interface:Fire("ClientTelemetry", "search", {
									query = Text,
								})
							else
								if Text ~= "" then
									Handler_Interface:Set(
										"FavoritesResults",
										Search.searchSongs(Text, Handler_Interface:Get("Favorites"))
									)
								else
									Handler_Interface:Set("FavoritesResults", Handler_Interface:Get("Favorites"))
								end
							end
						end,
					}),

					New("Frame")({
						Name = "Icon",
						AnchorPoint = Vector2.new(0, 0.5),
						BackgroundColor3 = Color3.fromRGB(17, 17, 17),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.025, 0.5),
						Size = UDim2.fromScale(0.189, 0.833),

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("ImageLabel")({
								Name = "Icon",
								Image = "rbxassetid://18935266802",
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.4, 0.4),

								[Children] = {
									New("UIAspectRatioConstraint")({
										Name = "UIAspectRatioConstraint",
									}),
								},
							}),

							New("UIAspectRatioConstraint")({
								Name = "UIAspectRatioConstraint",
							}),
						},
					}),

					ImageButton({
						Active = Active,
						Name = "Clear",
						BackgroundColor3 = Color3.fromRGB(31, 31, 31),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						AnchorPoint = Vector2.new(1, 0.5),
						LayoutOrder = 2,
						Position = UDim2.fromScale(0.99, 0.5),
						Size = UDim2.fromScale(0.143, 0.769),
						GrowthSize = 1.1,
						ShrinkSize = 0.9,
						AnimationSpeed = 0.2,
						Image = "",
						BackgroundTransparency = 0,
						OnClick = function()
							local SearchTab = Handler_Interface:Get("SearchTab")

							Handler_Interface:Set("Pill", "NaN")
							Handler_Interface:Set("SearchBarText", "")
							Handler_Interface:Set("GenreBoxSelected", false)

							if SearchTab == "Library" then
								Handler_Interface:Set("LibraryResults", {})
							else
								Handler_Interface:Set("FavoritesResults", Handler_Interface:Get("Favorites"))
							end
						end,

						Children = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("ImageLabel")({
								Name = "Icon",
								Image = "rbxassetid://18925488171",
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.3, 0.3),
							}),
						},
					}),

					New("UIFlexItem")({
						Name = "UIFlexItem",
						FlexMode = Enum.UIFlexMode.Fill,
					}),
				},
			}),

			-- ImageButton({
			-- 	Active = Active,
			-- 	Name = "Search",
			-- 	BackgroundColor3 = Color3.fromRGB(31, 31, 31),
			-- 	BorderColor3 = Color3.fromRGB(0, 0, 0),
			-- 	BorderSizePixel = 0,
			-- 	LayoutOrder = 2,
			-- 	Position = UDim2.fromScale(0.329, 0),
			-- 	Size = UDim2.fromScale(0.143, 0.769),
			-- 	GrowthSize = 1.1,
			-- 	ShrinkSize = 0.9,
			-- 	AnimationSpeed = 0.2,
			-- 	Image = "",
			-- 	BackgroundTransparency = 0,
			-- 	OnClick = function() end,

			-- 	Children = {
			-- 		New("UICorner")({
			-- 			Name = "UICorner",
			-- 			CornerRadius = UDim.new(0, 5),
			-- 		}),

			-- 		New("ImageLabel")({
			-- 			Name = "Icon",
			-- 			Image = "rbxassetid://18935266802",
			-- 			AnchorPoint = Vector2.new(0.5, 0.5),
			-- 			BackgroundColor3 = Color3.fromRGB(255, 255, 255),
			-- 			BackgroundTransparency = 1,
			-- 			BorderColor3 = Color3.fromRGB(0, 0, 0),
			-- 			BorderSizePixel = 0,
			-- 			Position = UDim2.fromScale(0.5, 0.5),
			-- 			Size = UDim2.fromScale(0.3, 0.3),
			-- 		}),
			-- 	},
			-- }),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 5.38,
				DominantAxis = Enum.DominantAxis.Height,
			}),
		},
	})

	return SearchBar
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXa22815d315ae43c5a7050d9a1a6620a7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchResults</string>
							<string name="ScriptGuid">{6077e6c0-ea24-44e8-93e6-04678a59fda5}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local TimeSorter = require(Util.TimeSorter)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local SearchResult = require(script.SearchResult)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultsProps = {}

return function(props: SearchResultsProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local SearchResults = New("ScrollingFrame")({
		[Ref] = Handler_Interface:GetState("SearchResultsCanvasRef"),
		Name = "Results",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.0249, 0.2),
		Size = UDim2.fromScale(0.95, 0.799),
		Visible = Computed(function()
			local Searching = Handler_Interface:Get("Searching") :: boolean
			local SearchTab = Handler_Interface:Get("SearchTab") :: string
			local SearchBarText = Handler_Interface:Get("SearchBarText") :: string
			local GenreBoxSelected = Handler_Interface:Get("GenreBoxSelected") :: string

			if Searching then
				return false
			end

			if SearchTab ~= "Library" then
				return true
			end

			if #SearchBarText > 0 or GenreBoxSelected then
				return true
			end

			return false
		end),

		ScrollBarThickness = 1,
		AutomaticCanvasSize = Enum.AutomaticSize.Y,

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),

			Computed(function()
				local SearchTab = Handler_Interface:Get("SearchTab") :: string
				local LibraryResults = Handler_Interface:Get("LibraryResults")
				local FavoritesResults = Handler_Interface:Get("FavoritesResults")

				local SongCount = 1
				local SongResultList = {}

				local CuratedResults = SearchTab == "Library" and LibraryResults or FavoritesResults

				if SearchTab ~= "Library" and #CuratedResults > 1 then
					TimeSorter(CuratedResults)
				end

				for Index, Song in CuratedResults do
					Song.Index = SearchTab == "Library" and Index or SongCount
					Song.Dark = SongCount % 2 == 0

					table.insert(SongResultList, SearchResult(Song))

					SongCount += 1
				end

				return SongResultList
			end, function() end),
		},
	})

	return SearchResults
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXd0de2478811f4f2da52af1c3a3d0d0ce">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SearchResult</string>
								<string name="ScriptGuid">{cf08257a-6aaf-40b0-9437-913afc409fd5}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultProps = {
	["asset_audioDetails_audioType"]: string,
	["asset_audioDetails_musicAlbum"]: string,
	["asset_audioDetails_musicGenre"]: string,
	["asset_audioDetails_tags"]: string,
	["asset_audioDetails_title"]: string,
	["asset_description"]: string,
	["asset_id"]: number,
	["asset_isEndorsed"]: string,

	Liked: boolean,
	Index: number,
	Dark: boolean,
}

return function(props: SearchResultProps)
	--// Value States
	local FavoritesDictionary = Handler_Interface:Get("FavoritesDictionary")

	local Active = Value(true)
	local Liked = Value(FavoritesDictionary[props["asset_id"]] or false)

	local LikedImage = "rbxassetid://18952672240"
	local UnlikedImage = "rbxassetid://18925349461"

	local SearchResult = ImageButton({
		Active = Active,
		GrowthSize = 1.025,
		ShrinkSize = 0.95,
		AnimationSpeed = 0.2,
		Name = "SearchResult",
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = props["Index"] or 1,
		Size = UDim2.new(1, 0, 0, 35),
		BackgroundTransparency = props["Dark"] and 1 or 0,
		Image = "",

		OnClick = function()
			Handler_Interface:Fire("PlaySound", props)
		end,

		Children = {
			ImageButton({
				Active = Active,
				GrowthSize = 1.1,
				ShrinkSize = 0.5,
				AspectRatio = 1.2,
				AnimationSpeed = 0.2,

				Visible = Computed(function()
					return Handler_Interface:Get("SearchTab") == "Library"
				end),

				Name = "Like",
				Image = Computed(function()
					return Liked:get() and LikedImage or UnlikedImage
				end),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Size = UDim2.fromScale(0.6, 0.6),

				ImageColor3 = Computed(function()
					return Liked:get() and Handler_Interface:Get("DefaultAccentColor") or Color3.fromRGB(255, 255, 255)
				end),

				OnClick = function()
					Liked:set(not Liked:get())
					Handler_Interface:Fire("LikeEvent", props, Liked:get())
				end,
			}),

			ImageButton({
				Active = Active,
				GrowthSize = 1.1,
				ShrinkSize = 0.5,
				AnimationSpeed = 0.2,

				Visible = Computed(function()
					return Handler_Interface:Get("SearchTab") == "Library"
				end),

				Name = "AddToQueue",
				Image = "rbxassetid://18925349301",
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(0.6, 0.6),
				ImageColor3 = Computed(function()
					return Handler_Interface:Get("DefaultAccentColor")
				end),

				OnClick = function()
					Handler_Interface:Fire("AddToQueue", props)
				end,

				AspectRatio = 1,
			}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = props["asset_audioDetails_title"] or "Unknown",
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Size = UDim2.fromScale(0.7, 0.8),

				[Children] = {
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 5),
						PaddingRight = UDim.new(0.1, 0),
					}),
				},
			}),
		},
	})

	return SearchResult
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX6c55245c6b204047bf0c52f3cc9cfe7d">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchingFrame</string>
							<string name="ScriptGuid">{689c4850-96e1-4b7c-9d4c-f3a2d103a903}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Genres = require(Util.Genres)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
	SpinnerSize = 50,
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchingFrameProps = {}

return function(props: SearchingFrameProps)
	--// Value States
	local Active = Value(false)
	local SpinnerRef = Value()

	RunService:BindToRenderStep("BoomboxSearchingAnimation", 0, function()
		if SpinnerRef:get() then
			SpinnerRef:get().Rotation = SpinnerRef:get().Rotation + 5
		end
	end)

	local SearchingFrame = New("Frame")({
		[Cleanup] = function()
			RunService:UnbindFromRenderStep("BoomboxSearchingAnimation")
		end,
		Name = "SearchingFrame",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.0249, 0.2),
		Size = UDim2.fromScale(0.95, 0.799),

		Visible = Computed(function()
			return Handler_Interface:Get("Searching")
		end),

		[Children] = {

			New("UIPadding")({
				Name = "UIPadding",
				PaddingTop = UDim.new(0, 5),
				PaddingBottom = UDim.new(0, 5),
			}),

			New("Frame")({
				[Ref] = SpinnerRef,
				Size = UDim2.fromOffset(Settings.SpinnerSize, Settings.SpinnerSize),
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.fromScale(0.5, 0.5),
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = "Searching...",
				TextColor3 = Computed(function()
					return Luminance(Color3.new(0, 0, 0))
				end),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Bottom,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(1, 1),

				[Children] = {
					New("UITextSizeConstraint")({
						Name = "UITextSizeConstraint",
						MaxTextSize = 40,
					}),
				},
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),
		},
	})

	return SearchingFrame
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXc569db0c03b94319ae30130d7cc9d082">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Tabs</string>
							<string name="ScriptGuid">{3a8ca3f3-4614-4806-8c9c-bc51dbc00428}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type TabsProps = {}

return function(props: TabsProps)
	--// Value States
	local Active = Value(true)
	local SearchTab = Handler_Interface:GetState("SearchTab")

	local Tabs = New("Frame")({
		Name = "Tabs",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -10,
		Size = UDim2.fromScale(0.998, 0.102),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("Frame")({
				Name = "TabContainer",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.0238, 0.115),
				Size = UDim2.fromScale(0.939, 0.769),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("UIListLayout")({
						Name = "UIListLayout",
						FillDirection = Enum.FillDirection.Horizontal,
						SortOrder = Enum.SortOrder.LayoutOrder,
						Padding = UDim.new(0.02, 0),
					}),

					ImageButton({
						Active = Active,
						Name = "BackButton",
						BackgroundColor3 = Color3.fromRGB(206, 31, 31),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.0, 0),
						Size = UDim2.fromScale(1, 1),
						Image = "",
						BackgroundTransparency = 0,
						LayoutOrder = -2,
						AnimationSpeed = 0.2,
						GrowthSize = 1.1,
						ShrinkSize = 0.9,
						AspectRatio = 1,
						OnClick = function()
							Handler_Interface:Set("Page", "AudioPlayer")
						end,

						Children = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("ImageLabel")({
								Name = "Icon",
								Image = "rbxassetid://18925477687",
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.2, 0.3),
							}),
						},
					}),

					New("Frame")({
						Name = "Overlay",
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 0,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Size = UDim2.fromScale(1, 1),

						[Children] = {
							New("UIListLayout")({
								Name = "UIListLayout",
								FillDirection = Enum.FillDirection.Horizontal,
								SortOrder = Enum.SortOrder.LayoutOrder,
							}),

							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("UIFlexItem")({
								Name = "UIFlexItem",
								FlexMode = Enum.UIFlexMode.Fill,
							}),

							ImageButton({
								Active = Active,
								Size = Computed(function()
									if SearchTab:get() == "Library" then
										return UDim2.fromScale(1, 1)
									end

									return UDim2.fromScale(0, 1)
								end),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								Image = "",
								AnimationSpeed = 0.2,
								GrowthSize = 1.1,
								ShrinkSize = 0.9,

								OnClick = function()
									SearchTab:set("Library")
								end,
								Children = {
									New("TextLabel")({
										Name = "Library",
										FontFace = Font.new(
											"rbxasset://fonts/families/SourceSansPro.json",
											Enum.FontWeight.Bold,
											Enum.FontStyle.Normal
										),
										TextSize = 25,
										TextScaled = true,
										TextWrapped = true,
										Text = Computed(function()
											local GenreBoxSelected = Handler_Interface:Get("GenreBoxSelected")

											if GenreBoxSelected then
												return GenreBoxSelected
											end

											return "Search"
										end),
										BackgroundColor3 = Color3.fromRGB(255, 255, 255),
										BackgroundTransparency = 1,
										BorderColor3 = Color3.fromRGB(0, 0, 0),
										TextColor3 = Color3.new(0, 0, 0),
										BorderSizePixel = 0,
										Size = UDim2.fromScale(1, 1),
									}),

									New("UIPadding")({
										Name = "UIPadding",
										PaddingBottom = UDim.new(0, 5),
										PaddingLeft = UDim.new(0, 5),
										PaddingRight = UDim.new(0, 5),
										PaddingTop = UDim.new(0, 5),
									}),
								},
							}),

							ImageButton({
								Active = Active,
								Size = Computed(function()
									if Handler_Interface:Get("SearchTab") ~= "Library" then
										return UDim2.fromScale(1, 1)
									end

									return UDim2.fromScale(0, 1)
								end),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								Image = "",
								AnimationSpeed = 0.2,
								GrowthSize = 1.1,
								ShrinkSize = 0.9,

								OnClick = function()
									SearchTab:set("Favorites")
								end,
								Children = {
									New("TextLabel")({
										Name = "Favorites",
										FontFace = Font.new(
											"rbxasset://fonts/families/SourceSansPro.json",
											Enum.FontWeight.Bold,
											Enum.FontStyle.Normal
										),
										TextSize = 25,
										TextScaled = true,
										TextWrapped = true,
										Text = "Favorites",
										BackgroundColor3 = Color3.fromRGB(255, 255, 255),
										BackgroundTransparency = 1,
										BorderColor3 = Color3.fromRGB(0, 0, 0),
										TextColor3 = Color3.new(0, 0, 0),
										BorderSizePixel = 0,
										Size = UDim2.fromScale(1, 1),
									}),

									New("UIPadding")({
										Name = "UIPadding",
										PaddingBottom = UDim.new(0, 5),
										PaddingLeft = UDim.new(0, 5),
										PaddingRight = UDim.new(0, 5),
										PaddingTop = UDim.new(0, 5),
									}),
								},
							}),
						},
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 5.38,
				DominantAxis = Enum.DominantAxis.Height,
			}),
		},
	})

	return Tabs
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX13e0767bb3054c638ea46c2c1e2f1f69">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Config</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX6c0097e37a5743bfbcb959f44f5f7751">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InterfaceSettings</string>
						<string name="ScriptGuid">{ecbf7906-0239-4b56-adfe-4fab0c398320}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Sunday September 17th 2023 3:58:52 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Monday December 18th 2023 11:51:17 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
local module = {
	AutoActive = "NaN",
	BaseDebug = false,
}

return module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXcc5839c585fc4f69934fef705d469d91">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InterfaceSignals</string>
						<string name="ScriptGuid">{a149f880-3206-47c7-9248-cf38e67aca00}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Monday September 18th 2023 12:27:53 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Saturday November 25th 2023 11:07:20 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
local Handler_Interface = {
	ToggleAnimation = Instance.new("BindableEvent"),
}

return Handler_Interface]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXd0b8665dc68643b5b235f71c05ea605d">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InterfaceStates</string>
						<string name="ScriptGuid">{9df3ad39-0044-4390-bae3-2fdfaa8ece16}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Saturday September 23rd 2023 2:04:00 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Saturday September 23rd 2023 2:04:39 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
local Value = Fusion.Value

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXe707cacad20743718ed641ec8230aa26">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Handlers</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0fa0f6f878c84eaabbe6e3c2ba0c0ac8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Handlers_Interface</string>
						<string name="ScriptGuid">{912dce7f-90b9-4290-aaae-a4c3169f4b41}</string>
						<ProtectedString name="Source"><![CDATA[---@diagnostic disable: undefined-type
--[[
--Created Date: Monday November 20th 2023 12:13:34 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 10:51:19 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
-- Implementation of Interface.

--// Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")

--// Plugin
local Plugin = script.Parent.Parent.Parent

--// Fusion
local Fusion = require(Plugin.BoomBoxPackages.Fusion)
local Value = Fusion.Value
local Observer = Fusion.Observer

--// Maid
local Maid = require(Plugin.BoomBoxPackages.Maid)

--// Class
local Interface = {}
Interface.__index = Interface

--// Private Function
local function FlattenStates(states, prefix)
	local flatStates = {}
	for key, value in pairs(states) do
		-- Construct a new key using the prefix and the current key
		local newKey = key

		if typeof(value) == "table" and not getmetatable(value) then
			-- If the value is a table and not a Fusion Value object, recursively flatten it
			local nestedStates = FlattenStates(value, newKey)
			for nestedKey, nestedValue in pairs(nestedStates) do
				flatStates[nestedKey] = nestedValue
			end
		else
			-- If the value is not a table or is a Fusion Value object, add it directly
			flatStates[newKey] = value
		end
	end
	return flatStates
end

---
-- @description Constructs a new Interface object.
-- @return Interface - The newly created Interface instance.
--
function Interface.new()
	local Event = function()
		return Instance.new("BindableEvent")
	end

	local Function = function()
		return Instance.new("BindableFunction")
	end

	local info = {
		--// External
		Events = {
			General = {
				PlaySound = Event(),
				AddToQueue = Event(),
				ToggleSong = Event(),
				InstaQuery = Event(),
				QueueReorder = Event(),
				ClientTelemetry = Event(),
				LikeEvent = Event(),
				ResizeFrame = Event(),
			},
		},

		--// Internal

		--// States
		States = {

			Default = {
				DraggingEnabled = Value(false),
				DefaultPosition = Value(Vector2.new(1, 0.5)),
				DefaultAccentColor = Value(Color3.new(1, 1, 1)),
			},

			Root = {
				Page = Value("AudioPlayer"),
				DragCache = Value({}),
				Volume = Value(1),
				MaxVolume = Value(1),
				VolumePercent = Value(0.5),
				Fading = Value(false),
				PlayerListGui = Value(false),
				KeyboardDetected = Value(UserInputService.KeyboardEnabled),
				Viewport = Value(workspace.CurrentCamera.ViewportSize),

				Loaded = Value(false),

				QueueTab = Value("Queue"),
				SearchTab = Value("Library"),
				ScreenGui = Value(false),
			},

			Tracking = {
				InteractionTick = Value(0),
			},

			AudioPlayer = {
				Shuffling = Value(false),
				PlayingLiked = Value(false),
			},

			Search = {

				States = {
					Genres = Value({
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
					}),
					Emotions = Value({
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
					}),

					Sound = Value(false),
					AutoPlay = Value(false),
					SoundPlaying = Value(false),

					Length = Value(10),
					SoundInstance = Value(Instance.new("Sound")),

					Queue = Value({}),
					ShuffledQueue = Value({}),
					GeneratedQueue = Value({}),

					QueueIndex = Value(1),
					QueueMaxLength = Value(40),
					Favorites = Value({}),
					FavoritesDictionary = Value({}),

					Pill = Value("NaN"),
					PillQueries = Value({
						Happy = "Happy",
						Anger = "Anger",
						Sad = "Sad",
						Rad = "Rad",
						Orchestral = "Orchestral",
						Real = "Real",
						Magical = "Magical",
						Emotional = "Emotional",
					}),
					GenreBoxSelected = Value(false),

					Searching = Value(false),
					SearchQuery = Value(""),
					SearchBarText = Value(""),
					LikesSearchBarText = Value(""),

					LibraryResults = Value({}),
					FavoritesResults = Value({}),
				},

				Refs = {
					SearchBoxRef = Value(),
					PillsCanvasRef = Value(),
					LikesSearchBoxRef = Value(),
					SearchResultsCanvasRef = Value(),
					FavoritesResultsCanvasRef = Value(),
				},
			},

			Player = {
				PlayerHidden = Value(false),
				PlayerVisible = Value(true),
				PlayerSide = Value(-1),

				Refs = {
					PlayerRef = Value(),
				},
			},
		},

		--// State Subscriptions
		StateSubscriptions = {},

		--// CleanUp
		_maid = Maid.new(),
	}

	setmetatable(info, Interface):Init()

	return info
end

---
-- @description Removes Layers from self.Event
--
function Interface:CondensedSelf()
	local function RecursiveLoop(A, _Tbl)
		local Tbl = _Tbl or {}
		for i, v in pairs(A) do
			if typeof(v) == "table" and not v["_value"] then
				-- Removed 'return' to allow continuation of the loop
				RecursiveLoop(v, Tbl)
			else
				if Tbl[i] then
					warn(i .. " already exists!")
				end

				Tbl[i] = v
			end
		end
		return Tbl
	end

	self.Events = RecursiveLoop(self.Events, {})
	self.States = FlattenStates(self.States, "")
end

---
-- @description Adds Observers for the States in the Interface.
--
function Interface:InitializeSubscriptionArrays()
	for StateName: string, State in pairs(self.States) do
		local CurrentStateSubscriptionArray = self.StateSubscriptions[StateName]
		self.StateSubscriptions[StateName] = CurrentStateSubscriptionArray or {}
	end
end

---
-- @description Initializes the Interface.
--
function Interface:Init()
	self:CondensedSelf()
	self:InitializeSubscriptionArrays()
	self:ListenToStates()

	-- Players.LocalPlayer.CharacterAdded:Connect(function(Character)
	-- 	self:SetState("Character", Character)
	-- 	workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	-- end)

	-- task.spawn(function()
	-- 	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	-- 	self:SetState("Character", Character)
	-- end)
end

---
-- @description Adds Observers for the States in the Interface.
--
function Interface:ListenToStates()
	-- Adding Observers
	for StateName, State in pairs(self.States) do
		--// LocalStateSubscriptions
		local StateSubscriptions = self.StateSubscriptions[StateName]

		local observer = Observer(State)
		self._maid:GiveTask(observer:onChange(function()
			for _, Callback: () -> nil in pairs(StateSubscriptions) do
				task.spawn(Callback, State:get())
			end
		end))
	end
end

---
-- @description Fetches a desired BindableEvent from the Interface.
-- @param SignalName string - The name of the BindableEvent to fetch.
-- @return BindableEvent - The fetched BindableEvent.
--
function Interface:GetEvent(SignalName: string): BindableEvent
	local DesiredSignal: BindableEvent = self.Events[SignalName]
	assert(DesiredSignal, "Bindable Event `" .. SignalName .. "` does not exist")

	return DesiredSignal
end

---
-- @description Fetches a desired State from the Interface.
-- @param StateName string - The name of the State to fetch.
-- @return Fusion.Value<any> - The fetched State.
--

function Interface:GetState(StateName: string)
	local DesiredState = self.States[StateName]
	assert(DesiredState, "State `" .. StateName .. "` does not exist")

	return DesiredState
end

---
-- @description Fetches a desired State value from the Interface.
-- @param StateName string - The name of the State to fetch.
-- @return Fusion.Value<any> - The fetched State.
--
function Interface:Get(StateName: string)
	local DesiredState = self.States[StateName]
	assert(DesiredState, "State `" .. StateName .. "` does not exist")

	return DesiredState:get()
end

---
-- @description Sets a state value in the Interface.
-- @param StateName string - The name of the State to set.
-- @param Value any - The value to set the state to.
--
function Interface:SetState(StateName: string, _Value)
	local DesiredState = self:GetState(StateName)
	DesiredState:set(_Value)
end

---
-- @description Sets a state value in the Interface.
-- @param StateName string - The name of the State to set.
-- @param Value any - The value to set the state to.
--
function Interface:Set(StateName: string, _Value)
	local DesiredState = self:GetState(StateName)
	DesiredState:set(_Value)
end

---
-- @description Hooks an event listener to a desired State.
-- @param StateName string - The name of the State to hook.
-- @param callback function - The function to execute when the event is triggered.
--
function Interface:SubscribeToState(State: string, callback: () -> nil)
	local DesiredState = self:GetState(State)
	local StateSubscriptions = self.StateSubscriptions[State] or {}

	table.insert(StateSubscriptions, callback)
end

---
-- @description Hooks an event listener to a desired BindableEvent.
-- @param SignalName string - The name of the BindableEvent to hook.
-- @param callback function - The function to execute when the event is triggered.
--
function Interface:Subscribe(SignalName: string, callback: (...any) -> any)
	local DesiredSignal: BindableEvent | BindableFunction = self:GetEvent(SignalName)

	if DesiredSignal.ClassName == "BindableEvent" then
		-- For BindableEvent, connect the event to the callback
		self._maid:GiveTask(DesiredSignal.Event:Connect(callback))
	elseif DesiredSignal.ClassName == "BindableFunction" then
		-- For BindableFunction, set the OnInvoke to the callback
		DesiredSignal.OnInvoke = function(...)
			return callback(...)
		end
	else
		warn("Unsupported signal type for subscription: " .. DesiredSignal.ClassName)
	end
end

---
-- @description Fires a BindableEvent with the provided arguments.
-- @param SignalName string - The name of the BindableEvent to fire.
-- @param ... any - The arguments to pass when firing the event.
--
function Interface:Fire(SignalName: string, ...)
	local DesiredSignal: BindableEvent | BindableFunction = self:GetEvent(SignalName)
	local IsBindableFunction = DesiredSignal:IsA("BindableFunction")
	local Tuple = { ... }

	if not IsBindableFunction then
		DesiredSignal:Fire(...)
	else
		-- If it is a BindableFunction, invoke it and yield until it returns
		local result
		local success, err = pcall(function()
			result = DesiredSignal:Invoke(table.unpack({ Tuple }))
		end)

		if not success then
			warn("Error invoking BindableFunction '" .. SignalName .. "': " .. tostring(err))
			return false
		end

		return result
	end
end

---
-- @description Cleans up all tasks and listeners associated with the Interface.
--
function Interface:DoCleaning()
	self._maid:Cleanup()
end

return Interface.new()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXb3d8232d422a4cfeaf3733b9a057977b">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Pages</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXf4175523e5f34caf9eccb654ca8a8342">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioPlayer</string>
						<string name="ScriptGuid">{e90896fd-9470-471d-922f-6e2086bc7b3d}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Draggable = require(Util.Draggable)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local Playing = require(LocalComponents.Playing)
local TimeBar = require(LocalComponents.TimeBar)
local Buttons = require(LocalComponents.Buttons)
local AudioControls = require(LocalComponents.AudioControls)

local AudioScapeButton = require(LocalComponents.AudioscapeButton)
local AudioControlsVertical = require(LocalComponents.AudioControlsVertical)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type AudioPlayerProps = {}

return function(props: AudioPlayerProps)
	--// Value States
	local Active = Value(false)
	local Visible = Value(true)

	local PlayerRef = Handler_Interface:GetState("PlayerRef")

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local AudioPlayer = New("Frame")({
		[Ref] = PlayerRef,
		Name = "AudioPlayer",
		BackgroundColor3 = Color3.fromRGB(17, 17, 17),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		AnchorPoint = Computed(function()
			local DefaultPosition = Handler_Interface:Get("DefaultPosition") :: Vector2
			local Confined = Vector2.new(math.clamp(DefaultPosition.X, 0, 1), math.clamp(DefaultPosition.Y, 0, 1))

			return Confined
		end),
		Position = Computed(function()
			local DefaultPosition = Handler_Interface:Get("DefaultPosition") :: Vector2
			local Confined = Vector2.new(math.clamp(DefaultPosition.X, 0, 1), math.clamp(DefaultPosition.Y, 0, 1))

			return UDim2.fromScale(Confined.X, Confined.Y)
		end),
		Size = UDim2.new(0, 275, 0, 120),
		ClipsDescendants = false,

		[Children] = {
			New("Frame")({
				Name = "AudioPlayer",
				BackgroundColor3 = Color3.fromRGB(17, 17, 17),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				AnchorPoint = Vector2.new(1, 0.5),
				Position = UDim2.fromScale(1, 0.5),
				BackgroundTransparency = 0,
				Size = Tween(
					Computed(function()
						return Handler_Interface:Get("PlayerVisible") and UDim2.new(1, 0, 1, 0) or UDim2.new(0, 0, 1, 0)
					end),
					Tweens.Fast
				),

				[Children] = {
					Buttons({}),
					Playing({}),
					TimeBar({}),
					AudioControls({}),
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("UIPadding")({
						Name = "UIPadding",
						PaddingBottom = UDim.new(0, 5),
						PaddingLeft = UDim.new(0, 5),
						PaddingRight = UDim.new(0, 5),
						PaddingTop = UDim.new(0, 5),
					}),
				},
			}),

			New("ImageButton")({
				Name = "SideBar",
				BackgroundColor3 = Color3.fromRGB(17, 17, 17),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = Tween(
					Computed(function()
						local DesiredSize = Handler_Interface:Get("PlayerVisible") and UDim2.fromScale(0, 0.5)
							or UDim2.fromScale(1, 0.5)

						return DesiredSize
					end),
					Tweens.Fast
				),
				AnchorPoint = Tween(
					Computed(function()
						local DesiredSize = Handler_Interface:Get("PlayerVisible") and Vector2.new(1, 0.5)
							or Vector2.new(1, 0.5)

						return DesiredSize
					end),
					Tweens.Fast
				),
				Size = Tween(
					Computed(function()
						local DesiredSize = Handler_Interface:Get("PlayerVisible") and UDim2.new(0, 10, 0.9, 0)
							or UDim2.new(0, 30, 1, 0)

						-- Handler_Interface:Fire("ResizeFrame", DesiredSize)

						return DesiredSize
					end),
					Tweens.Fast
				),

				-- Visible = Computed(function()
				-- 	return Handler_Interface:Get("PlayerVisible")
				-- end),

				[Children] = {
					New("UIDragDetector")({
						BoundingUI = PlayerRef:get(),
					}),
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					Computed(function()
						local PlayerVisible = Handler_Interface:Get("PlayerVisible")
						if PlayerVisible then
							return New("ImageButton")({
								ZIndex = Computed(function()
									return PlayerVisible and 2 or -4
								end),
								Size = UDim2.fromScale(1, 1),
								BackgroundTransparency = 1,
								[OnEvent("MouseButton1Click")] = function()
									Handler_Interface:Set("PlayerVisible", false)
									Handler_Interface:Set("PlayerHidden", true)
								end,
								[Children] = {
									New("ImageLabel")({
										Size = UDim2.fromScale(0.8, 0.8),
										Position = UDim2.fromScale(0.5, 0.5),
										AnchorPoint = Vector2.new(0.5, 0.5),
										-- Rotation = 180,
										-- Rotation = 180,
										BackgroundTransparency = 1,
										-- Image = "rbxassetid://18925477687",
										Image = "rbxassetid://485495665",
										[Children] = {
											New("UIAspectRatioConstraint")({
												AspectRatio = 1,
											}),
										},
									}),
								},
							})
						end

						return {}
					end, function() end),

					-- AudioScapeButton({}),
					AudioControlsVertical({}),
				},
			}),
		},
	})

	return AudioPlayer
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX17796634919f4fbaa14338f47319491a">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Queue</string>
						<string name="ScriptGuid">{fad6562a-49e4-4eb6-a823-8cc7183e8c47}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Queue",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Queue

local Tabs = require(LocalComponents.Tabs)
local Favorites = require(LocalComponents.Favorites)
local SearchBar = require(LocalComponents.SearchBar)
local QueueHeader = require(LocalComponents.QueueHeader)
local QueueContainer = require(LocalComponents.QueueContainer)
local PillsContainer = require(LocalComponents.PillsContainer)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type QueueProps = {}

return function(props: QueueProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	local Queue = New("Frame")({
		Name = "Queue",
		BackgroundColor3 = Color3.fromRGB(17, 17, 17),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.692, -0.0013),
		Size = UDim2.fromScale(0.308, 1),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),
			Tabs({}),

			Computed(function()
				if Handler_Interface:Get("QueueTab") == "Queue" then
					return {
						QueueHeader({}),
						QueueContainer({}),
					}
				else
					return {
						SearchBar({}),
						Favorites({}),
						PillsContainer({}),
					}
				end
			end, function() end),
		},
	})

	return Queue
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX43d065f2bf654c56b3915d2d9af4fe45">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Root</string>
						<string name="ScriptGuid">{a1d47834-b018-45e0-8197-c392e3758734}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Screen = require(Util.Screen)
local Instween = require(Util.Instween)
local Viewport = require(Util.Viewport)
local Draggable = require(Util.Draggable)
local AudioPlayerSider = require(Util.AudioPlayerSider)

--// Types
local Types_Song = require(Interface.Types.Sound)

--// Packages
local Packages = script.Parent.Parent.Parent.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)

--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Hydrate = Fusion.Hydrate
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Root",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local PagesFolder = script.Parent
local Components = Interface.Components

local Queue = require(PagesFolder.Queue)
local Search = require(PagesFolder.Search)
local AudioPlayer = require(PagesFolder.AudioPlayer)

local Pages = {
	Queue = Queue(),
	Search = Search(),
	AudioPlayer = AudioPlayer(),
}

local BasePageInfo = {}
local DraggablePages = {
	AudioPlayer = true,
}

for PageName, Page: Frame in pairs(Pages) do
	BasePageInfo[PageName] = {
		Size = Page.Size,
		Position = Page.Position,
		AnchorPoint = Page.AnchorPoint,
		BackgroundTransparency = Page.BackgroundTransparency,
	}
end

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type RootProps = {}

return function(props: RootProps)
	--// Value States
	local Page = Value(Pages[Handler_Interface:Get("Page")])
	local PageName = Value(Handler_Interface:Get("Page"))
	local SpinnerRef = Value()

	local DragCache = {}

	local PlayerListEnabled = StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.PlayerList)
	Handler_Interface:Set("PlayerListGui", PlayerListEnabled)

	local FirstAssignment = true
	local LastOnScreenPosition = UDim2.fromScale(0.5, 0.5)

	Handler_Interface:SubscribeToState("PlayerListGui", function(Enabled: boolean)
		if Enabled then
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, PlayerListEnabled)
		else
			PlayerListEnabled = StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.PlayerList)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		end
	end)

	Viewport(function(ViewportSize: Vector2)
		Handler_Interface:Set("Viewport", ViewportSize)
	end)

	if RunService:IsRunning() then
		local Sound = Handler_Interface:Get("SoundInstance") :: Sound
		Sound.Parent = Players.LocalPlayer.PlayerGui

		local function Connections(CurrentSound: Sound)
			local ConnectionsCreated = {}

			ConnectionsCreated["Played"] = CurrentSound.Played:Connect(function()
				Handler_Interface:Set("SoundPlaying", true)
			end)

			ConnectionsCreated["Stopped"] = CurrentSound.Stopped:Connect(function()
				Handler_Interface:Set("SoundPlaying", false)
			end)

			ConnectionsCreated["Ended"] = CurrentSound.Ended:Connect(function()
				if CurrentSound == Handler_Interface:Get("SoundInstance") then
					Handler_Interface:Fire("ToggleSong", 1)
				end
			end)

			ConnectionsCreated["Destroying"] = CurrentSound.Destroying:Connect(function()
				for _, Connection in pairs(ConnectionsCreated) do
					Connection:Disconnect()
				end
			end)
		end

		Connections(Sound)

		Hydrate(Sound)({
			Volume = Computed(function()
				return Handler_Interface:Get("Volume")
			end),
		})

		--// Crossfading logic within the Sound state subscription
		Handler_Interface:SubscribeToState("Sound", function(Song: Types_Song.ReadableDictionary)
			Sound = Handler_Interface:Get("SoundInstance") :: Sound

			if not Song or not Song.asset_id then
				return
			end

			-- If there is a current sound and Song.Fade exists, perform crossfade
			if Sound.IsPlaying and Song.Fade and not Song.Faded then
				Song.Faded = true

				local FadeOutTween = Instween.new(
					Sound,
					{
						Volume = 0,
					},
					Song.Fade, -- Use the Fade value from the Song
					{
						EasingStyle = Enum.EasingStyle.Linear,
						EasingDirection = Enum.EasingDirection.Out,
					}
				)

				FadeOutTween.Completed:Once(function()
					Sound:Stop()
					Sound:Destroy()
				end)

				FadeOutTween:Play()
			else
				Sound:Stop()
				Sound:Destroy()
			end

			-- Create and configure the new sound
			local NewSound = Instance.new("Sound")
			NewSound.SoundId = "rbxassetid://" .. Song.asset_id
			NewSound.Volume = Song.Fade and 0 or Handler_Interface:Get("Volume") :: number -- Start at 0 for fade in, or full volume if no fade
			NewSound.Parent = Players.LocalPlayer.PlayerGui
			Connections(NewSound)
			Handler_Interface:Set("SoundInstance", NewSound)

			-- Load the new sound and handle playback
			if not NewSound.IsLoaded then
				NewSound.Loaded:Wait()
			end

			Handler_Interface:Set("Length", NewSound.TimeLength)

			if Handler_Interface:Get("AutoPlay") then
				NewSound:Play()
			end

			-- If Song.Fade exists, fade in the new sound
			if Song.Fade then
				local FadeInTween = Instween.new(
					NewSound,
					{
						Volume = Handler_Interface:Get("Volume") :: number,
					},
					Song.Fade, -- Use the Fade value from the Song
					{
						EasingStyle = Enum.EasingStyle.Linear,
						EasingDirection = Enum.EasingDirection.Out,
					}
				)

				FadeInTween.Completed:Once(function()
					FadeInTween:Destroy()
					Handler_Interface:Set("Fading", false)
				end)

				FadeInTween:Play()
				Handler_Interface:Set("Fading", true)
			end

			Song.Fade = nil
		end)

		Handler_Interface:SubscribeToState("Favorites", function(Favorites: { [string]: Types_Song.ReadableDictionary })
			local Song = Handler_Interface:Get("Sound") :: Types_Song.ReadableDictionary

			if not Song then
				return
			end

			Handler_Interface:Set("PlayingLiked", Favorites[tostring(Song.asset_id)] and true or false)
		end)
	end

	local Root = New("ImageButton")({
		Active = Computed(function()
			return Handler_Interface:Get("PlayerVisible")
		end),
		Size = Computed(function()
			local CurrentPageName = PageName:get() :: string
			local CurrentViewport = Handler_Interface:Get("Viewport") :: Vector2

			if CurrentPageName ~= "AudioPlayer" and CurrentViewport.X < CurrentViewport.Y then
				return UDim2.fromScale(0.5, 1)
			end

			return BasePageInfo[PageName:get()].Size
		end),
		Position = Computed(function()
			local DragCachePosition = DragCache[PageName:get()]
			local CurrentViewport = Handler_Interface:Get("Viewport") :: Vector2

			if DragCachePosition then
				return DragCachePosition
			end

			if FirstAssignment and PageName:get() == "AudioPlayer" then
				FirstAssignment = false
				return BasePageInfo[PageName:get()].Position
			end

			if PageName:get() ~= "AudioPlayer" and CurrentViewport.X < CurrentViewport.Y then
				return UDim2.fromScale(1, 0.5)
			end

			return BasePageInfo[PageName:get()].Position
		end),
		AnchorPoint = Computed(function()
			if PageName:get() == "AudioPlayer" then
				return BasePageInfo[PageName:get()].AnchorPoint
			else
				local CurrentViewport = Handler_Interface:Get("Viewport") :: Vector2

				if CurrentViewport.X < CurrentViewport.Y then
					return Vector2.new(1, 0.5)
				end
			end

			return Vector2.new(0, 0)
		end),
		BackgroundTransparency = 1,

		[Children] = {
			Computed(function()
				local PageElement = Page:get()
				PageElement.Position = UDim2.fromScale(0, 0)
				PageElement.Size = UDim2.fromScale(1, 1)

				if PageName:get() == "AudioPlayer" then
					PageElement.Position = UDim2.fromScale(0, 0)
					PageElement.AnchorPoint = Vector2.new(0, 0)
				end
				return PageElement
			end, function() end),
		},
	}) :: Frame

	--// Handling Dragging

	local Drag

	if Handler_Interface:Get("DraggingEnabled") then
		Drag = Draggable.new(Root, function(Position: UDim2)
			local ScreenSize = Screen()
			local CurrentPageName = PageName:get()

			DragCache[CurrentPageName] = Position

			local DesiredSize = Handler_Interface:Get("PlayerVisible") and 10 or 30

			if
				Root.AbsolutePosition.X - DesiredSize > 0
				and Root.AbsolutePosition.X + Root.AbsoluteSize.X < ScreenSize.width
				and Root.AbsolutePosition.Y > 0
				and Root.AbsolutePosition.Y + (Root.AbsoluteSize.Y * 1.5) < ScreenSize.height
			then
				LastOnScreenPosition = Position
			else
				Root.Position = LastOnScreenPosition
			end
		end)
		Drag:Enable()
	end

	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Page:set(Pages[NewPage])
		PageName:set(NewPage)

		if Handler_Interface:Get("DraggingEnabled") then
			if DraggablePages[NewPage] then
				Drag:Enable()
			else
				Drag:Disable()
			end
		end

		if NewPage == "Search" or NewPage == "Queue" then
			Handler_Interface:Set("PlayerListGui", false)
		else
			Handler_Interface:Set("PlayerListGui", true)
		end
	end)

	Handler_Interface:Subscribe("ResizeFrame", function(NewSize: UDim2)
		Root.Size = NewSize
	end)

	-- AudioPlayerSider(Root, Pages.AudioPlayer, PlayerAnchorPointCache)

	return Root
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4412553544324d33a502a2f8b47f9b3e">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Search</string>
						<string name="ScriptGuid">{3617334b-8b81-4955-bb2d-1357fad45866}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local Tabs = require(LocalComponents.Tabs)
local SearchBar = require(LocalComponents.SearchBar)
local GenreBoxes = require(LocalComponents.GenreBoxes)
local SearchResults = require(LocalComponents.SearchResults)
local PillsContainer = require(LocalComponents.PillsContainer)
local SearchingFrame = require(LocalComponents.SearchingFrame)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchProps = {}

return function(props: SearchProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	local Search = New("Frame")({
		Name = "Search",
		BackgroundColor3 = Color3.fromRGB(17, 17, 17),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.692, -0.0013),
		Size = UDim2.fromScale(0.308, 1),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			Tabs({}),
			SearchBar({}),
			GenreBoxes({}),
			SearchResults({}),
			PillsContainer({}),

			Computed(function()
				if Handler_Interface:Get("Searching") then
					return SearchingFrame({})
				end
			end, function(Child)
				return Child and Child or nil
			end),
		},
	})

	return Search
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX696311166d90444990bfa4c15b4df845">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Stories</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXd838bea86f9b4516a18d872418fb0c9d">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioPlayer.story</string>
						<string name="ScriptGuid">{6ebcce86-2835-496b-ac6d-04906b204e67}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:59:22 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Monday September 25th 2023 10:39:56 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ServerScriptService = game:GetService("ServerScriptService")

--// Pages
local Components = ServerScriptService.BoomBox.Interface.Components
local Pages = ServerScriptService.BoomBox.Interface.Pages

local RootFrame = require(Pages.AudioPlayer)({})

return function(target: Frame)
	RootFrame.Parent = target

	return function()
		RootFrame:Destroy()
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3addfd2b27d24d89a5c6dc8c5ac514d1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Queue.story</string>
						<string name="ScriptGuid">{95d530a2-aee6-472d-985f-f65ec879fe81}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:59:22 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Monday September 25th 2023 10:39:56 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ServerScriptService = game:GetService("ServerScriptService")

--// Pages
local Components = ServerScriptService.BoomBox.Interface.Components
local Pages = ServerScriptService.BoomBox.Interface.Pages

local RootFrame = require(Pages.Queue)({})

return function(target: Frame)
	RootFrame.Parent = target

	return function()
		RootFrame:Destroy()
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX671e74c230614e4881cc1c05ddb4af21">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Root.story</string>
						<string name="ScriptGuid">{b169f6c9-ae84-452d-916e-4f32644a7141}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:59:22 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Monday September 25th 2023 10:39:56 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ServerScriptService = game:GetService("ServerScriptService")

--// Pages
local Components = ServerScriptService.BoomBox.Interface.Components
local Pages = ServerScriptService.BoomBox.Interface.Pages

local RootFrame = require(Pages.Root)({})

return function(target: Frame)
	RootFrame.Parent = target

	return function()
		RootFrame:Destroy()
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3dcc3868fc0e4fe19d12d09788dcce2e">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Search.story</string>
						<string name="ScriptGuid">{e45184af-0709-4f97-bd6e-542355dc68ad}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:59:22 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Monday September 25th 2023 10:39:56 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ServerScriptService = game:GetService("ServerScriptService")

--// Pages
local Components = ServerScriptService.BoomBox.Interface.Components
local Pages = ServerScriptService.BoomBox.Interface.Pages

local RootFrame = require(Pages.Search)({})

return function(target: Frame)
	RootFrame.Parent = target

	return function()
		RootFrame:Destroy()
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX46f649eaa0c54fa7bdfae5d45218899c">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Types</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX4a74ca389bcb40178886faf38b3b934f">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Sound</string>
						<string name="ScriptGuid">{18a053d0-2502-4763-b1d8-f71be5a39d46}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Wednesday July 10th 2024 1:12:53 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Wednesday July 10th 2024 1:13:01 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
export type ReadableDictionary = {
	asset_ageGuidelines: string,
	asset_assetGenres: string,
	asset_assetSubTypes: string,
	asset_audioDetails_artist: string,
	asset_audioDetails_audioType: string,
	asset_audioDetails_musicAlbum: string,
	asset_audioDetails_musicGenre: string,
	asset_audioDetails_soundEffectCategory: string,
	asset_audioDetails_soundEffectSubcategory: string,
	asset_audioDetails_tags: string,
	asset_audioDetails_title: string,
	asset_createdUtc: string,
	asset_creatingUniverseId: string,
	asset_description: string,
	asset_description_feature_extraction_Album: string,
	asset_description_feature_extraction_AlbumInfo: string,
	asset_description_feature_extraction_BPM: string,
	asset_description_feature_extraction_CourtesyOf: string,
	asset_description_feature_extraction_Duration: string,
	asset_description_feature_extraction_Genre: string,
	asset_description_feature_extraction_Key: string,
	asset_description_feature_extraction_Library: string,
	asset_duration: string,
	asset_hasScripts: string,
	asset_id: string,
	asset_isAssetHashApproved: string,
	asset_isEndorsed: string,
	asset_name: string,
	asset_socialLinks: string,
	asset_typeId: string,
	asset_updatedUtc: string,
	asset_visibilityStatus: string,
	creator_id: string,
	creator_isVerifiedCreator: string,
	creator_latestGroupUpdaterUserId: string,
	creator_latestGroupUpdaterUserName: string,
	creator_name: string,
	creator_type: string,
	product_isForSaleOrIsPublicDomain: string,
	product_price: string,
	product_productId: string,
	voting_canVote: string,
	voting_downVotes: string,
	voting_hasVoted: string,
	voting_showVotes: string,
	voting_upVotePercent: string,
	voting_upVotes: string,
	voting_userVote: string,
	voting_voteCount: string,
}

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXd50b242a194147f6bcb07d2abf240c80">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Util</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXcc7d5b5908f746b1a0e28329302ad9af">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioPlayerSider</string>
						<string name="ScriptGuid">{ea2db188-ac54-43a7-9091-68aa40f52b7c}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)

--// Dependencies
local ScreenSize = require(script.Parent.Screen)()

return function(Root: Frame, Frame: Frame, PlayerAnchorPointCache)
	local PlayerRef = Handler_Interface:Get("PlayerRef") :: Frame

	if not PlayerRef then
		return
	end

	local PlayerSize = PlayerRef.AbsoluteSize
	local PlayerPosition = PlayerRef.AbsolutePosition

	if Handler_Interface:Get("PlayerSide") == 1 then
		if PlayerPosition.X + PlayerSize.X > ScreenSize.width then
			Handler_Interface:Set("PlayerSide", -1)
			Frame.Position = UDim2.fromScale(1, 0)
			Frame.AnchorPoint = Vector2.new(1, 0)
			Root.AnchorPoint = Vector2.new(1, 0)
			PlayerAnchorPointCache:set(Root.AnchorPoint)
		end
	else
		if PlayerPosition.X < 0 then
			Handler_Interface:Set("PlayerSide", 1)
			Frame.Position = UDim2.fromScale(0, 0)
			Frame.AnchorPoint = Vector2.new(0, 0)
			Root.AnchorPoint = Vector2.new(0, 0)
			PlayerAnchorPointCache:set(Root.AnchorPoint)
		end
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX79ebc9cd59b0447e83e08c3eea581e2a">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Camera</string>
						<string name="ScriptGuid">{2ff07e73-1bb7-4c22-a26f-a3d2ed87b37b}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Tuesday October 17th 2023 1:38:00 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Thursday April 4th 2024 1:04:39 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
-- Implementation of Camera.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Module
local Camera = {}

function Camera.getCameraOffset(fov, extentsSize)
	local halfSize = extentsSize.Magnitude / 2
	local fovDivisor = math.tan(math.rad(fov / 2))
	return halfSize / fovDivisor
end

function Camera.zoomToExtents(camera, instance)
	local isModel = instance:IsA("Model")

	local instanceCFrame = isModel and instance:GetModelCFrame() or instance.CFrame
	local extentsSize = isModel and instance:GetExtentsSize() or instance.Size

	local cameraOffset = Camera.getCameraOffset(camera.FieldOfView, extentsSize)
	local cameraRotation = camera.CFrame - camera.CFrame.p

	local instancePosition = instanceCFrame.p
	camera.CFrame = cameraRotation + instancePosition + (-cameraRotation.LookVector * cameraOffset)
	camera.Focus = cameraRotation + instancePosition
end

return Camera]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXb4c147ea85a742a28079b48962815e80">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Capitalize</string>
						<string name="ScriptGuid">{e33de9fc-7e99-4f5d-8902-718b226700e8}</string>
						<ProtectedString name="Source"><![CDATA[return function(str)
	local finalized = str:gsub("(%a)([%w_']*)", function(firstLetter, restOfWord)
		return firstLetter:upper() .. restOfWord:lower()
	end)

	return finalized
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4c3e71dfacd04d31bdb4dec63a2d42f1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Draggable</string>
						<string name="ScriptGuid">{0e72cfc3-1eff-4a01-bf9a-23d51d7e24d6}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	@Author: Spynaz
	@Description: Enables dragging on GuiObjects. Supports both mouse and touch.
	
	For instructions on how to use this module, go to this link:
	https://devforum.roblox.com/t/simple-module-for-creating-draggable-gui-elements/230678
--]]

local UDim2_new = UDim2.new

local UserInputService = game:GetService("UserInputService")

local DraggableObject = {}
DraggableObject.__index = DraggableObject

-- Sets up a new draggable object
function DraggableObject.new(Object, CallBack)
	local self = {}
	self.Object = Object
	self.DragStarted = nil
	self.DragEnded = nil
	self.Dragged = nil
	self.Dragging = false
	self.CallBack = CallBack

	setmetatable(self, DraggableObject)

	return self
end

-- Enables dragging
function DraggableObject:Enable()
	local object = self.Object
	local dragInput = nil
	local dragStart = nil
	local startPos = nil
	local preparingToDrag = false

	-- Updates the element
	local function update(input)
		local delta = input.Position - dragStart
		local newPosition =
			UDim2_new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		object.Position = newPosition

		self.CallBack(newPosition)

		return newPosition
	end

	self.InputBegan = object.InputBegan:Connect(function(input)
		if
			input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch
		then
			preparingToDrag = true
			--[[if self.DragStarted then
				self.DragStarted()
			end
			
			dragging	 	= true
			dragStart 		= input.Position
			startPos 		= Element.Position
			--]]

			local connection
			connection = input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End and (self.Dragging or preparingToDrag) then
					self.Dragging = false
					connection:Disconnect()

					if self.DragEnded and not preparingToDrag then
						self.DragEnded()
					end

					preparingToDrag = false
				end
			end)
		end
	end)

	self.InputChanged = object.InputChanged:Connect(function(input)
		if
			input.UserInputType == Enum.UserInputType.MouseMovement
			or input.UserInputType == Enum.UserInputType.Touch
		then
			dragInput = input
		end
	end)

	self.InputChanged2 = UserInputService.InputChanged:Connect(function(input)
		if object.Parent == nil then
			self:Disable()
			return
		end

		if preparingToDrag then
			preparingToDrag = false

			if self.DragStarted then
				self.DragStarted()
			end

			self.Dragging = true
			dragStart = input.Position
			startPos = object.Position
		end

		if input == dragInput and self.Dragging then
			local newPosition = update(input)

			if self.Dragged then
				self.Dragged(newPosition)
			end
		end
	end)
end

-- Disables dragging
function DraggableObject:Disable()
	self.InputBegan:Disconnect()
	self.InputChanged:Disconnect()
	self.InputChanged2:Disconnect()

	if self.Dragging then
		self.Dragging = false

		if self.DragEnded then
			self.DragEnded()
		end
	end
end

return DraggableObject]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXe005b297ce324ba89ee4bdad094be7a5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Genres</string>
						<string name="ScriptGuid">{310044a9-ba31-45dd-96db-4e732196d467}</string>
						<ProtectedString name="Source"><![CDATA[local Genres = {}

Genres.GenreConversions = {
	["rock"] = "Rock",
	["scores-orchestral"] = "Movie Music",
	["electronic"] = "EDM",
	["pop"] = "Pop",
	["atmosphere"] = "Ambient",
	["corporate"] = "Reality TV Music",
	["folk-contemporary"] = "Folk",
	["jazz"] = "Jazz",
	["ethnic-folk"] = "Folk-World",
	["hip-hop"] = "Hip-hop",
	["classical"] = "Classical",
	["children"] = "Kids",
	["kitsch-retro"] = "Kitch-Retro",
	["easy-listening"] = "Elevator Music",
	["world-beat"] = "World-Beat",
	["religious"] = "Religious",
	["funk-soul-r-b"] = "R&B",
	["latin"] = "Latin",
	["country"] = "Country",
	["ethnic-pop"] = "World-Pop",
	["blues"] = "Blues",
	["Phonk"] = "Phonk",
}

Genres.EmotionConversions = {
	["Dance"] = "Dance_music",
	["Exciting"] = "Exciting_music",
	["Angry"] = "Angry_music",
	["Chill"] = "Tender_music",
	["Happy"] = "Happy_music",
	["Scary"] = "Scary_music",
	["Sad"] = "Sad_music",
	["Laid Back"] = "New-age_music",
}
Genres.EmotionConversionsReversal = {
	["Dance_music"] = "Dance",
	["Exciting_music"] = "Exciting",
	["Angry_music"] = "Angry",
	["Tender_music"] = "Chill",
	["Happy_music"] = "Happy",
	["Scary_music"] = "Scary",
	["Sad_music"] = "Sad",
	["New-age_music"] = "Laid Back",
}

return Genres]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0921c57aa4a940478bfbc455d9ec6dfb">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Images</string>
						<string name="ScriptGuid">{82ff3107-98c1-44ea-b1bb-cc32a4b66110}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 11:27:41 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Tuesday December 19th 2023 1:11:52 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
return {
	Icons = {
		Skip = "rbxassetid://18881497118",
		Rewind = "rbxassetid://18881496575",
		Play = "rbxassetid://18881496807",
		Pause = "rbxassetid://18881496961",
		Loop = "rbxassetid://18494883282",

		Back = "rbxassetid://18619359944",
		Remove = "rbxassetid://120102783556633",
		-- Remove = "rbxassetid://18619360107",
		Emotes = "rbxassetid://18501541108",
		Shuffle = "rbxassetid://133420889460943",
		Likes = "rbxassetid://18501540967",
		LikeFill = "rbxassetid://18619231117",
		LikeOutline = "rbxassetid://18494997452",
		Library = "rbxassetid://18538854391",
		Playing = "rbxassetid://18501540591",
		Settings = "rbxassetid://18501540365",
		Queue = "rbxassetid://92846077417489",

		LikedImage = "rbxassetid://18952672240",
		UnlikedImage = "rbxassetid://18925349461",
		PlaylistAdd = "rbxassetid://18648211687",
	},
	Trading = {
		LeftPanel = "rbxassetid://14473079256",
		RightPanel = "rbxassetid://14473107622",
	},
}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXc23c370adbb44b9580e94003aab1197a">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Instween</string>
						<string name="ScriptGuid">{d803c1c9-f0c4-4bd3-a86c-4c7f042aec2c}</string>
						<ProtectedString name="Source"><![CDATA[--[[
Tween

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = Tween.TopLevel('foo')
    print(foobar.Thing)

DESCRIPTION

    A detailed description of the module.

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of Tween.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

--// module
local Tween = {}

function Tween.new(Object: Instance, Changes: table, Time: number, Settings: table)
	Settings = Settings or {}

	if Settings.Reversing then
		local test = if Settings.Reversing ~= nil then Settings.Reversing else false
	end

	local Info = TweenInfo.new(
		Time,
		Settings.EasingStyle or Enum.EasingStyle.Linear, -- EasingStyle
		Settings.EasingDirection or Enum.EasingDirection.Out, -- EasingDirection
		Settings.TimesRepeated or 0, -- Times repeteated
		if Settings.Reversing ~= nil then Settings.Reversing else false, -- Reversing
		Settings.Delay or 0 -- Time Delay
	)
	local Action = TweenService:Create(Object, Info, Changes)
	return Action
end

return Tween]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXa9e5ac03b62842f6962e6708d55fd9ff">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Luminance</string>
						<string name="ScriptGuid">{8b3fe4e0-12df-44fe-bc95-27cdaeae1dfc}</string>
						<ProtectedString name="Source"><![CDATA[return function(color, opacity)
	-- Default opacity to 1
	opacity = opacity or 1

	-- Extract the RGB components from the Color3 value
	local red = color.R
	local green = color.G
	local blue = color.B

	-- Adjust the RGB components based on opacity
	red = red * opacity + (1 - opacity)
	green = green * opacity + (1 - opacity)
	blue = blue * opacity + (1 - opacity)

	-- Calculate the luminance
	local luminance = 0.299 * red + 0.587 * green + 0.114 * blue

	-- If luminance is greater than 0.5, use black text; otherwise, use white text
	if luminance > 0.5 then
		return Color3.new(0, 0, 0) -- Black
	else
		return Color3.new(1, 1, 1) -- White
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX521b75d0867f4f05adf4acecfec9e858">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MatteColor</string>
						<string name="ScriptGuid">{7a1e24d6-49ba-4855-abc8-c82997ae5e88}</string>
						<ProtectedString name="Source"><![CDATA[-- Matte Color Generator
local function generateMatteColor()
	-- Generate random RGB values with low saturation for a matte effect
	local red = math.random(0.2 * 255, 0.7 * 255) / 255
	local green = math.random(0.2 * 255, 0.7 * 255) / 255
	local blue = math.random(0.2 * 255, 0.7 * 255) / 255

	-- Slightly reduce the brightness to make the color more muted
	local brightnessFactor = 0.8
	red = red * brightnessFactor
	green = green * brightnessFactor
	blue = blue * brightnessFactor

	-- Return the Color3 value
	return Color3.new(red, green, blue)
end

return generateMatteColor]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX6c5be9a2a0ea49ccb8dc93804f64c1b4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PastelColor</string>
						<string name="ScriptGuid">{e4e56697-29be-4695-ad7f-2153ccea0565}</string>
						<ProtectedString name="Source"><![CDATA[-- Pastel Color Generator
local function generatePastelColor()
	-- Base color (random values between 0 and 1)
	local baseRed = math.random()
	local baseGreen = math.random()
	local baseBlue = math.random()

	-- Mix with white to create pastel effect
	local pastelRed = (baseRed + 1) / 2
	local pastelGreen = (baseGreen + 1) / 2
	local pastelBlue = (baseBlue + 1) / 2

	-- Return Color3 value
	return Color3.new(pastelRed, pastelGreen, pastelBlue)
end

return generatePastelColor]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX91fc333bc0954c5d86650aba7305e1e6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlayerFromId</string>
						<string name="ScriptGuid">{cde0c9d2-6b28-47a9-9dee-383d7fea89dd}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday April 26th 2024 10:45:07 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday April 26th 2024 12:00:00 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
local Players = game:GetService("Players")

return function(Id: string)
	for i, p: Player in ipairs(Players:GetPlayers()) do
		if p.Name == Id then
			return p
		end
	end

	return false
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXb5a66b968cd443f7a2c6f12eb3d79e7e">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Screen</string>
						<string name="ScriptGuid">{4273382d-9c54-4e3c-bf53-8ffe3cfa3873}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Camera = workspace.CurrentCamera
	local ScreenSize = {}

	ScreenSize.width = Camera.ViewportSize.X
	ScreenSize.height = Camera.ViewportSize.Y

	return ScreenSize
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXe88889049b25489d902500f1b42f1427">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Search</string>
						<string name="ScriptGuid">{1f8ec467-6fac-4b68-8d8a-647f3c6903c0}</string>
						<ProtectedString name="Source"><![CDATA[local Module = {}

local Genere = require(script.Parent.Genres)
local TimeSorter = require(script.Parent.TimeSorter)

-- Function to split a string into lowercase words
function Module.splitStringToLower(str)
	local words = {}
	for word in str:gmatch("%w+") do
		table.insert(words, word:lower())
	end
	return words
end

-- Function to search songs based on query term
function Module.searchSongs(queryTerm, songs)
	local keywords = Module.splitStringToLower(queryTerm)
	local results = {}

	for _, song in songs do
		local description = (song.asset_description or ""):lower()
		local genre = (song.asset_audioDetails_musicGenre or ""):lower()
		local tags = (song.asset_audioDetails_musicGenre or ""):lower()
		local name = song.asset_audioDetails_title:lower()
		local match = false

		for _, keyword in keywords do
			if genre:find(keyword) or description:find(keyword) or name:find(keyword) then
				match = true
				break
			end
		end

		if match then
			table.insert(results, song)
		end
	end

	return TimeSorter(results)
end

function Module.searchFromTag(queryTerm, songs)
	local results = {}

	for _, song in songs do
		if not song.asset_audioDetails_tags then
			continue
		end
		local tags = song.asset_audioDetails_tags:split(",")
		local reversalTerm = Genere.EmotionConversions[queryTerm]
		local match = false

		if not reversalTerm then
			continue
		end

		if table.find(tags, reversalTerm) then
			table.insert(results, song)
		end
	end

	return TimeSorter(results)
end

function Module.getPillsFromTags(songs)
	local results = {}
	local ResultsDictionary = {}

	for _, song in songs do
		local match = false

		if not song.asset_audioDetails_tags then
			continue
		end

		local tags = song.asset_audioDetails_tags:split(",")

		for Tag, TagReversal in Genere.EmotionConversionsReversal do
			local Found = table.find(tags, Tag)
			if Found and not ResultsDictionary[TagReversal] then
				ResultsDictionary[TagReversal] = true

				table.insert(results, TagReversal)

				match = true
				break
			end
		end
	end

	return results
end

return Module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX697386d30d3d4f21a568bf193b2a8805">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Sounds</string>
						<string name="ScriptGuid">{fd9cf10e-ecf9-490a-8036-dad7c4881649}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:51:40 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Saturday March 16th 2024 8:15:47 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--[[
Sounds

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = Sounds.TopLevel('foo')
   

DESCRIPTION

    A detailed description of the module.

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of Sounds.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Packages
local Maid = require(ReplicatedStorage.BoomBoxPackages.Maid)

--// Class
local Sounds = {}
Sounds.__index = Sounds

function Sounds.new()
	local SoundDictionary = {
		Click = "rbxassetid://12313312",
		_maid = Maid.new(),
	}
	setmetatable(SoundDictionary, Sounds)
	return SoundDictionary
end

function Sounds:Play(SoundName: string)
	if true then
		return
	end
	local targetSound = self[SoundName]

	if not targetSound then
		return warn(SoundName .. " does not exist.")
	end

	local SoundEndedConnection
	local Sound = Instance.new("Sound")
	Sound.SoundId = targetSound

	Sound:Play()

	SoundEndedConnection = Sound.Ended:Connect(function()
		Sound:Destroy()
		SoundEndedConnection:Disconnect()
	end)
end

function Sounds:Disconnect()
	for _, c: RBXScriptConnection in pairs(self.Connections) do
		c:Disconnect()
	end
end

function Sounds:Destroy()
	self:Disconnect()

	setmetatable(self, nil)
	table.clear(self)
	table.freeze(self)
end

return Sounds]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7067c840467d47f5afbce249d8acbf0d">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TimeSorter</string>
						<string name="ScriptGuid">{7610d942-7314-4f15-acde-6251b48b7ba8}</string>
						<ProtectedString name="Source"><![CDATA[-- liked_at_sorter.lua

local liked_at_sorter = {}

-- Function to convert ISO 8601 liked_at to a comparable format
local function parse_liked_at(ts)
	local pattern = "(%d+)-(%d+)-(%d+)T(%d+):(%d+):(%d+).(%d+)Z"
	local year, month, day, hour, min, sec, msec = ts:match(pattern)
	return os.time({ year = year, month = month, day = day, hour = hour, min = min, sec = sec }) + (msec / 1000)
end

-- Function to sort a dictionary of dictionaries by liked_ats and return a sorted array
function liked_at_sorter.sort_by_liked_at(data)
	-- Extract keys and sort them based on liked_ats
	local keys = {}
	for k in pairs(data) do
		table.insert(keys, k)
	end

	table.sort(keys, function(a, b)
		return parse_liked_at(data[a].liked_at) > parse_liked_at(data[b].liked_at)
	end)

	-- Create a sorted array
	local sorted_array = {}
	for _, k in ipairs(keys) do
		table.insert(sorted_array, data[k])
	end

	return sorted_array
end

return liked_at_sorter.sort_by_liked_at]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXd9ab3442b35346fea0dd815056ae1aef">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Tweens</string>
						<string name="ScriptGuid">{51d4b73d-9002-4b57-810d-19bacdbb29f1}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:36:56 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Thursday July 4th 2024 8:37:18 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]

local Settings = {
	DefaultTransitionTime = 0.75,
	DefaultContentDelay = 0.3,
}

local Tweens = {

	DefaultTransitionTime = Settings.DefaultTransitionTime,
	DefaultContentDelay = Settings.DefaultContentDelay,
	Default = TweenInfo.new(
		Settings.DefaultTransitionTime,
		Enum.EasingStyle.Sine,
		Enum.EasingDirection.InOut,
		0,
		false,
		0
	),
	Toon = TweenInfo.new(
		Settings.DefaultTransitionTime,
		Enum.EasingStyle.Back,
		Enum.EasingDirection.InOut,
		0,
		false,
		0
	),
}

Tweens.Fast =
	TweenInfo.new(Settings.DefaultTransitionTime / 5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, 0)

Tweens.ToonMedium =
	TweenInfo.new(Settings.DefaultTransitionTime / 2.5, Enum.EasingStyle.Back, Enum.EasingDirection.InOut, 0, false, 0)

Tweens.ToonFast =
	TweenInfo.new(Settings.DefaultTransitionTime / 5, Enum.EasingStyle.Back, Enum.EasingDirection.InOut, 0, false, 0)

Tweens.RadialMenuTransitionTime = Settings.DefaultTransitionTime / 1.5

function Tweens.modifyTween(
	_BaseStyle: string,
	Changes: {
		Time: number?,
		EasingStyle: Enum.EasingStyle?,
		EasingDirection: Enum.EasingDirection?,
		RepeatCount: number?,
		Reverses: boolean?,
		DelayTime: number?,
	},
	SaveName: string?
)
	local BaseStyle = Tweens[_BaseStyle]

	local NewTween = TweenInfo.new(
		Changes.Time or BaseStyle.Time,
		Changes.EasingStyle or BaseStyle.EasingStyle,
		Changes.EasingDirection or BaseStyle.EasingDirection,
		Changes.RepeatCount or BaseStyle.RepeatCount,
		Changes.Reverses or BaseStyle.Reverses,
		Changes.DelayTime or BaseStyle.DelayTime
	)

	if SaveName then
		Tweens[SaveName] = NewTween
	end

	return NewTween
end

Tweens.WindowTime = Tweens.Toon.Time / 2.5

local TweenService = game:GetService("TweenService")

function Tweens.new(Object: Instance, Changes: table, Time: number, Settings: table)
	Settings = Settings or {}

	if Settings.Reversing then
		local test = if Settings.Reversing ~= nil then Settings.Reversing else false
	end

	local Info = TweenInfo.new(
		Time,
		Settings.EasingStyle or Enum.EasingStyle.Linear, -- EasingStyle
		Settings.EasingDirection or Enum.EasingDirection.Out, -- EasingDirection
		Settings.TimesRepeated or 0, -- Times repeteated
		if Settings.Reversing ~= nil then Settings.Reversing else false, -- Reversing
		Settings.Delay or 0 -- Time Delay
	)
	local Action = TweenService:Create(Object, Info, Changes)
	return Action
end

return Tweens]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXbc4b0d28ea8944c19acf659cda538dbc">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">UICorner</string>
						<string name="ScriptGuid">{f28aac0a-b9a9-4cfa-b4e0-ed19d864753f}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Monday September 18th 2023 1:09:04 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Saturday March 16th 2024 8:15:47 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--[[
UICorner

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = UICorner.TopLevel('foo')
   

DESCRIPTION

    A module for creating relatively scaled ui strokes

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of UICorner.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Private Functions
local function GetAverage(vector: Vector2): number
	return (vector.X + vector.Y) / 2
end

--// Variables
local STUDIO_SCREEN_SIZE = Vector2.new(1366, 767) -- change 0, 0 to your studio resolution
local camera: Camera = workspace.Camera

local studioAverage = GetAverage(STUDIO_SCREEN_SIZE)
local currentScreenAverage = GetAverage(camera.ViewportSize)

--// Variable-reliant Private Functions
local function AdjustCornerRadius(OriginalCornerRadius: number)
	local ratio = OriginalCornerRadius / studioAverage
	return currentScreenAverage * ratio
end

local function ModifyUICorners(args: any)
	currentScreenAverage = GetAverage(camera.ViewportSize) -- re-calculate the screen average as it could've changed
	return AdjustCornerRadius(args)
end

--// Module
local UICorner = function(_CornerRadius: number)
	local ratio = (_CornerRadius or 1) / studioAverage
	local CornerRadius = currentScreenAverage * ratio

	return CornerRadius
end

return UICorner]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9a2b3a9401e847bfac77a79f51dc7365">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">UIStroke</string>
						<string name="ScriptGuid">{fd584add-e2f3-4e69-9d3b-cb4ba3581375}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Monday September 18th 2023 1:09:04 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Saturday March 16th 2024 8:15:47 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--[[
UIStroke

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = UIStroke.TopLevel('foo')
   

DESCRIPTION

    A module for creating relatively scaled ui strokes

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of UIStroke.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Private Functions
local function GetAverage(vector: Vector2): number
	return (vector.X + vector.Y) / 2
end

--// Variables
local STUDIO_SCREEN_SIZE = Vector2.new(1366, 767) -- change 0, 0 to your studio resolution
local camera: Camera = workspace.Camera

local studioAverage = GetAverage(STUDIO_SCREEN_SIZE)
local currentScreenAverage = GetAverage(camera.ViewportSize)

--// Variable-reliant Private Functions
local function AdjustThickness(OriginalThickness: number)
	local ratio = OriginalThickness / studioAverage
	return currentScreenAverage * ratio
end

local function ModifyUiStrokes(args: any)
	currentScreenAverage = GetAverage(camera.ViewportSize) -- re-calculate the screen average as it could've changed
	return AdjustThickness(args)
end

--// Module
local UIStroke = function(_Thickness: number)
	local ratio = (_Thickness or 1) / studioAverage
	local Thickness = currentScreenAverage * ratio

	return Thickness
end

return UIStroke]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX80f472f8c3ac4032bd9a204cd7a44c4a">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Viewport</string>
						<string name="ScriptGuid">{4bcf6fec-32c0-4673-8dde-b3625b853835}</string>
						<ProtectedString name="Source"><![CDATA[local CurrentCamera = workspace.CurrentCamera
local Module = {
	Subscriptions = {},
}

CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	for i, v in pairs(Module.Subscriptions) do
		v(CurrentCamera.ViewportSize)
	end
end)

return function(cb: () -> nil)
	table.insert(Module.Subscriptions, cb)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>