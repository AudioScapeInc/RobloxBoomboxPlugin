<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBX64e49451ad6347979094f77461e76dda">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">AudioscapeBoomBox</string>
			<string name="ScriptGuid">{6421bf0a-184c-40df-868e-894b2cfd5a57}</string>
			<ProtectedString name="Source"><![CDATA[--// Services
local HttpService = game:GetService("HttpService") -- Service for HTTP requests and JSON encoding/decoding
local Players = game:GetService("Players") -- Service for player management
local ReplicatedStorage = game:GetService("ReplicatedStorage") -- Storage for objects that need to be accessible by both client and server
local RunService = game:GetService("RunService") -- Service to handle game loop and execution of code based on environment
local AssetService = game:GetService("AssetService") -- Service to retrieve asset metadata, particularly audio assets

-- Exit if running on the client side
if RunService:IsClient() then
	return {}
end

--// Types
-- Type definition for Roblox audio metadata
type RobloxAudioMetadata = {
	Artist: string, -- The artist of the audio track
	AssetId: string, -- The unique ID of the audio asset
	AudioType: string, -- Type of the audio (e.g., music, sound effect)
	Duration: number, -- Duration of the audio in seconds
	Title: string, -- Title of the audio track
}

--// Events
local Events = require(script.Server.Events) -- Module to handle server events

--// Boombox Class
local BoomBox = {}
BoomBox.__index = BoomBox

-- Constructor for the BoomBox class
function BoomBox.new()
	local self = setmetatable({}, BoomBox)
	return self
end

-- Function to restructure the Roblox audio metadata into a format expected by the boombox system
-- @param Songs: Table of RobloxAudioMetadata - List of audio metadata to restructure
-- @param Fade: Number or nil - Fade duration to be applied to the first song
-- @return: JSON encoded string of the restructured song metadata
function BoomBox:RestructureFromRobloxMetaData(Songs: { RobloxAudioMetadata }, Fade)
	local RestructuredSongMetaData = {}

	for _, Song in ipairs(Songs) do
		table.insert(RestructuredSongMetaData, {
			asset_id = Song.AssetId, -- Asset ID of the song
			asset_name = Song.Title, -- Title of the song
			asset_audio_details_music_album = Song.Artist, -- Artist of the song
			asset_audio_details_music_genre = "Unknown", -- Music genre, set to unknown as a default

			Fade = _ == 1 and Fade or nil, -- Apply fade to the first song only
		})
	end

	return HttpService:JSONEncode(RestructuredSongMetaData) -- Convert the table to JSON
end

-- Function to push songs to the boombox queue for players
-- @param Info: Table containing details about the songs to be queued and player information
function BoomBox:PushToQueue(
	Info: {
		Players: { Player }?, -- Optional list of players to push the queue to
		AssetIDs: { number }, -- List of asset IDs of the songs to queue
		PlayNow: boolean, -- Whether to play the songs immediately
		ClearQueue: boolean, -- Whether to clear the existing queue
		Fade: number?, -- Optional fade duration for the first song
	}
)
	local AssetIds = Info.AssetIDs

	if type(AssetIds) == "number" then
		AssetIds = { AssetIds } -- Convert single asset ID to a table
	end

	-- Restructure the audio metadata for use in the boombox system
	local RobloxAudioMetadata =
		self:RestructureFromRobloxMetaData(AssetService:GetAudioMetadataAsync(AssetIds), Info.Fade)
	local AudioScapeAudioMetadata

	-- Spawn a task to get additional audio metadata
	task.spawn(function()
		AudioScapeAudioMetadata = Events.ServerAudioscape:Invoke(nil, "details", AssetIds)
	end)

	-- For each player, create a RemoteFunction to fill metadata and invoke client functions
	for _, Player in Info.Players or Players:GetPlayers() do
		task.spawn(function()
			local RequestMetadataFill = Instance.new("RemoteFunction")
			RequestMetadataFill.Name = "BoomboxPothole" .. HttpService:GenerateGUID()
			RequestMetadataFill.Parent = ReplicatedStorage
			RequestMetadataFill.OnServerInvoke = function()
				repeat
					task.wait()
				until AudioScapeAudioMetadata -- Wait until additional metadata is available

				task.delay(1, function()
					RequestMetadataFill:Destroy() -- Destroy the RemoteFunction after use
				end)

				return AudioScapeAudioMetadata -- Return the metadata to the client
			end
			local s, e = pcall(function()
				local Test =
					Events.HeadlessFunctions:InvokeClient(Player, RobloxAudioMetadata, RequestMetadataFill, Info)
			end)
		end)
	end
end

-- Function to adjust the volume for specific players or all players
-- @param Info: Table containing player information and the volume level
function BoomBox:AdjustVolume(
	Info: {
		Players: { Player }?, -- Optional list of players to adjust the volume for
		Volume: number, -- The volume level to set
	}
)
	assert(Info.Volume, "Volume is required") -- Ensure the volume is provided

	if Info.Players then
		for _, Player in Info.Players do
			Events.HeadlessEvents:FireClient(Player, "AdjustVolume", Info) -- Adjust volume for specific players
		end
	else
		Events.HeadlessEvents:FireAllClients("AdjustVolume", Info) -- Adjust volume for all players
	end
end

-- Function to adjust the maximum volume for specific players or all players
-- @param Info: Table containing player information and the maximum volume level
function BoomBox:AdjustMaxVolume(
	Info: {
		Players: { Player }?, -- Optional list of players to adjust the max volume for
		MaxVolume: number, -- The maximum volume level to set
	}
)
	assert(Info.MaxVolume, "MaxVolume is required") -- Ensure the maximum volume is provided

	if Info.Players then
		for _, Player in Info.Players do
			Events.HeadlessEvents:FireClient(Player, "AdjustMaxVolume", Info) -- Adjust max volume for specific players
		end
	else
		Events.HeadlessEvents:FireAllClients("AdjustMaxVolume", Info) -- Adjust max volume for all players
	end
end

-- Function to play the boombox for specific players or all players
-- @param Info: Table containing player information
function BoomBox:Play(
	Info: {
		Players: { Player }?, -- Optional list of players to play the boombox for
	}
)
	Info = Info or {}

	if Info.Players then
		for _, Player in Info.Players do
			Events.HeadlessEvents:FireClient(Player, "PlayBoombox", Info) -- Play boombox for specific players
		end
	else
		Events.HeadlessEvents:FireAllClients("PlayBoombox", Info) -- Play boombox for all players
	end
end

-- Function to pause the boombox for specific players or all players
-- @param Info: Table containing player information
function BoomBox:Pause(
	Info: {
		Players: { Player }?, -- Optional list of players to pause the boombox for
	}
)
	Info = Info or {}

	if Info.Players then
		for _, Player in Info.Players do
			Events.HeadlessEvents:FireClient(Player, "PauseBoombox", Info) -- Pause boombox for specific players
		end
	else
		Events.HeadlessEvents:FireAllClients("PauseBoombox", Info) -- Pause boombox for all players
	end
end

-- Return a new instance of the BoomBox class
return BoomBox.new()]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Configuration" referent="RBX60c6a388aa47456ba08b1686e905f8cb">
			<Properties>
				<BinaryString name="AttributesSerialize"><![CDATA[BwAAAAgAAABBdXRvcGxheQMBEgAAAERlZmF1bHRBY2NlbnRDb2xvcg8AAIA/AACAPwAAgD8P
AAAARGVmYXVsdFBvc2l0aW9uEAAAgD8AAAA/DwAAAERyYWdnaW5nRW5hYmxlZAMACQAAAE1h
eFZvbHVtZQYAAAAAAADwPwkAAABNaW5pbWl6ZWQDAA0AAABTZWFyY2hFbmFibGVkAwE=]]></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">AttributeConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX6676d6e4c0eb4ae79483387a39eb34da">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Client</string>
				<string name="ScriptGuid">{1b6a1988-ea04-4b93-a643-e8ac686ba9de}</string>
				<ProtectedString name="Source"><![CDATA[-- Implementation of BoomBoxClient.

--// Services
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

--// Modules
local BeatSync = require(script.Modules.BeatSync)
local Scheduler = require(script.Modules.Scheduler)

--// Default Genres
local GenreBoxText = {
	["Trap"] = "Trap",
	["Ambient Background"] = "Ambient Background",
	["Chiptune"] = "Chiptune",
	["Phonk"] = "Phonk",
	["Dubstep"] = "Dubstep",
	["EDM"] = "EDM",
	["Lo-fi"] = "Lo-fi",
	["Movie Music"] = "Movie Music",
	["Hip-hop"] = "Hip-hop",
	["Pop"] = "Pop",
	["Rock"] = "Rock",
	["Kitsch-Retro"] = "Kitsch-Retro",
	["Classical"] = "Classical",
	["Reality TV Music"] = "Reality TV Music",
	["Latin"] = "Latin",
	["Folk"] = "Folk",
	["Folk-World"] = "Folk-World",
	["Elevator Music"] = "Elevator Music",
	["World-Beat"] = "World-Beat",
	["R&B"] = "R&B",
	["Country"] = "Country",
	["World-Pop"] = "World-Pop",
	["Jazz"] = "Jazz",
	["Religious"] = "Religious",
	["Blues"] = "Blues",
	["Kids"] = "Kids",
}

--// Class
local BoomBoxClient = {}
BoomBoxClient.__index = BoomBoxClient

function BoomBoxClient.new()
	local info = {
		Connections = {},
		BeatSync = BeatSync,
		Scheduler = Scheduler.new(),
		LoadEvent = Instance.new("BindableEvent"),

		Events = {},
		ExcludedGenres = {},
		ExcludedStations = {},

		SongSubscriptions = {},

		Loaded = false,
	}
	setmetatable(info, BoomBoxClient):Init()
	return info
end

function BoomBoxClient:Init()
	self:AddToBeatSync(function(Sound, BeatInterval, Args) end)
	self:SyncSoundToBeat()

	task.defer(function()
		repeat
			task.wait()
		until Handlers_Interface:Get("Loaded")

		self.Loaded = true
	end)

	task.defer(function()
		local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
		local Events = {
			CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
			Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
			Audioscape = Remotes:WaitForChild("Audioscape") :: RemoteFunction,
		}

		self.Events = Events
	end)

	task.defer(function()
		self.Events.Audioscape:InvokeServer("telemetry", {
			["event_type"] = "player_joining",
		})
	end)
end

function BoomBoxClient:WaitForLoad()
	repeat
		task.wait()
	until #Handlers_Interface:Get("Genres") > 0

	--print("Loaded", self.Loaded)
end

function BoomBoxClient:ListenToSong(callback: (Sound) -> nil)
	Handlers_Interface:SubscribeToState("Sound", callback)
end

function BoomBoxClient:ListenToPlayToggle(callback: (Sound) -> nil)
	Handlers_Interface:SubscribeToState("SoundPlaying", callback)
end

function BoomBoxClient:ListenToShuffle(callback: (Shuffle: boolean) -> nil)
	Handlers_Interface:SubscribeToState("Shuffling", callback)
end

function BoomBoxClient:SyncSoundToBeat()
	Handlers_Interface:SubscribeToState("Sound", function(Sound)
		if not Sound then
			return
		end

		local BPM = Sound["asset_bpm"] :: number | nil

		-- print(Sound)

		-- if not BPM then
		-- 	warn("No BPM found for " .. Sound.asset_name)
		-- 	return
		-- else
		-- 	warn("BPM found for " .. Sound.asset_name .. ": " .. BPM)
		-- end

		local AudioPlayer = Handlers_Interface:Get("AudioPlayer") :: Sound

		BeatSync.Play(AudioPlayer, BPM, 0)

		-- local AudioPlayer = Handlers_Interface:Get("AudioPlayer") :: Sound

		-- BeatSync.Play(AudioPlayer, 1)
	end)
end

function BoomBoxClient:AddToBeatSync(Cycle: (
	Sound: boolean | Sound,
	BeatInterval: number,
	Args: {
		BeatCounter: number,
		SixteenthNoteCounter: number,
		CurrentBar: number,
		CurrentBeat: number,
		TotalBars: number,
	}
) -> nil)
	table.insert(BeatSync.Cycles, Cycle)
end

function BoomBoxClient:Scheduler()
	BeatSync.SongChanged:Connect(function()
		--// Going to Use this when I get back
		self.Scheduler = Scheduler.new()
	end)
end

function BoomBoxClient:SyncToBeat(Callback: (Beat: number, BeatDuration: number) -> nil)
	self.Scheduler.Connections[HttpService:GenerateGUID(false)] = BeatSync.BeatChanged.Event:Connect(Callback)
end

function BoomBoxClient:SyncToSixteenthNote(Callback: (SixteenthNote: number, NoteDuration: number) -> nil)
	self.Scheduler.Connections[HttpService:GenerateGUID(false)] = BeatSync.SixteenthNoteChanged.Event:Connect(Callback)
end

function BoomBoxClient:SyncToDownBeat(Callback: (Beat: number) -> nil)
	-- self.Scheduler.Connections[HttpService:GenerateGUID(false)] = BeatSync.DownBeatChanged:Connect(Callback)
end

function BoomBoxClient:ExcludeStation(Station: string) end

function BoomBoxClient:GetGenres()
	self:WaitForLoad()

	local Genres = {}
	for _, Genre in Handlers_Interface:Get("Genres") :: { string } do
		if GenreBoxText[Genre] then
			table.insert(Genres, GenreBoxText[Genre])
		end
	end
	return Genres
end

function BoomBoxClient:GetStations()
	self:WaitForLoad()

	local Stations = {}

	for _, Station in Handlers_Interface:Get("Genres") :: { string } do
		if not GenreBoxText[Station] then
			table.insert(Stations, Station)
		end
	end
	return Stations
end

function BoomBoxClient:PlayGenre(Genre: string, failCallback: () -> nil)
	Handlers_Interface:Set("AutoPlay", true)
	if table.find(self.ExcludedGenres, Genre) then
		task.defer(failCallback)
		return
	end

	Handlers_Interface:Fire("ClientAudioscape", "search", {
		genre = Genre,
	}, true)
end

function BoomBoxClient:PlayStation(Station: string, failCallback: () -> nil)
	Handlers_Interface:Set("AutoPlay", true)

	if table.find(self.ExcludedStations, Station) then
		task.defer(failCallback)
		return
	end

	Handlers_Interface:Fire("ClientAudioscape", "search", {
		genre = Station,
	}, true)

	task.defer(function()
		self.Events.Audioscape:InvokeServer("telemetry", {
			["station_name"] = Station,
			["event_type"] = "play_station",
		})
	end)
end

function BoomBoxClient:GetShuffle()
	return Handlers_Interface:Get("Shuffling")
end

function BoomBoxClient:GetPlaying()
	return Handlers_Interface:Get("SoundPlaying")
end

function BoomBoxClient:TogglePlay()
	Handlers_Interface:Fire("ToggleSong", 0)
end

function BoomBoxClient:ToggleShuffle()
	Handlers_Interface:Set("Shuffling", not Handlers_Interface:Get("Shuffling"))
end

function BoomBoxClient:Skip()
	Handlers_Interface:Fire("ToggleSong", 1)
end

function BoomBoxClient:Rewind()
	Handlers_Interface:Fire("ToggleSong", -1)
end

--// Gets Clamped to the MaxVolume state automatically
function BoomBoxClient:Volume(number: number)
	Handlers_Interface:Set("Volume", math.clamp(number, 0, Handlers_Interface:Get("MaxVolume")))
end

function BoomBoxClient:MaxVolume(number: number)
	Handlers_Interface:Set("MaxVolume", number)
end

function BoomBoxClient:SetExcludedStations(ExcludedStations: { string })
	self.ExcludedStations = ExcludedStations
end

function BoomBoxClient:SetExcludedGenres(ExcludedGenres: { string })
	self.ExcludedGenres = ExcludedGenres
end

function BoomBoxClient:SetPlayerVisible(PlayerVisible: boolean)
	Handlers_Interface:Set("DisableAppearance", not PlayerVisible)
end

return BoomBoxClient.new()]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="AudioListener" referent="RBXe1cb8e8499ff4a5e937ff1ba8282f1c5">
				<Properties>
					<BinaryString name="AngleAttenuation">AA==</BinaryString>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="AudioInteractionGroup"></string>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<BinaryString name="DistanceAttenuation">AA==</BinaryString>
					<string name="Name">AudioListener</string>
					<token name="SimulationFidelity">1</token>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="AudioDeviceOutput" referent="RBX599588cf1d5c42e588e980f102ff25b2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">AudioDeviceOutput</string>
						<Ref name="Player">null</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Wire" referent="RBXc2a0da2f034e4cf2a11661ea2db0a9bf">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Wire</string>
							<int64 name="SourceAssetId">-1</int64>
							<Ref name="SourceInstance">RBXe1cb8e8499ff4a5e937ff1ba8282f1c5</Ref>
							<string name="SourceName">Output</string>
							<BinaryString name="Tags"></BinaryString>
							<Ref name="TargetInstance">RBX599588cf1d5c42e588e980f102ff25b2</Ref>
							<string name="TargetName">Input</string>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX4fb84595ed454cb2a7e74f4e04acdb44">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Debug</string>
					<string name="ScriptGuid">{69fcd400-9c76-42da-ab7f-90298dd34b6b}</string>
					<ProtectedString name="Source"><![CDATA[return {
	LoadingDebug = false,
	HeadlessRemotesDebug = false,
	GlobalDatabaseUpdateInterval = 60 * 5,
	GlobalDatabaseGenereUpdateDebug = false,
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBXc44c406dd2cd4a65b31ca0b28d6f80d0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Initialize</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{cee4d36b-37c3-4fef-94e4-bbb6ef6e6761}</string>
					<ProtectedString name="Source"><![CDATA[--@localscript
--[[
--Created Date: Tuesday July 9th 2024 10:43:39 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 11:37:15 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Modules
local Debug = require(script.Parent.Debug)

--// Songs
local AudioListener = script.Parent.AudioListener:Clone() :: AudioListener
AudioListener.Name = "BoomboxAudioListener"

--// Variables
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	Audioscape = Remotes:WaitForChild("Audioscape") :: RemoteFunction,
}

local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

Handlers_Interface:Set("AudioListener", AudioListener)

--// Attributes
local Autoplay = script.Parent:GetAttribute("Autoplay")
local MaxVolume = script.Parent:GetAttribute("MaxVolume")
local Minimized = script.Parent:GetAttribute("Minimized")
local SearchEnabled = script.Parent:GetAttribute("SearchEnabled")
local DraggingEnabled = script.Parent:GetAttribute("DraggingEnabled")
local DefaultPosition = script.Parent:GetAttribute("DefaultPosition")
local DefaultAccentColor = script.Parent:GetAttribute("DefaultAccentColor")

Handlers_Interface:Set("AutoPlay", Autoplay)
Handlers_Interface:Set("MaxVolume", MaxVolume)
Handlers_Interface:Set("PlayerHidden", Minimized)
Handlers_Interface:Set("PlayerVisible", not Minimized)
Handlers_Interface:Set("SearchEnabled", SearchEnabled)
Handlers_Interface:Set("DraggingEnabled", DraggingEnabled)
Handlers_Interface:Set("DefaultPosition", DefaultPosition)
Handlers_Interface:Set("DefaultAccentColor", DefaultAccentColor)

--// Init
require(Interface)
Handlers_Interface:Set("Queue", {})

--// Var

task.spawn(function()
	local Song = Events.Persistence:InvokeServer("GET", "playing")

	if Song then
		Song = HttpService:JSONDecode(Song)
		Handlers_Interface:Set("Sound", Song)
	end

	local Queue = Events.Persistence:InvokeServer("GET", "queue")

	if Queue and Queue ~= "null" then
		local DecodedQueue = HttpService:JSONDecode(Queue)

		Handlers_Interface:Set("Queue", DecodedQueue["asset_id"] and { DecodedQueue } or DecodedQueue)
	end
end)

Handlers_Interface:Set("Loaded", true)

if Debug.LoadingDebug then
	require(script.Parent)
	print("Init Client Loaded")
end

AudioListener.Parent = workspace.CurrentCamera

require(script.Parent.Managers)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4171531dfd254d3292ba331c6c8ffbe7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Managers</string>
					<string name="ScriptGuid">{69fb0cf0-eeca-4bcd-8737-f4c0f236e027}</string>
					<ProtectedString name="Source"><![CDATA[local Debug = require(script.Parent.Debug)

local ManagerScripts = {
	script.Audioscape,
	script.AudioControls,
	script.Queue,
	script.Search,
	script.HeadlessRemotes,
	script.Persistence,
	script.Sound,
	script.BoomboxReplicator,
	script.Loader,
	script.Like,
}

local Managers = {}

for i = 1, #ManagerScripts do
	local Current = ManagerScripts[i]
	if Debug.LoadingDebug then
		print("-----------\n Loading Manager: " .. Current.Name)
	end

	require(Current)
end

return Managers]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX55533165c2f54f64ad007d9f3d1d76ec">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioControls</string>
						<string name="ScriptGuid">{49570595-b0b4-4d6a-98f3-25a4ff420ff2}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Debug = require(script.Parent.Parent.Debug)
local BoomboxClient = require(script.Parent.Parent)

local AudioAssembly = require(script.Parent.Parent.Modules.AudioAssembly)

local Instween = require(script.Parent.Parent.Util.Instween)

local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	Audioscape = Remotes:WaitForChild("Audioscape") :: RemoteFunction,
}

Handlers_Interface:Subscribe("PlaySound", function(Song: any, Fading: boolean)
	task.defer(function()
		Events.Audioscape:InvokeServer("telemetry", {
			["asset_id"] = Song.asset_id,
			["event_type"] = "play_song",
		})
	end)

	if Fading then
		local Sound = Handlers_Interface:Get("AudioPlayer") :: Sound

		local CurrentTween = Instween.new(
			Sound,
			{
				Volume = 0,
			},
			2,
			{
				EasingStyle = Enum.EasingStyle.Linear,
				EasingDirection = Enum.EasingDirection.Out,
			}
		)

		CurrentTween.Completed:Once(function()
			CurrentTween:Destroy()
			Handlers_Interface:Set("Fading", false)
			task.delay(1, function()
				Sound:Destroy()
			end)
		end)

		local NewSound =
			AudioAssembly.CreateLayers({ "AudioPitchShifter", "AudioFader", "AudioReverb", "AudioEqualizer" })
		NewSound.Parent = Sound.Parent
		NewSound.Name = "AudioscapeBoomBox"
		Handlers_Interface:Set("AudioPlayer", NewSound)

		CurrentTween:Play()
		Handlers_Interface:Set("Fading", true)
	end

	Handlers_Interface:Set("Sound", Song)
	Handlers_Interface:Fire("BoomboxEventMediator", "Play")
end)

Handlers_Interface:Subscribe("AddToQueue", function(Song: any)
	local Queue = Handlers_Interface:Get("Queue") :: { [any]: any }
	table.insert(Queue, Song) -- Insert after the first song
	Handlers_Interface:Set("Queue", Queue)
end)

Handlers_Interface:Subscribe("ToggleSong", function(State: number)
	local CurrentQueue = Handlers_Interface:Get("Queue") :: number
	local CurrentQueueIndex = Handlers_Interface:Get("QueueIndex") :: number

	local AudioPlayer = Handlers_Interface:Get("AudioPlayer") :: AudioPlayer
	local songCount = #Handlers_Interface:Get("Queue") -- Assuming songInfo is the table holding the songs

	if State == -1 then
		-- Go to previous song

		task.defer(function()
			Events.Audioscape:InvokeServer("telemetry", {
				["asset_id"] = AudioPlayer.AssetId,
				["event_type"] = "rewind_song",
			})
		end)

		if AudioPlayer.TimePosition > 5 and AudioPlayer.IsPlaying then
			AudioPlayer.TimePosition = 0

			task.defer(function()
				Events.Audioscape:InvokeServer("telemetry", {
					["asset_id"] = AudioPlayer.AssetId,
					["event_type"] = "play_song",
				})
			end)
			return
		end

		CurrentQueueIndex = (CurrentQueueIndex - 1) < 1 and songCount or (CurrentQueueIndex - 1)
		Handlers_Interface:Set("QueueIndex", CurrentQueueIndex)
	elseif State == 1 then
		-- Go to next song

		task.defer(function()
			Events.Audioscape:InvokeServer("telemetry", {
				["asset_id"] = AudioPlayer.AssetId,
				["event_type"] = "skip_song",
			})
		end)

		if Handlers_Interface:Get("Shuffling") then
			local RandomSongIndex = math.random(CurrentQueueIndex, #CurrentQueue)

			-- Move the random song in front of the CurrentQueueIndex
			local RandomSong = table.remove(CurrentQueue, RandomSongIndex)
			CurrentQueueIndex = (CurrentQueueIndex + 1) > songCount and 1 or (CurrentQueueIndex + 1)
			table.insert(CurrentQueue, CurrentQueueIndex, RandomSong)

			-- Update the Queue and QueueIndex in your interface
			Handlers_Interface:Set("Queue", CurrentQueue)
			Handlers_Interface:Set("QueueIndex", CurrentQueueIndex)
		else
			CurrentQueueIndex = (CurrentQueueIndex + 1) > songCount and 1 or (CurrentQueueIndex + 1)
			Handlers_Interface:Set("QueueIndex", CurrentQueueIndex)
		end
	elseif State == 0 then
		-- Stop/Play the song
		if AudioPlayer.IsPlaying then
			task.defer(function()
				Events.Audioscape:InvokeServer("telemetry", {
					["asset_id"] = AudioPlayer.AssetId,
					["event_type"] = "pause_song",
				})
			end)
			AudioPlayer:Stop()
			Handlers_Interface:Set("SoundPlaying", false)
			Handlers_Interface:Fire("BoomboxEventMediator", "Pause")
		else
			task.defer(function()
				Events.Audioscape:InvokeServer("telemetry", {
					["asset_id"] = AudioPlayer.AssetId,
					["event_type"] = "resume_song",
				})
			end)
			AudioPlayer:Play()
			Handlers_Interface:Set("SoundPlaying", true)
			Handlers_Interface:Fire("BoomboxEventMediator", "Resume")
		end
	end
end)

if Debug.LoadingDebug then
	print("Audio Controls Manager Loaded")
end

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXdcc0bea36fe04e799b150f13cb4fb73a">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Audioscape</string>
						<string name="ScriptGuid">{32690f3d-e821-42a0-a688-1790e8337ad2}</string>
						<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Debug = require(script.Parent.Parent.Debug)

local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	Audioscape = Remotes:WaitForChild("Audioscape") :: RemoteFunction,
}

Handlers_Interface:Subscribe("ClientAudioscape", function(Action: string, Payload: any, PushToQueue: boolean)
	if Action == "search" then
		Handlers_Interface:Set("LibraryResults", {})
		Handlers_Interface:Set("Searching", true)

		local Results = HttpService:JSONDecode(Events.Audioscape:InvokeServer("search", Payload))

		if #Results < 1 then
			Handlers_Interface:Set("Searching", false)
		end

		if Results[1] then
			Handlers_Interface:Set("LibraryResults", Results)
			Handlers_Interface:Set("Searching", false)

			if PushToQueue then
				local Queue = {}
				for i = 1, math.clamp(#Results, 2, 40) do
					table.insert(Queue, Results[i])
				end

				Handlers_Interface:Fire("PlaySound", Results[1])

				Handlers_Interface:Set("Queue", Queue)
			end
		end
	else
		Events.Audioscape:InvokeServer(Action, Payload)
	end
end)

if Debug.LoadingDebug then
	print("Audioscape Manager Loaded")
end

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXb2ac8cd186ee4f06a09b975224f75c36">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BoomboxReplicator</string>
						<string name="ScriptGuid">{4d81cfd2-c72e-4c38-a431-b89933524065}</string>
						<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Debug = require(script.Parent.Parent.Debug)

local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	BoomboxEvent = Remotes:WaitForChild("BoomboxEvent") :: RemoteEvent,
	ToggleBoombox = Remotes:WaitForChild("ToggleBoombox") :: RemoteEvent,
	BoomboxStateRetrieval = Remotes:WaitForChild("BoomboxStateRetrieval") :: RemoteFunction,
}

Handlers_Interface:Subscribe("ToggleBoombox", function()
	Handlers_Interface:Set("BoomboxVisible", not Handlers_Interface:Get("BoomboxVisible"))
	Events.ToggleBoombox:FireServer(Handlers_Interface:Get("BoomboxVisible"))

	if not Handlers_Interface:Get("BoomboxVisible") then
		local AudioPlayer = Handlers_Interface:Get("AudioPlayer") :: Sound
		AudioPlayer.Volume = Handlers_Interface:Get("Volume")
	end
end)

Handlers_Interface:Subscribe("BoomboxEventMediator", function(Event: string, ...)
	if not Handlers_Interface:Get("BoomboxVisible") then
		return
	end

	local Sound = Handlers_Interface:Get("Sound")
	local AudioPlayer = Handlers_Interface:Get("AudioPlayer") :: AudioPlayer

	local Volume = AudioPlayer.Volume

	if Event == "Volume" then
		Volume = Handlers_Interface:Get("Volume")
	end

	local BoomboxState = {
		Sound = Sound,
		SoundProperties = {
			Volume = Volume,
			AssetId = AudioPlayer.AssetId,
			Playing = AudioPlayer.IsPlaying,
			TimePosition = AudioPlayer.TimePosition,
			AudioPreset = Handlers_Interface:Get("AudioPreset"),
		},
	}

	Events.BoomboxEvent:FireServer(Event, BoomboxState, ...)
end)

Events.BoomboxStateRetrieval.OnClientInvoke = function()
	local Sound = Handlers_Interface:Get("Sound")
	local AudioPlayer = Handlers_Interface:Get("AudioPlayer") :: AudioPlayer

	task.delay(0.1, function()
		AudioPlayer.Volume = 0
	end)
	return {
		Sound = Sound,
		SoundProperties = {
			Volume = AudioPlayer.Volume,
			AssetId = AudioPlayer.AssetId,
			Playing = AudioPlayer.IsPlaying,
			TimePosition = AudioPlayer.TimePosition,
			AudioPreset = Handlers_Interface:Get("AudioPreset"),
		},
	}
end

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8e6dbae995ec44998b84cee1bd626766">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">HeadlessRemotes</string>
						<string name="ScriptGuid">{231dd753-50a3-442d-8b3c-5ea7cb540d10}</string>
						<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript
local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")

local Debug = require(script.Parent.Parent.Debug)

local Events = {
	HeadlessEvents = Remotes:WaitForChild("HeadlessEvents") :: RemoteEvent,
	HeadlessFunctions = Remotes:WaitForChild("HeadlessFunctions") :: RemoteFunction,
	Audioscape = Remotes:WaitForChild("Audioscape") :: RemoteFunction,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
}

local InsTweent = require(script.Parent.Parent.Util.Instween)

--// Types
type RobloxAudioMetadata = {
	asset_id: string,
	asset_name: string,
	asset_audio_details_music_album: string,
	asset_audio_details_music_genre: string,
}

Events.HeadlessFunctions.OnClientInvoke = function(
	RobloxAudioMetadata: string,
	RequestMetadataFill: RemoteFunction,
	Info: {
		Fade: number?,
		PlayNow: boolean,
		ClearQueue: boolean,
	}
)
	-- Retrieve the current queue and queue index from the interface handler
	local Queue = Handlers_Interface:Get("Queue")
	local QueueIndex = Handlers_Interface:Get("QueueIndex")

	-- Decode the JSON string containing Roblox audio metadata
	local DecodedMetadata = HttpService:JSONDecode(RobloxAudioMetadata) :: { RobloxAudioMetadata }

	if Debug.HeadlessRemotesDebug then
		print("Decoded Metadata: ", DecodedMetadata)
	end

	-- Initialize the positions where new metadata will be inserted
	local InsertedPositions = {
		Start = 1,
		End = #DecodedMetadata,
	}

	-- If the queue should be cleared or the songs should play immediately
	if Info.ClearQueue or Info.PlayNow then
		-- Set the queue to the decoded metadata and reset the queue index
		Handlers_Interface:Set("Queue", DecodedMetadata)
		Handlers_Interface:Set("QueueIndex", 1)
		-- Trigger the play sound event with the first song in the queue
		Handlers_Interface:Fire("PlaySound", DecodedMetadata[1])
	else
		-- Otherwise, insert the new metadata into the existing queue
		for i, metadata in ipairs(DecodedMetadata) do
			table.insert(Queue, QueueIndex + i, metadata)
		end
		-- Update the inserted positions
		InsertedPositions.Start = QueueIndex + 1
		InsertedPositions.End = QueueIndex + #DecodedMetadata

		-- Update the queue in the interface handler
		Handlers_Interface:Set("Queue", Queue)
	end

	-- Request additional audio metadata from the server
	if Debug.HeadlessRemotesDebug then
		print("Requesting metadata")
	end

	local AudioScapeAudioMetadata = HttpService:JSONDecode(RequestMetadataFill:InvokeServer())

	if Debug.HeadlessRemotesDebug then
		print("Metadata received", AudioScapeAudioMetadata)
	end

	task.spawn(function()
		-- Retrieve the updated queue from the interface handler
		local UpdatedQueue = Handlers_Interface:Get("Queue")

		-- Update the queue with the additional metadata
		for i = QueueIndex + 1, #UpdatedQueue do
			for _, audioMetadata in ipairs(AudioScapeAudioMetadata) do
				if UpdatedQueue[i].asset_id == audioMetadata.asset_id then
					UpdatedQueue[i] = audioMetadata
				end
			end
		end

		-- Set the updated queue in the interface handler
		Handlers_Interface:Set("Queue", UpdatedQueue)
	end)

	-- Return true to indicate successful processing
	return true
end

Remotes.HeadlessEvents.OnClientEvent:Connect(function(EventName: string, Info)
	if EventName == "AdjustMaxVolume" then
		local MaxVolume = Info.MaxVolume

		local VolumePercent = Handlers_Interface:Get("VolumePercent")

		Handlers_Interface:Set("MaxVolume", MaxVolume)

		Handlers_Interface:Set("Volume", MaxVolume * VolumePercent)

		local Sound = Handlers_Interface:Get("AudioPlayer") :: Sound
		-- Sound.Volume = MaxVolume * VolumePercent
		local NewTween = InsTweent.new(
			Sound,
			{ Volume = math.clamp(0, Sound.Volume, MaxVolume) },
			Info.FadeTime or 1,
			{ EasingStyle = Enum.EasingStyle.Linear }
		)

		local Connection
		Connection = NewTween.Completed:Connect(function()
			Handlers_Interface:Set("Volume", Sound.Volume)
			Connection:Disconnect()
		end)

		NewTween:Play()
	elseif EventName == "AdjustVolume" then
		local Volume = Info.Volume

		local MaxVolume = Handlers_Interface:Get("MaxVolume")

		Handlers_Interface:Set("VolumePercent", Volume / MaxVolume)

		local Sound = Handlers_Interface:Get("AudioPlayer") :: Sound
		-- Sound.Volume = MaxVolume * (Volume / MaxVolume)

		local NewTween = InsTweent.new(
			Sound,
			{ Volume = MaxVolume * (Volume / MaxVolume) },
			Info.FadeTime or 1,
			{ EasingStyle = Enum.EasingStyle.Linear }
		)

		local Connection
		Connection = NewTween.Completed:Connect(function()
			Handlers_Interface:Set("Volume", Sound.Volume)
			Connection:Disconnect()
		end)

		NewTween:Play()
	elseif EventName == "PlayBoombox" then
		if not Handlers_Interface:Get("SoundPlaying") then
			Handlers_Interface:Fire("ToggleSong", 0)
		end
	elseif EventName == "PauseBoombox" then
		if Handlers_Interface:Get("SoundPlaying") then
			Handlers_Interface:Fire("ToggleSong", 0)
		end
	end
end)

if Debug.LoadingDebug then
	print("Headless Remotes Loaded")
end

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX629d7cdc5e154fca8e97390fc2378b36">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Like</string>
						<string name="ScriptGuid">{ae43387b-7519-44d6-9189-90001b7127ff}</string>
						<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Debug = require(script.Parent.Parent.Debug)

local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	Audioscape = Remotes:WaitForChild("Audioscape") :: RemoteFunction,
}

local TimeSorter = require(script.Parent.Parent.Util.TimeSorter)

Handlers_Interface:Subscribe("LikeEvent", function(Payload, Liked: boolean)
	local Like = if Liked == false then "unlike" else "like"

	Events.Audioscape:InvokeServer(Like, Payload)

	local Likes = HttpService:JSONDecode(Events.Audioscape:InvokeServer("likes", {}))
	Handlers_Interface:Set("Favorites", TimeSorter(Likes))
	Handlers_Interface:Set("FavoritesResults", TimeSorter(Likes))
end)

Handlers_Interface:SubscribeToState("Sound", function(Playing: { ["asset_id"]: number })
	local Favorites = Handlers_Interface:Get("Favorites")
	local Found = false

	for _, Song in Favorites do
		if Song and Playing and Song.asset_id == Playing.asset_id then
			Found = true
		end
	end
	Handlers_Interface:Set("PlayingLiked", Found)
end)

Handlers_Interface:SubscribeToState("Favorites", function(Favorites: { { ["asset_id"]: number } })
	local Playing = Handlers_Interface:Get("Sound")
	local Found = false

	local FavoritesDictionary = {}

	for _, Song in Favorites do
		if Playing and Song.asset_id == Playing.asset_id then
			Found = true
		end

		FavoritesDictionary[Song.asset_id] = true
	end

	Handlers_Interface:Set("PlayingLiked", Found)
	Handlers_Interface:Set("FavoritesDictionary", FavoritesDictionary)
end)

local Likes = HttpService:JSONDecode(Events.Audioscape:InvokeServer("likes", {}))

if Debug.LoadingDebug then
	warn("Printing Likes")
	print(Likes)
end

Handlers_Interface:Set("LikesRetrieved", true)
Handlers_Interface:Set("Favorites", TimeSorter(Likes))
Handlers_Interface:Set("FavoritesResults", TimeSorter(Likes))

if Debug.LoadingDebug then
	print("Like Manager Loaded")
end

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX06b70678b405439280f81a12e5b5ef31">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Loader</string>
						<string name="ScriptGuid">{0d44ca95-8eba-4439-845a-4e6e3709473c}</string>
						<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Debug = require(script.Parent.Parent.Debug)

local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	Audioscape = Remotes:WaitForChild("Audioscape") :: RemoteFunction,
}

local EmotionRetrievalTick = tick()

if Debug.LoadingDebug then
	EmotionRetrievalTick = tick()
	print("GETTING EMOTIONS")
end

local Emotions = Events.Audioscape:InvokeServer("emotions", {})

if Debug.LoadingDebug then
	print(`RETRIEVED EMOTIONS IN {tick() - EmotionRetrievalTick} SECONDS: `, HttpService:JSONDecode(Emotions))
end

Handlers_Interface:Set("Emotions", HttpService:JSONDecode(Emotions))

local Genres = Events.Audioscape:InvokeServer("genres", {})
local DecodedGenres = HttpService:JSONDecode(Genres)
Handlers_Interface:Set("Genres", DecodedGenres)

task.spawn(function()
	while true do
		task.wait(Debug.GlobalDatabaseUpdateInterval)
		EmotionRetrievalTick = tick()
		Genres = Events.Audioscape:InvokeServer("genres", {})
		Handlers_Interface:Set("Genres", HttpService:JSONDecode(Genres))

		if Debug.GlobalDatabaseGenereUpdateDebug then
			print(`UPDATED GENRES IN {tick() - EmotionRetrievalTick} SECONDS: `, HttpService:JSONDecode(Genres))
		end
	end
end)

if Debug.LoadingDebug then
	print("Loader Manager Loaded")
end
return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX83e1f483fa6543eb8d3cad8c45afe917">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Persistence</string>
						<string name="ScriptGuid">{f909d2a0-d828-4c1b-8e2d-52539056eb4e}</string>
						<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Debug = require(script.Parent.Parent.Debug)

local Remotes = ReplicatedStorage:WaitForChild("BoomboxRemotes")
local Events = {
	CreatePublicSound = Remotes:WaitForChild("CreatePublicSound") :: RemoteEvent,
	Persistence = Remotes:WaitForChild("Persistence") :: RemoteFunction,
	Audioscape = Remotes:WaitForChild("Audioscape") :: RemoteFunction,
}

Handlers_Interface:SubscribeToState("Sound", function(Sound)
	--// Check if the sound is still the same
	if Handlers_Interface:Get("Sound") ~= Sound then
		return
	end

	--// Post the sound

	if not Sound or not Sound.asset_id then
		return
	end

	local Post = Events.Persistence:InvokeServer("POST", "playing", {
		asset_id = Sound.asset_id,
		asset_name = Sound.asset_name,
		asset_audio_details_music_album = Sound.asset_audio_details_music_album,
	})
end)

Handlers_Interface:SubscribeToState("Queue", function(Queue)
	if Handlers_Interface:Get("Queue") ~= Queue then
		return
	end

	local QueueIndex = Handlers_Interface:Get("QueueIndex")
	local StoredQueue = {}

	for i = QueueIndex, #Queue do
		table.insert(StoredQueue, Queue[i])
	end

	--// Post the sound
	local Post = Events.Persistence:InvokeServer("POST", "queue", StoredQueue)
end)

if Debug.LoadingDebug then
	print("Persistence Manager Loaded")
end

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXe117328daf5c4deeb73152a97fba0765">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Queue</string>
						<string name="ScriptGuid">{5fca6a2d-a311-44a8-876e-a8b5cf124bc9}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Debug = require(script.Parent.Parent.Debug)

Handlers_Interface:SubscribeToState("QueueIndex", function(Index)
	if not Handlers_Interface:Get("Loaded") then
		return
	end

	local Queue = Handlers_Interface:Get("Queue") :: { [any]: any }
	local QueueLength = #Queue
	local NewIndex = math.clamp(Index, 0, QueueLength + 5)

	--// Play First Song
	-- Handlers_Interface:Set("Sound", Queue[NewIndex])
	Handlers_Interface:Fire("PlaySound", Queue[NewIndex])
end)

Handlers_Interface:SubscribeToState("Queue", function(Queue: { [number]: any })
	local QueueIndex = Handlers_Interface:Get("QueueIndex") :: number
	local QueueMaxLength = Handlers_Interface:Get("QueueMaxLength") :: number

	local NewIndex = QueueIndex

	if #Queue > QueueMaxLength then
		if QueueIndex > 1 and #Queue > QueueMaxLength then
			-- Remove the first song

			table.remove(Queue, 1)
			NewIndex = QueueIndex - 1
		elseif QueueIndex == 1 and #Queue > QueueMaxLength then
			-- Remove the second to last song
			table.remove(Queue, #Queue - 1)
		end

		Handlers_Interface:Set("Queue", Queue)

		if NewIndex ~= QueueIndex then
			Handlers_Interface:Set("QueueIndex", NewIndex)
		end
	end
end)

Handlers_Interface:Subscribe("QueueReorder", function(Data, Play)
	local Queue = Handlers_Interface:Get("Queue") :: { [number]: any }

	local Index = Data["Index"] :: number
	local NewIndex = Data["NewIndex"] :: number

	local Song = Queue[Index]

	table.remove(Queue, Index)
	table.insert(Queue, NewIndex, Song)

	Handlers_Interface:Set("Queue", Queue)

	local NewQueue = Handlers_Interface:Get("Queue") :: { [number]: any }
end)

if Debug.LoadingDebug then
	print("Queue Manager Loaded")
end

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXba49948ecbee494fa18a6b08f9748d16">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Search</string>
						<string name="ScriptGuid">{7494bc4e-e8b3-4f71-ae27-dde3936c52e0}</string>
						<ProtectedString name="Source"><![CDATA[local AssetService = game:GetService("AssetService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Debug = require(script.Parent.Parent.Debug)

Handlers_Interface:SubscribeToState("LibraryResults", function(State)
	if State[1] then
		-- Songs = State
		-- Handlers_Interface:Set("Queue", State)a

		if Handlers_Interface:Get("QueueIndex") == 1 then
			Handlers_Interface:Set("Sound", State[1])
		else
			Handlers_Interface:Set("QueueIndex", 1)
		end

		local Payload = {
			search_term = Handlers_Interface:Get("SearchQuery"),
			results = {},
		}

		for i, v in pairs(State) do
			table.insert(Payload.results, tonumber(v.asset_id))
		end
	end
end)

local function RestructureFromRobloxMetaData(Song)
	return {
		asset_bpm = 120,
		asset_id = Song.AssetId, -- Asset ID of the song
		asset_name = Song.Title, -- Title of the song
		asset_audio_details_music_album = Song.Artist, -- Artist of the song
		asset_audio_details_music_genre = "Unknown", -- Music genre, set to unknown as a default
	}
end

Handlers_Interface:Subscribe("ProcessIDSearch", function(Id: string)
	local MetaData = AssetService:GetAudioMetadataAsync({ Id })[1]

	if not MetaData then
		print("No metadata found for " .. Id, MetaData)
		return
	end

	local RestructuredMetaData = RestructureFromRobloxMetaData(MetaData)

	Handlers_Interface:Set("Sound", RestructuredMetaData)
	-- AudioPlayer.AssetId = Id
end)

if Debug.LoadingDebug then
	print("Search Manager Loaded")
end

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX12dbcbbdf77a4c78b56c5e6e692667a3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Sound</string>
						<string name="ScriptGuid">{6bbae615-6d23-45d4-89df-137f9e486dd9}</string>
						<ProtectedString name="Source"><![CDATA[local AssetService = game:GetService("AssetService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

local Debug = require(script.Parent.Parent.Debug)

Handlers_Interface:SubscribeToState("AudioPlayer", function(State: AudioPlayer)
	local PreviousAudioAnalyzer = Handlers_Interface:Get("AudioAnalyzer") :: AudioAnalyzer
	if PreviousAudioAnalyzer then
		PreviousAudioAnalyzer:Destroy()
	end

	local AudioAnalyzer = Instance.new("AudioAnalyzer")
	AudioAnalyzer.Parent = State

	local Wire2 = Instance.new("Wire")
	Wire2.Parent = AudioAnalyzer
	Wire2.SourceInstance = State
	Wire2.TargetInstance = AudioAnalyzer

	Handlers_Interface:Set("AudioAnalyzer", AudioAnalyzer)
end)

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXb30dec99b1c24a8786b91a76939260c0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Modules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX3852a00928524595baf3fbc1f619e5df">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioAssembly</string>
						<string name="ScriptGuid">{0f6637e2-eb71-43ac-9a68-469d6730f246}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Modules
local Slider = require(script.Slider)
local Presets = require(script.Presets)

--// AudioAssembly Class
local AudioAssembly = {
	Debug = false,
	Layers = {},
}

local function ApplyPreset()
	local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
	local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

	Handlers_Interface:Subscribe("ApplyPreset", function(Layer: string, Preset: number)
		local LayerInstance = AudioAssembly.Layers[Layer]

		Handlers_Interface:Fire("BoomboxEventMediator", "ApplyPreset")

		if not LayerInstance then
			return
		end

		for Property, Value in Presets[Layer][Preset] do
			LayerInstance[Property] = Value
		end
	end)
end

function AudioAssembly.AudioPitchShifter(AudioPlayer: AudioPlayer, AudioPitchShifter: AudioPitchShifter)
	local Connections = {}
	local ScreenGui = nil

	Connections[#Connections + 1] = AudioPlayer:GetPropertyChangedSignal("PlaybackSpeed"):Connect(function()
		AudioPlayer.PlaybackSpeed = math.clamp(AudioPlayer.PlaybackSpeed, 0.6, 1.5)
		-- AudioPitchShifter.Pitch = 1 / AudioPlayer.PlaybackSpeed
	end)

	AudioPlayer.Destroying:Once(function()
		for _, Connection in Connections do
			Connection:Disconnect()
		end

		table.clear(Connections)

		if ScreenGui then
			ScreenGui:Destroy()
		end
	end)

	if AudioAssembly.Debug then
		ScreenGui = Instance.new("ScreenGui")
		ScreenGui.Parent = AudioPlayer

		local frame = Instance.new("Frame")
		frame.Name = "Frame"
		frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
		frame.BorderSizePixel = 0
		frame.Position = UDim2.fromScale(0, 0.645)
		frame.Size = UDim2.fromScale(0.187, 0.218)

		local PitchLabel = Instance.new("TextBox")
		PitchLabel.Name = "PitchLabel"
		PitchLabel.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
		PitchLabel.Text = "Pitch: 1"
		PitchLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
		PitchLabel.TextScaled = true
		PitchLabel.TextSize = 14
		PitchLabel.TextWrapped = true
		PitchLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		PitchLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
		PitchLabel.BorderSizePixel = 0
		PitchLabel.Size = UDim2.fromScale(1, 0.5)
		PitchLabel.Visible = false
		PitchLabel.Parent = frame

		-- local SliderButton = Instance.new("ImageButton")
		-- SliderButton.Name = "Slider"
		-- SliderButton.Image = ""
		-- SliderButton.Size = UDim2.fromScale(0.2, 0.2)
		-- SliderButton.BackgroundColor3 = Color3.new(1, 0, 0)

		-- SliderButton.Parent = PitchLabel

		-- local AspectRatio = Instance.new("UIAspectRatioConstraint")
		-- AspectRatio.Parent = SliderButton

		local PlaybackLabel = Instance.new("TextBox")
		PlaybackLabel.Name = "PlaybackLabel"
		PlaybackLabel.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
		PlaybackLabel.Text = "PlaybackSpeed: 1"
		PlaybackLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
		PlaybackLabel.TextScaled = true
		PlaybackLabel.TextSize = 14
		PlaybackLabel.TextWrapped = true
		PlaybackLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		PlaybackLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
		PlaybackLabel.BorderSizePixel = 0
		PlaybackLabel.Size = UDim2.fromScale(1, 0.5)
		PlaybackLabel.Parent = frame

		local uIListLayout = Instance.new("UIListLayout")
		uIListLayout.Name = "UIListLayout"
		uIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
		uIListLayout.Parent = frame

		-- local PitchSlider = Slider.new(PitchLabel, {
		-- 	Axis = "X",
		-- 	SliderData = {
		-- 		Start = 0.6,
		-- 		End = 2,
		-- 		Increment = 0.1,
		-- 	},
		-- })

		Connections[#Connections + 1] = AudioPlayer:GetPropertyChangedSignal("PlaybackSpeed"):Connect(function()
			PlaybackLabel.Text = "PlaybackSpeed: " .. AudioPlayer.PlaybackSpeed
		end)

		Connections[#Connections + 1] = AudioPitchShifter:GetPropertyChangedSignal("Pitch"):Connect(function()
			PitchLabel.Text = "Pitch: " .. AudioPitchShifter.Pitch
		end)

		Connections[#Connections + 1] = PlaybackLabel.FocusLost:Connect(function()
			local PlaybackSpeed = tonumber(PlaybackLabel.Text)
			if PlaybackSpeed then
				AudioPlayer.PlaybackSpeed = PlaybackSpeed
			end
			PlaybackLabel.Text = "PlaybackSpeed: " .. AudioPlayer.PlaybackSpeed
		end)

		Connections[#Connections + 1] = PitchLabel.FocusLost:Connect(function()
			local Pitch = tonumber(PitchLabel.Text)
			if Pitch then
				AudioPitchShifter.Pitch = Pitch
			end
			PitchLabel.Text = "Pitch: " .. AudioPitchShifter.Pitch
		end)

		-- Connections[#Connections + 1] = PitchSlider.Released:Connect(function(Value)
		-- 	local Pitch = tonumber(PitchLabel.Text)
		-- 	if Pitch then
		-- 		AudioPitchShifter.Pitch = Pitch
		-- 	end
		-- 	PitchLabel.Text = "Pitch: " .. AudioPitchShifter.Pitch
		-- end)

		frame.Parent = ScreenGui
		ScreenGui.Parent = Players.LocalPlayer.PlayerGui
	end
end

function AudioAssembly.AudioReverb(AudioPlayer: AudioPlayer, AudioReverb: AudioReverb)
	local Connections = {}
	local ScreenGui = nil

	AudioReverb.Bypass = true
	AudioReverb.DecayRatio = 0.811
	AudioReverb.DecayTime = 7.403
	AudioReverb.Density = 0.92
	AudioReverb.Diffusion = 1
	AudioReverb.DryLevel = 10
	AudioReverb.EarlyDelayTime = 0.022
	AudioReverb.HighCutFrequency = 5863.443
	AudioReverb.LateDelayTime = 0.1
	AudioReverb.LowShelfFrequency = 450
	AudioReverb.LowShelfGain = -36
	AudioReverb.ReferenceFrequency = 5000
	AudioReverb.WetLevel = 5

	AudioPlayer.Destroying:Once(function()
		for _, Connection in Connections do
			Connection:Disconnect()
		end

		table.clear(Connections)

		if ScreenGui then
			ScreenGui:Destroy()
		end
	end)

	if AudioAssembly.Debug then
		ScreenGui = Instance.new("ScreenGui")
		ScreenGui.Parent = AudioPlayer

		local frame = Instance.new("Frame")
		frame.Name = "Frame"
		frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
		frame.BorderSizePixel = 0
		frame.Position = UDim2.fromScale(0.1, 0.5)
		frame.Size = UDim2.fromScale(0.187, 0.218)
		frame.AnchorPoint = Vector2.new(0, 0.5)

		local uIListLayout = Instance.new("UIListLayout")
		uIListLayout.Name = "UIListLayout"
		uIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
		uIListLayout.Parent = frame

		for _, Property in { "WetLevel", "DryLevel", "Diffusion", "Density", "DecayTime" } do
			local PropertyLabel = Instance.new("TextBox")
			PropertyLabel.Name = "PropertyLabel"
			PropertyLabel.FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json")
			PropertyLabel.Text = Property .. ": " .. AudioReverb[Property]
			PropertyLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
			PropertyLabel.TextScaled = true
			PropertyLabel.TextSize = 14
			PropertyLabel.TextWrapped = true
			PropertyLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			PropertyLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
			PropertyLabel.BorderSizePixel = 0
			PropertyLabel.Size = UDim2.new(1, 0, 0, 25)
			PropertyLabel.Parent = frame

			Connections[#Connections + 1] = AudioReverb:GetPropertyChangedSignal(Property):Connect(function()
				PropertyLabel.Text = Property .. ": " .. AudioReverb[Property]
			end)

			Connections[#Connections + 1] = PropertyLabel.FocusLost:Connect(function()
				local Value = tonumber(PropertyLabel.Text)
				if Value then
					AudioReverb[Property] = Value
				else
					PropertyLabel.Text = Property .. ": " .. AudioReverb[Property]
				end
			end)
		end

		frame.Parent = ScreenGui
		ScreenGui.Parent = Players.LocalPlayer.PlayerGui
	end
end

function AudioAssembly.AudioEqualizer(AudioPlayer: AudioPlayer, AudioEqualizer: AudioEqualizer) end

function AudioAssembly.CreateLayer(AudioPlayer: AudioPlayer, PreviousLayer: Instance, Layer: string, Wire: Wire)
	local NewLayer = Instance.new(Layer)
	NewLayer.Name = Layer
	NewLayer.Parent = PreviousLayer

	if Wire then
		local NewWire = Instance.new("Wire")
		NewWire.Parent = NewLayer
		NewWire.SourceInstance = Wire.TargetInstance
		NewWire.TargetInstance = NewLayer
	else
		local NewWire = Instance.new("Wire")
		NewWire.Parent = NewLayer
		NewWire.SourceInstance = PreviousLayer
		NewWire.TargetInstance = NewLayer
	end

	if Layer == "AudioPitchShifter" then
		NewLayer.Pitch = 1
		AudioAssembly.AudioPitchShifter(AudioPlayer, NewLayer)
	elseif Layer == "AudioReverb" then
		AudioAssembly.AudioReverb(AudioPlayer, NewLayer)
	elseif Layer == "AudioEqualizer" then
		AudioAssembly.AudioEqualizer(AudioPlayer, NewLayer)
	end

	AudioAssembly.Layers[Layer] = NewLayer

	return NewLayer
end

function AudioAssembly.CreateLayers(Layers: { string })
	local Interface = ReplicatedStorage:WaitForChild("Interface") :: ModuleScript
	local Handlers_Interface = require(Interface.Handlers.Handlers_Interface) :: ModuleScript

	local AudioPlayer = Instance.new("AudioPlayer")
	local LayerInstances = {}

	local LastLayer = nil

	AudioAssembly.Layers["AudioPlayer"] = AudioPlayer

	for _, Layer in Layers do
		LastLayer = LayerInstances[#LayerInstances]
		table.insert(LayerInstances, AudioAssembly.CreateLayer(AudioPlayer, LastLayer or AudioPlayer, Layer))
	end

	local Wire = Instance.new("Wire")
	Wire.Parent = LayerInstances[#LayerInstances]
	Wire.SourceInstance = LayerInstances[#LayerInstances]
	Wire.TargetInstance = Handlers_Interface:Get("AudioListener"):FindFirstChildWhichIsA("AudioDeviceOutput")

	return AudioPlayer, LayerInstances
end

ApplyPreset()

return AudioAssembly]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX05ab43dddeeb4b2b912aa361aace73c8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Presets</string>
							<string name="ScriptGuid">{682f5da5-5f3f-498c-9b04-775740306c18}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	AudioReverb = {
		{
			DecayRatio = 0.811,
			DecayTime = 7.403,
			Density = 0.92,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0.022,
			HighCutFrequency = 5863.443,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = 5,
		},
	},
]]

local Presets = {
	AudioPlayer = {
		{
			PlaybackSpeed = 1,
		},
		{
			PlaybackSpeed = 0.7,
		},
		{
			PlaybackSpeed = 0.7,
		},
		{
			PlaybackSpeed = 1.3,
		},
		{
			PlaybackSpeed = 1.3,
		},
	},
	AudioFader = {
		{
			Volume = 1,
		},
		{
			Volume = 0.5,
		},
		{
			Volume = 0.5,
		},
		{
			Volume = 0.5,
		},
		{
			Volume = 0.5,
		},
	},
	AudioReverb = {
		{ -- Default
			Bypass = true,
			DecayRatio = 0.811,
			DecayTime = 6.189,
			Density = 0.92,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0.022,
			HighCutFrequency = 5863.443,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = -80,
		},
		{ -- 1
			Bypass = false,
			DecayRatio = 0.811,
			DecayTime = 6.189,
			Density = 0.92,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0.022,
			HighCutFrequency = 5863.443,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = 5,
		},
		{ -- 2
			Bypass = false,
			DecayRatio = 0.811,
			DecayTime = 1.314,
			Density = 1,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0,
			HighCutFrequency = 5863.443,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = 5,
		},
		{ -- 3
			Bypass = false,
			DecayRatio = 0.811,
			DecayTime = 1.314,
			Density = 1,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0,
			HighCutFrequency = 5863.443,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = 5,
		},
		{ -- 4
			Bypass = false,
			DecayRatio = 0.811,
			DecayTime = 3.344,
			Density = 1,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0,
			HighCutFrequency = 3689.429,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = 5,
		},
	},
}

return Presets]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXbc5343066a2944b9a3e148476b42c2bb">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Slider</string>
							<string name="ScriptGuid">{b1f91095-532a-45d8-8d83-d7a398a1cd1b}</string>
							<ProtectedString name="Source"><![CDATA[-----------------------------------------------------------------------------------------
----------------------------- Slider Module -----------------------------
-- [Author]: Krypt
-- [Description]: Creates a slider based on a start, end and incremental value. Allows ...
-- ... sliders to be moved, tracked/untracked, reset, and have specific properties such ...
-- ... as their current value and increment to be overriden.

-- [Version]: 2.1.1
-- [Created]: 22/12/2021
-- [Updated]: 23/11/2022
-- [Dev Forum Link]: https://devforum.roblox.com/t/1597785/
-----------------------------------------------------------------------------------------

--!nonstrict
local Slider = { Sliders = {} }

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

assert(RunService:IsClient(), "Slider module can only be used on the Client!")

local utilsFolder = script.Utils

local Signal = require(utilsFolder.Signal)
local SliderFuncs = require(utilsFolder.SliderFuncs)

Slider.__index = function(object, indexed)
	local deprecated = {
		{ ".OnChange", ".Changed", rawget(object, "Changed") },
	}

	for _, tbl in ipairs(deprecated) do
		local deprecatedStr = string.sub(tbl[1], 2)

		if deprecatedStr == indexed then
			warn(string.format("%s is deprecated, please use %s instead", tbl[1], tbl[2]))
			return tbl[3]
		end
	end

	return Slider[indexed]
end

export type configDictionary = {
	SliderData: { Start: number, End: number, Increment: number, DefaultValue: number | nil },
	MoveType: "Tween" | "Instant" | nil,
	MoveInfo: TweenInfo | nil,
	Axis: string | nil,
	Padding: number | nil,
	AllowBackgroundClick: boolean,
}

function Slider.new(holder: GuiBase2d, config: configDictionary)
	assert(
		pcall(function()
			return holder.AbsoluteSize, holder.AbsolutePosition
		end),
		"Holder argument does not have an AbsoluteSize/AbsolutePosition"
	)

	local duplicate = false
	for _, slider in ipairs(Slider.Sliders) do
		if slider._holder == holder then
			duplicate = true
			break
		end
	end

	assert(not duplicate, "Cannot set two sliders with same frame!")
	assert(config.SliderData.Increment ~= nil, "Failed to find Increment in SliderData table")
	assert(config.SliderData.Start ~= nil, "Failed to find Start in SliderData table")
	assert(config.SliderData.End ~= nil, "Failed to find End in SliderData table")
	assert(config.SliderData.Increment > 0, "SliderData.Increment must be greater than 0")
	assert(
		config.SliderData.End > config.SliderData.Start,
		string.format(
			"Slider end value must be greater than its start value! (%.1f <= %.1f)",
			config.SliderData.End,
			config.SliderData.Start
		)
	)

	local self = setmetatable({}, Slider)
	self._holder = holder
	self._data = {
		-- Buttons
		Button = nil,
		HolderButton = nil,

		-- Clicking
		_clickOverride = false,

		_mainConnection = nil,
		_clickConnections = {},
		_otherConnections = {},

		_inputPos = nil,

		-- Internal
		_percent = 0,
		_value = 0,
		_scaleIncrement = 0,
		_currentTween = nil,
		_allowBackgroundClick = if config.AllowBackgroundClick == false then false else true,
	}

	self._config = config
	self._config.Axis = string.upper(config.Axis or "X")
	self._config.Padding = config.Padding or 5
	self._config.MoveInfo = config.MoveInfo or TweenInfo.new(0.2)
	self._config.MoveType = config.MoveType or "Tween"
	self.IsHeld = false

	local sliderBtn = holder:FindFirstChild("Slider")
	assert(sliderBtn ~= nil, "Failed to find slider button.")
	assert(sliderBtn:IsA("GuiButton"), "Slider is not a GuiButton")

	self._data.Button = sliderBtn

	-- Holder button --
	if self._data._allowBackgroundClick then
		local holderClickButton = Instance.new("TextButton")
		holderClickButton.BackgroundTransparency = 1
		holderClickButton.Text = ""
		holderClickButton.Name = "HolderClickButton"
		holderClickButton.Size = UDim2.fromScale(1, 1)
		holderClickButton.ZIndex = -1
		holderClickButton.Parent = self._holder
		self._data.HolderButton = holderClickButton
	end

	-- Finalise --

	self._data._percent = 0
	if config.SliderData.DefaultValue then
		config.SliderData.DefaultValue =
			math.clamp(config.SliderData.DefaultValue, config.SliderData.Start, config.SliderData.End)
		self._data._percent =
			SliderFuncs.getAlphaBetween(config.SliderData.Start, config.SliderData.End, config.SliderData.DefaultValue)
	end

	self._data._percent = math.clamp(self._data._percent, 0, 1)

	self._data._value = SliderFuncs.getNewValue(self)
	self._data._increment = config.SliderData.Increment
	self._data._scaleIncrement = SliderFuncs.getScaleIncrement(self)

	self.Changed = Signal.new()
	self.Dragged = Signal.new()
	self.Released = Signal.new()

	self._data._percent = SliderFuncs.snapToScale(self._data._percent, self._data._scaleIncrement)
	self:Move()

	table.insert(
		self._data._otherConnections,
		sliderBtn:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			self:Move("Instant")
		end)
	)

	table.insert(Slider.Sliders, self)

	return self
end

function Slider:Track()
	for _, connection in ipairs(self._data._clickConnections) do
		connection:Disconnect()
	end

	table.insert(
		self._data._clickConnections,
		self._data.Button.MouseButton1Down:Connect(function()
			self.IsHeld = true
		end)
	)

	table.insert(
		self._data._clickConnections,
		self._data.Button.MouseButton1Up:Connect(function()
			if self.IsHeld then
				self.Released:Fire(self._data._value)
			end
			self.IsHeld = false
		end)
	)

	if self._data._allowBackgroundClick then
		table.insert(
			self._data._clickConnections,
			self._data.HolderButton.Activated:Connect(function(inputObject: InputObject)
				if
					inputObject.UserInputType == Enum.UserInputType.MouseButton1
					or inputObject.UserInputType == Enum.UserInputType.Touch
				then
					self._data._inputPos = inputObject.Position
					self._data._clickOverride = true
					self:Update()
					self._data._clickOverride = false
				end
			end)
		)
	end

	if self.Changed then
		self.Changed:Fire(self._data._value)
	end

	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end

	self._data._mainConnection = UserInputService.InputChanged:Connect(function(inputObject, gameProcessed)
		if
			inputObject.UserInputType == Enum.UserInputType.MouseMovement
			or inputObject.UserInputType == Enum.UserInputType.Touch
		then
			self._data._inputPos = inputObject.Position
			self:Update()
		end
	end)
end

function Slider:Update()
	if (self.IsHeld or self._data._clickOverride) and self._data._inputPos then
		local sliderSize = self._holder.AbsoluteSize[self._config.Axis]
		local sliderPos = self._holder.AbsolutePosition[self._config.Axis]

		local mousePos = self._data._inputPos[self._config.Axis]

		if mousePos then
			local relativePos = (mousePos - sliderPos)
			local newPos = SliderFuncs.snapToScale(relativePos / sliderSize, self._data._scaleIncrement)

			local percent = math.clamp(newPos, 0, 1)
			self._data._percent = percent
			self.Dragged:Fire(self._data._value)
			self:Move()
		end
	end
end

function Slider:Untrack()
	for _, connection in ipairs(self._data._clickConnections) do
		connection:Disconnect()
	end
	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end
	self.IsHeld = false
end

function Slider:Reset()
	for _, connection in ipairs(self._data._clickConnections) do
		connection:Disconnect()
	end
	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end

	self.IsHeld = false

	self._data._percent = 0
	if self._config.SliderData.DefaultValue then
		self._data._percent = SliderFuncs.getAlphaBetween(
			self._config.SliderData.Start,
			self._config.SliderData.End,
			self._config.SliderData.DefaultValue
		)
	end
	self._data._percent = math.clamp(self._data._percent, 0, 1)
	self:Move()
end

function Slider:OverrideValue(newValue: number)
	self.IsHeld = false
	self._data._percent =
		SliderFuncs.getAlphaBetween(self._config.SliderData.Start, self._config.SliderData.End, newValue)
	self._data._percent = math.clamp(self._data._percent, 0, 1)
	self._data._percent = SliderFuncs.snapToScale(self._data._percent, self._data._scaleIncrement)
	self:Move()
end

function Slider:Move(override: string)
	self._data._value = SliderFuncs.getNewValue(self)

	local moveType = if override ~= nil then override else self._config.MoveType
	if moveType == "Tween" or moveType == nil then
		if self._data._currentTween then
			self._data._currentTween:Cancel()
		end
		self._data._currentTween = TweenService:Create(self._data.Button, self._config.MoveInfo, {
			Position = SliderFuncs.getNewPosition(self),
		})
		self._data._currentTween:Play()
	elseif moveType == "Instant" then
		self._data.Button.Position = SliderFuncs.getNewPosition(self)
	end
	self.Changed:Fire(self._data._value)
end

function Slider:OverrideIncrement(newIncrement: number)
	self._config.SliderData.Increment = newIncrement
	self._data._increment = newIncrement
	self._data._scaleIncrement = SliderFuncs.getScaleIncrement(self)
	self._data._percent = math.clamp(self._data._percent, 0, 1)
	self._data._percent = SliderFuncs.snapToScale(self._data._percent, self._data._scaleIncrement)
	self:Move()
end

function Slider:GetValue()
	return self._data._value
end

function Slider:GetIncrement()
	return self._data._increment
end

function Slider:Destroy()
	for _, connection in ipairs(self._data._clickConnections) do
		connection:Disconnect()
	end
	for _, connection in ipairs(self._data._otherConnections) do
		connection:Disconnect()
	end

	if self._data._mainConnection then
		self._data._mainConnection:Disconnect()
	end

	if self._data.HolderButton then
		self._data.HolderButton:Destroy()
		self._data.HolderButton = nil
	end

	self.Changed:Destroy()
	self.Dragged:Destroy()
	self.Released:Destroy()

	for index = 1, #Slider.Sliders do
		if Slider.Sliders[index] == self then
			table.remove(Slider.Sliders, index)
		end
	end

	setmetatable(self, nil)
	self = nil
end

UserInputService.InputEnded:Connect(function(inputObject: InputObject, internallyProcessed: boolean)
	if
		inputObject.UserInputType == Enum.UserInputType.MouseButton1
		or inputObject.UserInputType == Enum.UserInputType.Touch
	then
		for _, slider in ipairs(Slider.Sliders) do
			if slider.IsHeld then
				slider.Released:Fire(slider._data._value)
			end
			slider.IsHeld = false
		end
	end
end)

return Slider
-----------------------------------------------------------------------------------------]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXce4bc67324714c71b51ed61854114852">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Utils</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX8d00e870c59e497ba85723727b4faca6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Signal</string>
									<string name="ScriptGuid">{cd35dc2c-e3ca-4a0e-ba91-cfa39998200e}</string>
									<ProtectedString name="Source"><![CDATA[----------------------------- Signal Module -----------------------------
-- > Used to create, connect, wait and destroy signals.
-- > Created by Quenty
-----------------------------------------------------------------------------------------

--- Lua-side duplication of the API of events on Roblox objects.
-- Signals are needed for to ensure that for local events objects are passed by
-- reference rather than by value where possible, as the BindableEvent objects
-- always pass signal arguments by value, meaning tables will be deep copied.
-- Roblox's deep copy method parses to a non-lua table compatable format.
-- @classmod Signal

local Signal = {}
Signal.__index = Signal
Signal.ClassName = "Signal"

--- Constructs a new signal.
-- @constructor Signal.new()
-- @treturn Signal
function Signal.new()
	local self = setmetatable({}, Signal)

	self._bindableEvent = Instance.new("BindableEvent")
	self._argData = nil
	self._argCount = nil -- Prevent edge case of :Fire("A", nil) --> "A" instead of "A", nil

	return self
end

--- Fire the event with the given arguments. All handlers will be invoked. Handlers follow
-- Roblox signal conventions.
-- @param ... Variable arguments to pass to handler
-- @treturn nil
function Signal:Fire(...)
	self._argData = { ... }
	self._argCount = select("#", ...)
	self._bindableEvent:Fire()
	self._argData = nil
	self._argCount = nil
end

--- Connect a new handler to the event. Returns a connection object that can be disconnected.
-- @tparam function handler Function handler called with arguments passed when `:Fire(...)` is called
-- @treturn Connection Connection object that can be disconnected
function Signal:Connect(handler)
	if not (type(handler) == "function") then
		error(("connect(%s)"):format(typeof(handler)), 2)
	end

	return self._bindableEvent.Event:Connect(function()
		handler(unpack(self._argData, 1, self._argCount))
	end)
end

--- Wait for fire to be called, and return the arguments it was given.
-- @treturn ... Variable arguments from connection
function Signal:Wait()
	self._bindableEvent.Event:Wait()
	assert(self._argData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
	return unpack(self._argData, 1, self._argCount)
end

--- Disconnects all connected events to the signal. Voids the signal as unusable.
-- @treturn nil
function Signal:Destroy()
	if self._bindableEvent then
		self._bindableEvent:Destroy()
		self._bindableEvent = nil
	end

	self._argData = nil
	self._argCount = nil
end

return Signal]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXea807bda3d7e491291b200ca4510ad4d">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SliderFuncs</string>
									<string name="ScriptGuid">{419d2d24-fef3-488d-8379-c42e854a6588}</string>
									<ProtectedString name="Source"><![CDATA[local SliderFuncs = {}

function SliderFuncs.snapToScale(val: number, step: number): number
	return math.clamp(math.round(val / step) * step, 0, 1)
end

function lerp(start: number, finish: number, percent: number): number
	return (1 - percent) * start + percent * finish
end

function SliderFuncs.map(
	value: number,
	start: number,
	stop: number,
	newStart: number,
	newEnd: number,
	constrain: boolean
): number
	local newVal = lerp(newStart, newEnd, SliderFuncs.getAlphaBetween(start, stop, value))
	if not constrain then
		return newVal
	end

	if newStart < newEnd then
		newStart, newEnd = newEnd, newStart
	end

	return math.max(math.min(newVal, newStart), newEnd)
end

function SliderFuncs.getNewPosition(self): UDim2
	local absoluteSize = self._data.Button.AbsoluteSize[self._config.Axis]
	local holderSize = self._holder.AbsoluteSize[self._config.Axis]

	local anchorPoint = self._data.Button.AnchorPoint[self._config.Axis]

	local paddingScale = (self._config.Padding / holderSize)

	local minScale = ((anchorPoint * absoluteSize) / holderSize + paddingScale)
	local decrement = ((2 * absoluteSize) * anchorPoint) - absoluteSize
	local maxScale = (1 - minScale) + (decrement / holderSize)

	local newPercent = SliderFuncs.map(self._data._percent, 0, 1, minScale, maxScale, true)

	return if self._config.Axis == "X"
		then UDim2.fromScale(newPercent, self._data.Button.Position.Y.Scale)
		else UDim2.fromScale(self._data.Button.Position.X.Scale, newPercent)
end

function SliderFuncs.getScaleIncrement(self)
	return 1 / ((self._config.SliderData.End - self._config.SliderData.Start) / self._config.SliderData.Increment)
end

function SliderFuncs.getAlphaBetween(a: number, b: number, c: number): number
	return (c - a) / (b - a)
end

function SliderFuncs.getNewValue(self)
	local newValue = lerp(self._config.SliderData.Start, self._config.SliderData.End, self._data._percent)
	local incrementScale = (1 / self._config.SliderData.Increment)

	newValue = math.round(newValue * incrementScale) / incrementScale
	return newValue
end

return SliderFuncs]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX1f3d1ec38b5d4c40889b20d0cae5000a">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BeatSync</string>
						<string name="ScriptGuid">{fd231848-5115-4014-9b33-46017574b9f4}</string>
						<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local SoundService = game:GetService("SoundService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Interface = ReplicatedStorage:WaitForChild("Interface")
local Handlers_Interface = require(Interface.Handlers.Handlers_Interface)

local Metronome = Instance.new("Sound")
Metronome.Name = "Metronome"
Metronome.SoundId = "rbxassetid://110068113267695"
Metronome.Volume = 2
Metronome.Parent = SoundService

local FirstBeat = 0

-- Dynamic Latency Calculation based on the current frame's difference
local function CalculateLatency()
	local ping = Players.LocalPlayer:GetNetworkPing()
	return ping / 1000 -- Convert ms to seconds
end

local function AdjustForLatency(Keyframe, BPM, latency)
	local BeatInterval = 60 / BPM
	local adjustedTime = math.max(Keyframe.Time - latency, 0)
	return adjustedTime
end

local BeatSync = {
	Cycles = {},
	BPM = 150,
	Sound = nil,
	BeatCounter = 0,
	BeatInterval = 60 / 150,
	SixteenthNoteCounter = 0,
	SixteenthNoteInterval = (60 / 150) / 4,
	TotalBars = 0,
	CurrentBar = 1,
	CurrentBeat = 1,
	SongChanged = Instance.new("BindableEvent"),
	SixteenthNoteChanged = Instance.new("BindableEvent"),
	BeatChanged = Instance.new("BindableEvent"),
	BarChanged = Instance.new("BindableEvent"),
}

function BeatSync.Run()
	local accumulator = 0
	local connection
	connection = RunService.Heartbeat:Connect(function(deltaTime)
		if not BeatSync.Sound then
			return
		end

		accumulator = accumulator + deltaTime
		if accumulator >= BeatSync.SixteenthNoteInterval then
			accumulator = accumulator - BeatSync.SixteenthNoteInterval
			BeatSync.IncrementSixteenthNote()
		end
	end)

	return function()
		if connection then
			connection:Disconnect()
		end
	end
end

function BeatSync.Insert(Cycle)
	table.insert(BeatSync.Cycles, Cycle)
end

function BeatSync.ReportSongPosition()
	if BeatSync.CurrentBar <= BeatSync.TotalBars then
		local totalBeats = BeatSync.TotalBars * 4
		local completedBeats = (BeatSync.CurrentBar - 1) * 4 + BeatSync.BeatCounter - 1
		local percentage = (completedBeats / totalBeats) * 100
	end
end

function BeatSync.IncrementBeat()
	BeatSync.BeatCounter = BeatSync.BeatCounter % 4 + 1
	BeatSync.CurrentBeat = (BeatSync.CurrentBar - 1) * 4 + BeatSync.BeatCounter
	BeatSync.BeatChanged:Fire(BeatSync.BeatCounter, 60 / (BeatSync.BPM or 120))

	if BeatSync.BeatCounter == 1 then
		BeatSync.CurrentBar = BeatSync.CurrentBar + 1
		BeatSync.BarChanged:Fire(BeatSync.CurrentBar)
	end

	BeatSync.ReportSongPosition()
end

function BeatSync.IncrementSixteenthNote()
	local currentTime = BeatSync.Sound.TimePosition

	if currentTime < FirstBeat then
		return
	end

	local totalSixteenthNotes = currentTime / BeatSync.SixteenthNoteInterval
	BeatSync.SixteenthNoteCounter = math.floor(totalSixteenthNotes % 16)
	BeatSync.SixteenthNoteChanged:Fire(BeatSync.SixteenthNoteCounter)

	if BeatSync.SixteenthNoteCounter % 4 == 1 then
		BeatSync.IncrementBeat()
	end
end

function BeatSync.CalculateTotalBars(trackDuration)
	BeatSync.TotalBars = math.ceil(trackDuration / (BeatSync.BeatInterval * 4))
	BeatSync.CurrentBar = 1
	BeatSync.CurrentBeat = 1
end

function BeatSync.Play(Track, BPM, StartDelay)
	StartDelay = StartDelay or 0
	BeatSync.Sound = Track
	BeatSync.BPM = BPM
	BeatSync.BeatCounter = 0
	BeatSync.BeatInterval = 60 / (BeatSync.BPM or 120)
	BeatSync.SixteenthNoteInterval = BeatSync.BeatInterval / 4

	if not Track.IsReady then
		Track:GetPropertyChangedSignal("IsReady"):Wait()
	end

	local trackDuration = Track.TimeLength
	BeatSync.CalculateTotalBars(trackDuration)
	Track.TimePosition = StartDelay
	Track:Play()
end

BeatSync.Run()

return BeatSync]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXe9faa59db0e6406cab264d8db9e8f583">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Scheduler</string>
						<string name="ScriptGuid">{b21d1e56-8add-4d1c-a9f5-548d173a235f}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Class
local Scheduler = {}
Scheduler.__index = Scheduler

function Scheduler.new()
	local info = {
		Connections = {},
	}
	setmetatable(info, Scheduler)
	return info
end

function Scheduler:Init() end

function Scheduler:Disconnect()
	for _, c: RBXScriptConnection in pairs(self.Connections) do
		c:Disconnect()
	end
end

function Scheduler:Destroy()
	self:Disconnect()

	setmetatable(self, nil)
	table.clear(self)
	table.freeze(self)
end

function Scheduler:ListenForSongChange(beatSync)
	local songChangedConnection
	songChangedConnection = beatSync.SongChanged.Event:Connect(function()
		self:Destroy()
		songChangedConnection:Disconnect()
	end)
	table.insert(self.Connections, songChangedConnection)
end

function Scheduler:SyncToSixteenthNote(beatSync, callback)
	local connection = beatSync.SixteenthNoteChanged.Event:Connect(callback)
	table.insert(self.Connections, connection)
end

function Scheduler:SyncToBeat(beatSync, callback)
	local connection = beatSync.BeatChanged.Event:Connect(callback)
	table.insert(self.Connections, connection)
end

function Scheduler:SyncToBar(beatSync, callback)
	local connection = beatSync.BarChanged.Event:Connect(callback)
	table.insert(self.Connections, connection)
end

return Scheduler]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX996f8d87b4634e39bed3a90f2bb556cb">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Util</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX108cfc6ca2c648a4a2b3480dd988b496">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Instween</string>
						<string name="ScriptGuid">{22aa5d8c-4556-482b-b399-115d52dd640b}</string>
						<ProtectedString name="Source"><![CDATA[--[[
Tween

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = Tween.TopLevel('foo')
    print(foobar.Thing)

DESCRIPTION

    A detailed description of the module.

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of Tween.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

--// module
local Tween = {}

function Tween.new(Object: Instance, Changes: table, Time: number, Settings: table)
	Settings = Settings or {}

	if Settings.Reversing then
		local test = if Settings.Reversing ~= nil then Settings.Reversing else false
	end

	local Info = TweenInfo.new(
		Time,
		Settings.EasingStyle or Enum.EasingStyle.Linear, -- EasingStyle
		Settings.EasingDirection or Enum.EasingDirection.Out, -- EasingDirection
		Settings.TimesRepeated or 0, -- Times repeteated
		if Settings.Reversing ~= nil then Settings.Reversing else false, -- Reversing
		Settings.Delay or 0 -- Time Delay
	)
	local Action = TweenService:Create(Object, Info, Changes)
	return Action
end

return Tween]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXa9bde3d862fc44568589a679bb03d9f3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Lerp</string>
						<string name="ScriptGuid">{2c4b4d71-45e2-4e7b-b451-9d54d41a5445}</string>
						<ProtectedString name="Source"><![CDATA[--[[
Lerp

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = Lerp.TopLevel('foo')
    print(foobar.Thing)

DESCRIPTION

    A detailed description of the module.

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of Lerp.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

--// module
local Lerp = {}

function DefaultLerpLerp(a, b, t)
	return a + (b - a) * t
end

function Lerp.KeyValue(array, key, goal: number, t: number)
	local timepassed: number = 0
	while timepassed <= t do
		timepassed = timepassed + RunService.RenderStepped:Wait()
		array[key] = DefaultLerpLerp(array[key], goal, timepassed / t)
		-- part.CFrame = start:Lerp(goal,timepassed/t)
	end
end

function Lerp.CFrame(part: BasePart | MeshPart | Camera, goal: CFrame, t: number)
	local timepassed: number = 0
	local start: CFrame = part.CFrame
	while timepassed <= t do
		timepassed = timepassed + RunService.RenderStepped:Wait()
		part.CFrame = start:Lerp(goal, timepassed / t)
	end
end

function Lerp.Size(part: BasePart | MeshPart, goal: Vector3, t: number, reversing: boolean)
	local timepassed: number = 0
	local start: Vector3 = part.Size
	while timepassed <= t do
		timepassed = timepassed + RunService.RenderStepped:Wait()
		part.Size = start:Lerp(goal, timepassed / t)
	end

	timepassed = 0

	if reversing then
		while timepassed <= t do
			timepassed = timepassed + RunService.RenderStepped:Wait()
			part.Size = part.Size:Lerp(start, timepassed / t)
		end
	end
end

function Lerp.CFrameAndSize(part: BasePart | MeshPart, goalCF: CFrame, goalV3: Vector3, t: number)
	local timepassed: number = 0
	local startV3: Vector3 = part.Size
	local startCF: CFrame = part.CFrame
	while timepassed <= t do
		timepassed = timepassed + RunService.RenderStepped:Wait()
		part.CFrame = startCF:Lerp(goalCF, timepassed / t)
		part.Size = startV3:Lerp(goalV3, timepassed / t)
	end
end

function Lerp.new(...)
	Lerp.CFrame(...)
end

return Lerp]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXd971c587f2814a0f884913217c7dd5a8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TimeSorter</string>
						<string name="ScriptGuid">{1418d6ed-4d89-4684-8461-76c3df9c1dc0}</string>
						<ProtectedString name="Source"><![CDATA[-- liked_at_sorter.lua

local liked_at_sorter = {}

-- Function to convert ISO 8601 liked_at to a comparable format
local function parse_liked_at(ts)
	local pattern = "(%d+)-(%d+)-(%d+)T(%d+):(%d+):(%d+).(%d+)Z"
	local year, month, day, hour, min, sec, msec = ts:match(pattern)
	return os.time({ year = year, month = month, day = day, hour = hour, min = min, sec = sec }) + (msec / 1000)
end

-- Function to sort a dictionary of dictionaries by liked_ats
function liked_at_sorter.sort_by_liked_at(data)
	-- Extract keys and sort them based on liked_ats
	local keys = {}
	for k in pairs(data) do
		table.insert(keys, k)
	end

	table.sort(keys, function(a, b)
		return parse_liked_at(data[a].liked_at) < parse_liked_at(data[b].liked_at)
	end)

	-- Create a new sorted dictionary
	local sorted_data = {}
	for _, k in ipairs(keys) do
		sorted_data[k] = data[k]
	end

	return sorted_data
end

return liked_at_sorter.sort_by_liked_at]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="StringValue" referent="RBX7cd3c71e639c49e8ab88de17f34bb0bd">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Developer_API_Key</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<string name="Value">AeQ4lrVjX31Giir84cipc6ZXD0FXtnMQagqN7WqS</string>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXb03b0a74dd6847f0a0494c51cf304f96">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Server</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{d4cc29b3-2e5e-46da-bb51-75b0db143ed9}</string>
				<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Tuesday July 9th 2024 10:22:26 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 12:31:09 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
-- Implementation of Interface.

--// Services
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Events
local Events = require(script.Events)

--// Modules
local AudioAssembly = require(script.Modules.AudioAssembly)

--// Types
local Types = require(script.Types)

--// Init
local Interface, Packages = script.Parent.Interface, script.Parent.BoomBoxPackages
Interface.Parent, Packages.Parent = ReplicatedStorage, ReplicatedStorage

local Configuration = script.Parent.AttributeConfiguration

type Settings = {
	game_id: number,
	settings: {
		accentColour: string,
		position: {
			x: number,
			y: number,
		},
		volume: number,
		draggingEnabled: boolean,
	},
}

local DefaultSettings = {
	game_id = game.PlaceId,
	settings = {
		accentColour = "#FFFFFFF",
		position = {
			x = 1,
			y = 0.5,
		},
		volume = 1,
		draggingEnabled = false,
	},
} :: Settings

local Settings = {
	game_id = game.PlaceId,
	settings = {
		accentColour = "#FFFFFFF",
		position = {
			x = 1,
			y = 0.5,
		},
		volume = 1,
		draggingEnabled = false,
	},
} :: Settings

--// Private Functions
local function CreateClient(Player: Player)
	local PlayerGui = Player:FindFirstChild("PlayerGui") :: PlayerGui

	if PlayerGui and PlayerGui:FindFirstChild("BoomBoxClient") then
		return
	end

	local BoomBoxClient = script.Parent.Client:Clone() :: ModuleScript
	BoomBoxClient.Name = "BoomBoxClient"

	BoomBoxClient:SetAttribute("Autoplay", Configuration:GetAttribute("Autoplay"))
	BoomBoxClient:SetAttribute("Minimized", Configuration:GetAttribute("Minimized"))
	BoomBoxClient:SetAttribute("MaxVolume", Configuration:GetAttribute("MaxVolume"))
	BoomBoxClient:SetAttribute(
		"DraggingEnabled",
		Settings.settings.draggingEnabled or DefaultSettings.settings.draggingEnabled
	)
	BoomBoxClient:SetAttribute(
		"DefaultPosition",
		Configuration:GetAttribute("DefaultPosition")
		-- Vector2.new(
		-- 	Settings.settings.position.x or DefaultSettings.settings.position.x,
		-- 	Settings.settings.position.y or DefaultSettings.settings.position.y
		-- )
	)
	BoomBoxClient:SetAttribute("DefaultAccentColor", Color3.fromHex(Settings.settings.accentColour))
	BoomBoxClient:SetAttribute("SearchEnabled", Configuration:GetAttribute("SearchEnabled"))

	BoomBoxClient.Parent = Player:WaitForChild("PlayerGui")
	BoomBoxClient.Initialize.Enabled = true
end

--// API
local API = script.API

for i, v in pairs(API:GetChildren()) do
	require(v)(Events)
end

--// Settings
Settings = HttpService:JSONDecode(Events.PriortiyServerAudioscape:Invoke(nil, "settings", {}))

--// Loading For Clients
Players.PlayerAdded:Connect(function(Player: Player)
	CreateClient(Player)
end)

for _, Player in Players:GetPlayers() do
	CreateClient(Player)
end

--// Type
type BoomboxState = {
	Sound: Sound,
	SoundProperties: {
		Volume: number,
		AssetId: string,
		Playing: boolean,
		TimePosition: number,
	},
}

--// Boombox Remotes
local BoomBoxSounds = {}
local BoomBoxStates = {}
local BoomBoxVisuals = {}
local BoomBoxConnections = {}
--// Visuals For Clients
local function AddBoomBoxVisual(Player: Player, Character: Model)
	local Boombox = script:FindFirstChild("BoomBox") :: Types.BoomBox
	if not Boombox then
		return
	end

	local Back: BasePart? = Character:WaitForChild("UpperTorso") or Character:WaitForChild("HumanoidRootPart")

	if not Back then
		return
	end

	Boombox = Boombox:Clone() :: Types.BoomBox

	local Weld = Instance.new("Weld")
	Weld.Part0 = Boombox
	Weld.Part1 = Back
	Weld.C0 = CFrame.new((-Back.Size.Z / 2) - (Boombox.Size.X / 2), 0, 0)
		* CFrame.fromEulerAnglesXYZ(0, math.pi / 2, math.pi / 4)

	Weld.Parent = Boombox

	Boombox.Parent = Character

	Boombox.AudioPlayer:Destroy()
	Boombox.AudioFader:Destroy()

	AudioAssembly.CreateLayers(Player, Boombox, { "AudioFader", "AudioPitchShifter", "AudioReverb", "AudioEqualizer" })

	BoomBoxSounds[Player] = AudioAssembly.AudioPlayers[Player.UserId]
	AudioAssembly.CreateSpeakers(AudioAssembly.LayerNerveEndings[Player.UserId], Boombox)

	return Boombox
end

Events.ToggleBoombox.OnServerEvent:Connect(function(Player: Player, ToggleActive: boolean)
	if BoomBoxConnections[Player] and not ToggleActive then
		BoomBoxConnections[Player]:Disconnect()
		BoomBoxVisuals[Player]:Destroy()
		return
	end

	local Character = Player.Character or Player.CharacterAdded:Wait()

	BoomBoxConnections[Player] = Player.CharacterAdded:Connect(function(_Character)
		_Character.Destroying:Once(function()
			BoomBoxVisuals[Player]:Destroy()
		end)
		BoomBoxVisuals[Player] = AddBoomBoxVisual(Player, _Character)
	end)

	BoomBoxVisuals[Player] = AddBoomBoxVisual(Player, Character)

	local BoomboxState = Events.BoomboxStateRetrieval:InvokeClient(Player, true) :: BoomboxState

	BoomBoxStates[Player] = BoomboxState
	BoomBoxSounds[Player].AssetId = BoomboxState.SoundProperties.AssetId
	BoomBoxSounds[Player].Volume = BoomboxState.SoundProperties.Volume

	local AudioPreset = BoomboxState.SoundProperties.AudioPreset

	AudioAssembly.ApplyPreset(Player, "AudioReverb", AudioPreset)
	AudioAssembly.ApplyPreset(Player, "AudioPlayer", AudioPreset)
	AudioAssembly.ApplyPreset(Player, "AudioFader", AudioPreset)

	if BoomboxState.SoundProperties.Playing then
		BoomBoxSounds[Player]:Play()
	else
		BoomBoxSounds[Player]:Stop()
	end

	BoomBoxSounds[Player].TimePosition = BoomboxState.SoundProperties.TimePosition
end)

Events.BoomboxEvent.OnServerEvent:Connect(function(Player: Player, Event: string, BoomboxState: BoomboxState, ...)
	local BoomboxSound = BoomBoxSounds[Player] :: AudioPlayer?

	if not BoomboxState or not BoomboxSound then
		return
	end

	if Event == "Play" then
		BoomboxSound.AssetId = BoomboxState.SoundProperties.AssetId
		BoomboxSound.TimePosition = BoomboxState.SoundProperties.TimePosition
		BoomboxSound:Play()
	elseif Event == "Resume" then
		BoomboxSound.TimePosition = BoomboxState.SoundProperties.TimePosition
		BoomboxSound:Play()
	elseif Event == "Pause" then
		BoomboxSound.TimePosition = BoomboxState.SoundProperties.TimePosition
		BoomboxSound:Stop()
	elseif Event == "Volume" then
		BoomboxSound.Volume = BoomboxState.SoundProperties.Volume
	elseif Event == "TimeChange" then
		BoomboxSound.TimePosition = BoomboxState.SoundProperties.TimePosition
	elseif Event == "ApplyPreset" then
		local AudioPreset = BoomboxState.SoundProperties.AudioPreset

		AudioAssembly.ApplyPreset(Player, "AudioReverb", AudioPreset)
		AudioAssembly.ApplyPreset(Player, "AudioPlayer", AudioPreset)
		AudioAssembly.ApplyPreset(Player, "AudioFader", AudioPreset)
	end
end)]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXc0af537809eb4e109e733c5da85b9be3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">API</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX05709db438e8499fae7a7d1566c7131c">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">API_Operations</string>
						<string name="ScriptGuid">{014b238d-2b3d-454c-8d99-50d4cf3a3f19}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local Players = game:GetService("Players")

--// Debug
local Debug = require(script.Parent.Parent.Debug)

--// Events
local Events = require(script.Parent.Parent.Events)

--// Return
return function(Remotes: Events.Remotes)
	require(script.Operations).new(Remotes)
	-- game:BindToClose(function()
	-- 	for _, Player in Players:GetPlayers() do
	-- 	end
	-- end)

	-- Players.PlayerRemoving:Connect(function(Player) end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX0ca3e1272c654f6584dc2d2eb45d3f64">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GlobalDatabase</string>
							<string name="ScriptGuid">{f65789e9-a2ae-4e7d-927a-a1462543a845}</string>
							<ProtectedString name="Source"><![CDATA[-- Implementation of GlobalDatabase.

--// Services
local DataStoreService = game:GetService("DataStoreService")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Global Data Store
local DataHeader = script.Parent.Parent.Parent.DataHeader.Value
local DataStoreVersion = script.Parent.Parent.Parent.DataStoreVersion.Value
local GlobalDataStore = DataStoreService:GetDataStore(`{DataHeader}.{DataStoreVersion}`)

--// Debug
local Debug = require(script.Parent.Parent.Parent.Debug)

--// Events
local Events = require(script.Parent.Parent.Parent.Events)

--// Class
local GlobalDatabase = {}
GlobalDatabase.__index = GlobalDatabase

function GlobalDatabase.new()
	local info = {
		Connections = {},
	}
	setmetatable(info, GlobalDatabase)
	return info
end

function GlobalDatabase:Init(Remotes: Events.Remotes, LifeCycleHook: {})
	task.spawn(function()
		self:PopulateGenres(Remotes)
	end)

	if Debug.GlobalDatabaseDebug then
		print(LifeCycleHook)
	end

	self.LifeCycleHook = LifeCycleHook
	self:LifeCycle()
end

function GlobalDatabase:LifeCycle()
	local GenereUpdateInterval = 60 * 5
	local Accumulator = 0
	table.insert(self.LifeCycleHook, function(acumulator: number, BATCH_UPDATE_INTERVAL: number, dt: number)
		Accumulator += dt
		if Accumulator >= GenereUpdateInterval then
			Accumulator = 0
			self:UpdateGenres()
		end
	end)
end

function GlobalDatabase:UpdateGenres()
	task.spawn(function()
		local Genres = Events.ServerAudioscape:Invoke(nil, "genres", {})
		GlobalDataStore:SetAsync("Genres", Genres)
	end)

	task.spawn(function()
		local Emotions = Events.ServerAudioscape:Invoke(nil, "emotions", {})
		GlobalDataStore:SetAsync("Emotions", Emotions)
	end)
end

function GlobalDatabase:PopulateGenres(Remotes: Events.Remotes)
	local Genres = Events.PriortiyServerAudioscape:Invoke(nil, "genres", {})
	local Emotions = Events.PriortiyServerAudioscape:Invoke(nil, "emotions", {})

	GlobalDataStore:SetAsync("Genres", Genres)
	GlobalDataStore:SetAsync("Emotions", Emotions)

	for _, GenreName in pairs(HttpService:JSONDecode(Genres)) do
		if Debug.OperationsDebug then
			print("Populating Global Data Store with " .. GenreName)
		end

		local Songs = Remotes.ServerAudioscape:Invoke(nil, "search", {
			genre = GenreName,
			limit = 1000,
		}) :: string -- JSON

		GlobalDataStore:SetAsync(GenreName, Songs)

		if Debug.OperationsDebug then
			print("Populated Global Data Store with " .. GenreName)
		end
	end
end

function GlobalDatabase:PopulateEmotions() end

function GlobalDatabase:Disconnect()
	for _, c: RBXScriptConnection in pairs(self.Connections) do
		c:Disconnect()
	end
end

function GlobalDatabase:Destroy()
	self:Disconnect()

	setmetatable(self, nil)
	table.clear(self)
	table.freeze(self)
end

return GlobalDatabase.new()]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX12e3e88dccb649df941c6948463c4d0e">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">NetworkFunnel</string>
							<string name="ScriptGuid">{25a31e1b-bae6-4507-96a9-a68dedfdeefd}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local HttpService = game:GetService("HttpService") -- Used for generating GUIDs and handling JSON encoding/decoding
local DataStoreService = game:GetService("DataStoreService") -- Handles persistent data storage
local ReplicatedStorage = game:GetService("ReplicatedStorage") -- Stores shared game objects across server and clients

--// Global Data Store
local DataHeader = script.Parent.Parent.Parent.DataHeader.Value -- Header used to identify the DataStore
local DataStoreVersion = script.Parent.Parent.Parent.DataStoreVersion.Value -- Version of the DataStore used
local GlobalDataStore = DataStoreService:GetDataStore(`{DataHeader}.{DataStoreVersion}`) -- Retrieves the global DataStore based on header and version

--// Debug
local Debug = require(script.Parent.Parent.Parent.Debug) -- Debug module for logging network activity

--// Events
local Events = require(script.Parent.Parent.Parent.Events) -- Handles remote events and communication

--// Capitalize The First Letter of A String
-- Utility function to capitalize the first letter of a string
local function capitalize(str: string): string
	return str:gsub("^%l", string.upper)
end

--// Class
local NetworkFunnel = {}
NetworkFunnel.__index = NetworkFunnel

-- Constructor for NetworkFunnel
-- Sets up batch IDs and tracking for different types of requests
function NetworkFunnel.new()
	local StarterBatchLikeID = HttpService:GenerateGUID(false) -- Generate unique batch ID for 'like'
	local StarterBatchLikesID = HttpService:GenerateGUID(false) -- Generate unique batch ID for 'likes'
	local StarterBatchUnlikeID = HttpService:GenerateGUID(false) -- Generate unique batch ID for 'unlike'
	local StarterBatchTelemetryID = HttpService:GenerateGUID(false) -- Generate unique batch ID for 'telemetry'

	local info = {
		Connections = {}, -- Stores connections to lifecycle hooks
		BatchIDs = { -- Stores current and previous batch IDs
			batchLike = {
				current = StarterBatchLikeID,
				previous = {},
			},
			batchLikes = {
				current = StarterBatchLikesID,
				previous = {},
			},
			batchUnlike = {
				current = StarterBatchUnlikeID,
				previous = {},
			},
			batchTelemetry = {
				current = StarterBatchTelemetryID,
				previous = {},
			},
		},
		RequestBatches = { -- Stores pending requests to be processed
			batchLike = {},
			batchLikes = {},
			batchUnlike = {},
			batchTelemetry = {},
			batchLikeLastRequest = 0, -- Timestamp of last batch request
			batchLikesLastRequest = 0,
			batchUnlikeLastRequest = 0,
			batchTelemetryLastRequest = 0,
		},
		BatchHistory = { -- Stores the history of batches that have been processed
			batchLike = {},
			batchLikes = {},
			batchUnlike = {},
			batchTelemetry = {},
		},
	}
	setmetatable(info, NetworkFunnel)
	return info
end

-- Initialize NetworkFunnel by setting up lifecycle hooks and remote events
function NetworkFunnel:Init(Remotes: Events.Remotes, LifeCycleHook: {}, BATCH_UPDATE_INTERVAL: number)
	self.Remotes = Remotes -- Reference to remote events
	self.LifeCycleHook = LifeCycleHook -- Reference to lifecycle hooks for periodic batch processing

	self:LifeCycle() -- Starts the lifecycle management
end

-- Returns the batch history
function NetworkFunnel:GetAllBatchHistory()
	return self.BatchHistory
end

-- Lifecycle method for handling batch updates at regular intervals
-- Checks and processes batch requests when the accumulator exceeds the interval
function NetworkFunnel:LifeCycle()
	table.insert(self.LifeCycleHook, function(acumulator: number, BATCH_UPDATE_INTERVAL: number, dt: number)
		if acumulator >= BATCH_UPDATE_INTERVAL then -- Process batch if accumulator exceeds the update interval
			for batchName, Batch in self.RequestBatches do
				if typeof(Batch) ~= "table" or #Batch == 0 then
					continue -- Skip if there's no batch or the batch is empty
				end

				local BatchID = self.BatchIDs[batchName].current -- Get the current batch ID

				-- Debug log: Print information about the batch being processed
				if Debug.NetworkFunnelDebug then
					print(`Shipping Batch: {batchName} - {Batch}`)
					print(`Last Request: {self.RequestBatches[batchName .. "LastRequest"]}`)
					print(`{batchName} .. "LastRequest"`)
					print(`Time Since Last Request: {tick() - self.RequestBatches[batchName .. "LastRequest"]}`)
				end

				-- Ensure enough time has passed since the last batch request
				if (tick() - self.RequestBatches[batchName .. "LastRequest"]) > 5 then
					self.RequestBatches[batchName .. "LastRequest"] = tick() -- Update timestamp of the last request
				else
					-- Debug log: Skip processing if the request was sent too recently
					if Debug.NetworkFunnelDebug then
						print(`Skipping Batch: {batchName} - {Batch}`)
					end
					continue
				end

				-- Set the batch ID
				self:SetBatchID(batchName)

				-- Send the batch to the server and handle success or failure
				local Success = self.Remotes.ServerAudioscape:Invoke(nil, batchName, Batch)

				if not Success then
					print(`Failed to ship batch: {batchName} - {Batch}`) -- Log failure
				else
					self.BatchHistory[batchName][BatchID] = Success -- Store the success in batch history

					-- Debug log: Print shipped batch and batch history
					if Debug.NetworkFunnelDebug then
						print(`Shipped Batch: {batchName} - {Batch}`)
						warn(`Batch History:`)
						print(self.BatchHistory)
					end
				end

				self.RequestBatches[batchName] = {} -- Clear the batch after it has been processed
			end
		end
	end)
end

-- Handles genre request and stores the result in the global data store
function NetworkFunnel:HandleGenreRequest(Player: Player, Action: string, Payload: string | { [any]: any })
	local Remotes = self.Remotes
	Payload.limit = 1000 -- Set the limit of returned songs

	local Songs = Remotes.ServerAudioscape:Invoke(nil, Action, Payload) :: string -- Fetch songs from the server
	local GenreStoreName = capitalize(Payload.genre) -- Capitalize the genre name

	GlobalDataStore:SetAsync(GenreStoreName, Songs) -- Store the songs in the global data store

	return Songs -- Return the result
end

-- Handles emotion request and stores the result in the global data store
function NetworkFunnel:HandleEmotionRequest(Player: Player, Action: string, Payload: string | { [any]: any })
	local Remotes = self.Remotes
	Payload.limit = 1000 -- Set the limit of returned songs

	local Songs = Remotes.ServerAudioscape:Invoke(nil, Action, Payload) :: string -- Fetch songs from the server
	local GenreStoreName = capitalize(`{Payload.genre}_{Payload.emotion}`) -- Capitalize genre and emotion

	GlobalDataStore:SetAsync(GenreStoreName, Songs) -- Store the songs in the global data store

	return Songs -- Return the result
end

-- Processes global requests such as fetching genres, emotions, likes, and handling search requests
function NetworkFunnel:RequestFromGlobal(Player: Player, Action: string, Payload: string | { [any]: any })
	if Action == "genres" then
		if Debug.GlobalDatabaseGenereUpdateDebug then
			print(`Requesting Genres from Global DataStore: {GlobalDataStore:GetAsync("Genres")}`)
		end

		return GlobalDataStore:GetAsync("Genres") -- Fetch and return genres
	elseif Action == "emotions" then
		return GlobalDataStore:GetAsync("Emotions") -- Fetch and return emotions
	elseif Action == "search" then
		-- Fetch results based on genre and emotion from the global data store
		if not Payload.emotion then
			local Result = GlobalDataStore:GetAsync(Payload.genre) or self:HandleGenreRequest(Player, Action, Payload)
			return Result
		else
			local GenreStoreName = capitalize(`{Payload.genre}_{Payload.emotion}`)
			local Result = GlobalDataStore:GetAsync(GenreStoreName)
				or self:HandleEmotionRequest(Player, Action, Payload)
			return Result
		end
	elseif Action == "like" then
		-- Add a like request to the batch
		if Debug.NetworkFunnelDebug then
			print(`Adding '{Action}' Request to Batch: {Payload.asset_id}`)
		end

		local BatchID = self:GetBatchID("batchLike")

		table.insert(self.RequestBatches.batchLike, {
			user_id = Player.UserId,
			asset_id = tonumber(Payload.asset_id),
		})

		self:HandleBatchYield(Player, "batchLike", BatchID)

		if Debug.NetworkFunnelDebug then
			warn("Like Request Result:")
			print(HttpService:JSONDecode(self.BatchHistory.batchLike[BatchID]))
		end

		return false
	elseif Action == "unlike" then
		-- Add a like request to the batch
		if Debug.NetworkFunnelDebug then
			print(`Adding '{Action}' Request to Batch: {Payload.asset_id}`)
		end

		local BatchID = self:GetBatchID("batchUnlike")

		table.insert(self.RequestBatches.batchUnlike, {
			user_id = Player.UserId,
			asset_id = tonumber(Payload.asset_id),
		})

		self:HandleBatchYield(Player, "batchUnlike", BatchID)

		if Debug.NetworkFunnelDebug then
			warn("Unlike Request Result:")
			print(HttpService:JSONDecode(self.BatchHistory.batchUnlike[BatchID]))
		end

		return false
	elseif Action == "likes" then
		-- Handle likes request
		return self:HandleLikesRequest(Player, Action, Payload)
	elseif Action == "telemetry" then
		-- Add a like request to the batch
		if Debug.NetworkFunnelDebug then
			print(`Adding '{Action}' Request to Batch: {Payload.asset_id}`)
		end

		local BatchID = self:GetBatchID("batchTelemetry")

		local temp_data = {}

		for i, v in pairs(Payload) do
			temp_data[i] = v
		end

		temp_data["user_id"] = tostring(Player.UserId)
		temp_data["asset_id"] = tonumber(Payload.asset_id)

		table.insert(self.RequestBatches.batchTelemetry, temp_data)

		--table.insert(self.RequestBatches.batchTelemetry, {
		--	user_id = Player.UserId,
		--	asset_id = tonumber(Payload.asset_id),
		--	event_type = Payload.event_type
		--})

		self:HandleBatchYield(Player, "batchTelemetry", BatchID)

		if Debug.NetworkFunnelDebug then
			warn("Like Request Result:")
			print(HttpService:JSONDecode(self.BatchHistory.batchTelemetry[BatchID]))
		end

		return false
	end
end

function NetworkFunnel:HandleBatchYield(Player: Player, BatchName: string, BatchID: string)
	-- Wait until the batch has been processed and available in the history
	repeat
		task.wait()
	until self.BatchHistory[BatchName][BatchID]
		and (self.BatchIDs[BatchName].current == BatchID or self.BatchIDs[BatchName].previous[BatchID])
end

-- Handles processing of 'likes' requests
function NetworkFunnel:HandleLikesRequest(Player: Player, Action: string, Payload: string | { [any]: any })
	if Debug.NetworkFunnelDebug then
		print(`Adding Likes Request to Batch: {Player.UserId}`)
	end

	local BatchID = self.BatchIDs.batchLikes.current -- Get current batch ID for 'likes'

	table.insert(self.RequestBatches.batchLikes, Player.UserId) -- Add the player's like request to the batch

	-- Wait until the batch has been processed and available in the history
	self:HandleBatchYield(Player, "batchLikes", BatchID)

	if Debug.NetworkFunnelDebug then
		warn("Likes Request Result:")
		print()
	end

	-- Iterate through the decoded batch history and find the player's likes
	for i, v: { likes: { [number]: { [string]: any } }, user_id: string } in
		HttpService:JSONDecode(self.BatchHistory.batchLikes[BatchID])
	do
		if tonumber(v.user_id) == Player.UserId then
			GlobalDataStore:SetAsync(`likes_{Player.UserId}`, {
				LastUpdated = DateTime.now().UnixTimestamp,
				Likes = HttpService:JSONEncode(v.likes),
			})
			return HttpService:JSONEncode(v.likes)
		end
	end

	return false
end

-- Returns the current batch ID for the given batch name
function NetworkFunnel:GetBatchID(batchName: string)
	return self.BatchIDs[batchName].current
end

-- Returns the batch history for the given batch name
function NetworkFunnel:GetBatchHistory(batchName: string)
	return self.BatchHistory[batchName]
end

-- Returns the current batch request queue for the given batch name
function NetworkFunnel:GetBatchRequest(batchName: string)
	return self.RequestBatches[batchName]
end

-- Returns all current batch IDs
function NetworkFunnel:GetBatchIDs()
	return self.BatchIDs
end

-- Returns all pending request batches
function NetworkFunnel:GetRequestBatches()
	return self.RequestBatches
end

-- Stores the result of a batch request in the batch history
function NetworkFunnel:StoreBatchResult(batchName: string, Result: string)
	self.BatchHistory[batchName][self.BatchIDs[batchName].current] = Result
end

-- Generates a new batch ID and stores the previous one in the history
function NetworkFunnel:SetBatchID(batchName: string)
	self.BatchIDs[batchName].previous[self.BatchIDs[batchName].current] = true
	self.BatchIDs[batchName].current = HttpService:GenerateGUID(false)

	if Debug.NetworkFunnelDebug then -- Debug log: Print the current batch ID
		warn("Batch IDs:")
		print(self.BatchIDs[batchName])
	end

	return self.BatchIDs[batchName].current
end

return NetworkFunnel.new() -- Returns a new instance of the NetworkFunnel class]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXd217d1562a6f4ee9b6e2348984810a37">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Operations</string>
							<string name="ScriptGuid">{741e5801-3ca8-4910-819d-004b6180aacd}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local RunService = game:GetService("RunService") -- Provides access to the game loop and the Heartbeat event for managing frame updates
local HttpService = game:GetService("HttpService") -- Used for generating unique GUIDs and handling JSON operations
local DataStoreService = game:GetService("DataStoreService") -- Provides persistent storage for player data and other game data
local ReplicatedStorage = game:GetService("ReplicatedStorage") -- Shared storage across server and clients, often used for storing shared assets

local AudioscapePlayerData = DataStoreService:GetDataStore("AudioscapePlayerData") -- DataStore for storing player-specific data for Audioscape

--// Modules
local Requester = require(script.Parent.Requester) -- Handles sending requests to remote services or endpoints
local NetworkFunnel = require(script.Parent.NetworkFunnel) -- Manages batched requests to reduce network load
local GlobalDatabase = require(script.Parent.GlobalDatabase) -- Module for initializing and handling a global database
local RequestTemplates = require(script.Parent.RequestTemplates) -- Contains templates for requests to be sent to the server

--// Debug
local Debug = require(script.Parent.Parent.Parent.Debug) -- Debug module for logging and troubleshooting during development

--// Constants
local BATCH_UPDATE_INTERVAL = 60 -- Time interval (in seconds) between batch processing
local FUNNELED_REQUESTS = { "search", "genres", "emotions", "like", "unlike", "likes", "telemetry" } -- List of requests that should be funneled through NetworkFunnel

--// Events
local Events = require(script.Parent.Parent.Parent.Events) -- Handles remote event communication between client and server

--// Class
local Operations = {}
Operations.__index = Operations -- Sets up the metatable to use Operations as the class

-- Constructor for the Operations class
-- Sets up the initial properties including batching mechanisms and lifecycle hooks
function Operations.new(Remotes: Events.Remotes)
	local BatchID = HttpService:GenerateGUID(false) -- Generate a unique ID for tracking batch operations
	local info = {
		Interval = 0, -- Timer to keep track of batch intervals
		Remotes = Remotes, -- Store reference to remote events
		RemotesInitialized = false, -- Flag to track whether remotes have been initialized
		ShipBatch = false, -- Flag to track whether a batch is ready to be shipped
		ProcessingBatch = false, -- Flag to track whether a batch is currently being processed
		Batch = {}, -- Table to store batched requests
		BatchID = BatchID, -- Current batch ID
		BatchIDs = {
			[BatchID] = {}, -- Store batch success statuses for the current batch
		},
		LifeCycleHook = {}, -- Table to store lifecycle hooks for processing batches
		Connections = {}, -- Table to store any active connections (like event listeners)
	}
	setmetatable(info, Operations):Init() -- Set metatable for class behavior and call Init method

	repeat
		task.wait() -- Wait until remotes are fully initialized
	until info.RemotesInitialized

	if Debug.OperationsDebug then
		print("Operations Initialized") -- Confirmation that the Operations class is initialized
	end

	return info -- Return the instance of Operations
end

-- Initializes the Operations class by setting up lifecycle, funnel, and remotes
function Operations:Init()
	self:LifeCycle() -- Start the lifecycle process for batching
	self:InitFunnel() -- Initialize the NetworkFunnel for managing funneled requests
	self:InitRemotes() -- Set up the remote events

	-- Initialize the global database asynchronously
	task.spawn(function()
		GlobalDatabase:Init(self.Remotes, self.LifeCycleHook)
	end)
end

-- Initializes the NetworkFunnel module with the remote events and lifecycle hook
function Operations:InitFunnel()
	NetworkFunnel:Init(self.Remotes, self.LifeCycleHook)
end

-- Initializes the remote events for handling requests
-- Implements a yielding mechanism for processing requests in batches
function Operations:InitRemotes()
	local Remotes = self.Remotes :: Events.Remotes -- Cast the remotes to the Events.Remotes type

	-- YieldedRequest function to handle requests that may need to wait until the batch is processed
	local function YieldedRequest(...)
		if Debug.OperationsDebug then
			print("Starting Request")
		end

		-- Wait if the system is currently shipping a batch
		if self.ShipBatch then
			repeat
				RunService.Heartbeat:Wait()
			until not self.ShipBatch
		end

		local DataPieID = HttpService:GenerateGUID(false) -- Generate a unique ID for this individual request

		self.BatchIDs[self.BatchID][DataPieID] = false -- Mark the request as not yet completed

		-- Wait until the current batch is being shipped
		repeat
			RunService.Heartbeat:Wait()
		until self.ShipBatch

		self.BatchIDs[self.BatchID][DataPieID] = true -- Mark the request as completed

		if Debug.OperationsDebug then
			print(`Request: {DataPieID}`, ...) -- Log the request for debugging
		end

		warn("DataPie")
		print(self.BatchIDs[self.BatchID], self.BatchIDs[self.BatchID][DataPieID])

		return Requester(...) -- Process the request using the Requester module
	end

	-- Assign remote functions to handle Audioscape and server requests
	Remotes.PriortiyServerAudioscape.OnInvoke = Requester -- Directly handle priority Audioscape requests
	Remotes.ServerAudioscape.OnInvoke = Requester -- Handle standard Audioscape requests
	Remotes.Audioscape.OnServerInvoke = function(Player: Player, Action: string, Payload: string | { [any]: any })
		-- Check if the action is one of the funneled requests
		if table.find(FUNNELED_REQUESTS, Action) then
			return NetworkFunnel:RequestFromGlobal(Player, Action, Payload) -- Process via the funnel
		else
			return YieldedRequest(Player, Action, Payload) -- Handle the request with yielding if necessary
		end
	end

	self.RemotesInitialized = true -- Set the remotes initialized flag to true
end

-- Resets the current batch and prepares for the next one
function Operations:NewBatch()
	self.ShipBatch = false -- Reset the batch shipping flag
	self.ProcessingBatch = false -- Reset the batch processing flag
	self.BatchID = HttpService:GenerateGUID(false) -- Generate a new batch ID
	self.BatchIDs[self.BatchID] = {} -- Initialize the new batch tracking table
end

-- Processes the current batch, checking for completion
function Operations:ProcessBatch()
	self.ShipBatch = true -- Set flag to indicate the batch is ready to be shipped
	self.ProcessingBatch = true -- Set flag to indicate the batch is being processed

	local Success = true -- Flag to track if all requests in the batch were successful

	repeat
		task.wait(0.1) -- Small wait to reduce load during processing
		for _, BatchSuccess in pairs(self.BatchIDs[self.BatchID]) do
			print(BatchSuccess)

			if not BatchSuccess then
				Success = false -- If any request fails, set success to false
			end
		end
	until Success -- Repeat until all requests in the batch are successful

	self:NewBatch() -- Prepare a new batch after processing
end

-- Manages the lifecycle of Operations, processing batches at regular intervals
function Operations:LifeCycle()
	local Accumulator = 0 -- Accumulator for time tracking
	RunService.Heartbeat:Connect(function(dt: number)
		Accumulator += dt -- Increment accumulator by delta time

		-- Call lifecycle hooks to process batches
		for _, LifeCycleHook in self.LifeCycleHook do
			LifeCycleHook(Accumulator, BATCH_UPDATE_INTERVAL, dt)
		end

		-- If enough time has passed and there is no active batch processing, start a new batch
		if Accumulator >= BATCH_UPDATE_INTERVAL and not self.ProcessingBatch then
			Accumulator = 0 -- Reset the accumulator
			self:ProcessBatch() -- Start processing the current batch
		end
	end)
end

-- Disconnects all active connections to avoid memory leaks
function Operations:Disconnect()
	for _, c: RBXScriptConnection in pairs(self.Connections) do
		c:Disconnect() -- Disconnect each connection
	end
end

-- Cleans up and destroys the Operations instance
function Operations:Destroy()
	self:Disconnect() -- Disconnect all connections

	setmetatable(self, nil) -- Clear the metatable to break class behavior
	table.clear(self) -- Clear the table of any remaining data
	table.freeze(self) -- Freeze the table to prevent further modifications
end

return Operations -- Return the Operations class]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXbf769be7bd4546d5a1221e625a69d5bb">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">RequestTemplates</string>
							<string name="ScriptGuid">{bcba6dad-f20d-4145-8200-9cf1f2fcf2fc}</string>
							<ProtectedString name="Source"><![CDATA[-- Implementation of RequestTemplates.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

export type SearchPostRequest = {
	game_id: string,
	game_name: string,
	genre: string,
	limit: number, -- You can return up to 1000 songs per search
}

--// Class
local RequestTemplates = {}

function RequestTemplates.new()
	local info = {
		Connections = {},
	}
	setmetatable(info, RequestTemplates)
	return info
end

function RequestTemplates.SearchRequest(
	game_id: string,
	game_name: string,
	genre: string,
	limit: number
): SearchPostRequest
	return {
		game_id = game_id,
		game_name = game_name,
		genre = genre,
		limit = limit,
	}
end

return RequestTemplates]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXab003e1226744daea28fa68d8ebb5b1b">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Requester</string>
							<string name="ScriptGuid">{e510ced0-86c4-4814-a84a-7741c61baf4e}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

--// Debug
local Debug = require(script.Parent.Parent.Parent.Debug)

--// DeveloperKey
local DeveloperKey = script.Parent.Parent.Parent.Parent.Developer_API_Key

--// Events
local Events = require(script.Parent.Parent.Parent.Events)

--// Settings
local QuerySettings = {
	SearchLimit = 10,
}

--// Game Name
local GameName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name

--// API KEY
local API_KEY = RunService:IsStudio() and DeveloperKey.Value or HttpService:GetSecret("audioscape_boombox_api_key")

--// Private Function
local function GetKeyName()
	local Name = script.Name
	local Split = string.split(Name, "_")

	return `{Split[2]}_{Split[1]}_Key`
end

local function GetPayload(Player: Player, Action: string, Payload: any, Data, url)
	local action = Action:lower()

	if action == "search" then -- Search for an asset
		-- print(Payload)

		-- Data["event_type"] = action -- event type should be 'search'
		Data["query"] = Payload.query -- The search term the user entered
		Data["genre"] = Payload.genre -- The results of the search
		Data["emotion"] = Payload.emotion -- The results of the search
		Data["limit"] = Payload.limit -- The results of the search

		Data["game_id"] = game.PlaceId -- The Game Id
		Data["game_name"] = GameName -- The Game Name

		Data["RequestType"] = "POST"

		return `{url}search`
	elseif action == "details" then -- Play an asset
		Data["event_type"] = "/assets/details"
		Data["asset_ids"] = Payload
		Data["RequestType"] = "POST"

		return `{url}/assets/details`
	elseif action == "like" or action == "unlike" then -- Like an asset
		Data["asset_id"] = tonumber(Payload.asset_id)
		Data["RequestType"] = "POST"

		return `{url}{action}`
	elseif action == "batchlike" or action == "batchunlike" then -- Get all the assets the user has liked
		Data["RequestType"] = "POST"
		Data[action == "batchlike" and "likes" or "unlikes"] = Payload

		if Debug.AudioscapeDebug then
			warn("Batch Like")
			print(Data)
		end

		return `{url}{action == "batchlike" and "batchLike" or "batchUnlike"}`
	elseif action == "batchlikes" then
		Data["RequestType"] = "POST"
		Data["user_ids"] = Payload

		if Debug.AudioscapeDebug then
			warn("Batch Likes")
			print(Payload)
		end

		return `{url}batchLikes`
	elseif action == "batchtelemetry" then
		Data["RequestType"] = "POST"
		Data["payload"] = Payload

		return `{url}batchTelemetry`
	elseif action == "emotions" or action == "genres" then -- Get all the assets the user has liked
		Data["RequestType"] = "GET"

		return `{url}{action}`
	-- elseif action == "likes" then -- Get all the assets the user has liked
	-- 	Data["RequestType"] = "GET"

	-- 	return `{url}{action}?user_id={Player.UserId}`
	elseif action == "settings" then -- Get all the assets the user has liked
		Data["RequestType"] = "GET"
		return `{url}{action}?game_id={game.PlaceId}`
	end

	return url
end

local function SendRequestFromType(API_KEY, url, jsonData, headers, Data, Action)
	if Debug.AudioscapeDebug then
		print(`Request Type: {Data.RequestType}`)
	end

	if Data.RequestType == "POST" then
		if Debug.AudioscapeDebug then
			print(
				"POST REQUEST:",
				"\n",
				url,
				"\n",
				jsonData,
				"\n",
				Enum.HttpContentType.ApplicationJson,
				"\n",
				false,
				"\n",
				headers,
				"\n"
			)
		end

		local Request = HttpService:RequestAsync({
			Url = url, -- This website helps debug HTTP requests
			Method = Data.RequestType,
			Headers = {
				["Content-Type"] = "application/json", -- When sending JSON, set this!
				["X-API-Key"] = API_KEY,
			},
			Body = jsonData,
		})

		return Request.Body -- Unable to cast Dictionary to token
	elseif Data.RequestType == "GET" then
		local Request = HttpService:RequestAsync({
			Url = url, -- This website helps debug HTTP requests
			Method = Data.RequestType,
			Headers = {
				["Content-Type"] = "application/json", -- When sending JSON, set this!
				["X-API-Key"] = API_KEY,
			},
		})

		return Request.Body
	else
		error(`Invalid Request Type: {Data.RequestType} at {url} for {Action}`)
	end
end

local function Request(Player: Player, Action: string, Payload: string | { [any]: any })
	local SecretIsString = type(API_KEY) == "string"

	local url = SecretIsString and "https://0ibi1y5igg.execute-api.us-east-2.amazonaws.com/dev/"
		or "https://api.audioscape.ai/boombox/"

	local headers = {
		["content"] = "application/json",
		["X-API-Key"] = API_KEY,
	}
	local data = {}

	--data["game_id"] = game.PlaceId -- The Game Id
	--data["game_name"] = GameName -- The Game Name
	data["AS-BoomBox-GameId"] = game.PlaceId
	data["AS-BoomBox-GameName"] = GameName
	data["AS-BoomBox-ClientDeviceType"] = RunService:IsStudio() and "Studio" or "Game"

	if Player then
		data["user_id"] = Player.UserId
		data["player_id"] = Player.UserId
		data["AS-BoomBox-PlayerId"] = Player.UserId
	end

	url = GetPayload(Player, Action, Payload, data, url)

	local jsonData = HttpService:JSONEncode(data)

	local response = SendRequestFromType(API_KEY, url, jsonData, headers, data, Action)

	if Debug.AudioscapeDebug then
		local ResponseDecode = HttpService:JSONDecode(response)

		print("URL: ", url, "\n")
		print("From: ", data["user_id"], "\n")
		print("Current Payload: ", Payload, "\n")
		print("JSON Data: ", data, "\n")
		print("Response Decode: ", HttpService:JSONDecode(response), "\n")

		if ResponseDecode.message then
			warn(`Message from BoomBox API: {ResponseDecode.message}`)
		elseif ResponseDecode.error then
			error(`Error from BoomBox API: {ResponseDecode.error}`)
		end
	end

	return response
end

return Request]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX0e8ca38a9dcd4c72973c3e336519b8d7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">API_Persistence</string>
						<string name="ScriptGuid">{68a58328-fb25-446d-82d8-9389b36d948e}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local DataStoreService = game:GetService("DataStoreService")
local QueuePersistence = DataStoreService:GetDataStore("QueuePersistence.2")
local PlayingPersistence = DataStoreService:GetDataStore("PlayingPersistence.2")

--// Debug
local Debug = require(script.Parent.Parent.Debug)

--// Events
local Events = require(script.Parent.Parent.Events)

--// Settings
local QuerySettings = {
	SearchLimit = 10,
}

--// Private Function
local function GetKeyName()
	local Name = script.Name
	local Split = string.split(Name, "_")

	return `{Split[2]}_{Split[1]}_Key`
end

local TemplateData = {
	asset_id = 1846594513,
	asset_name = "Melt Down",
	asset_audio_details_music_album = "Drones And Beats",
}

local PlayerData = {
	playing = {},
	queues = {},
}

local function Request(Player: Player, RequestType: string, Action: string, Payload)
	local Persistence = Action == "queue" and QueuePersistence or PlayingPersistence

	if RequestType == "GET" then
		local CurrentData = Persistence:GetAsync(Player.UserId)

		--print(CurrentData)

		if not CurrentData then
			Persistence:SetAsync(Player.UserId, HttpService:JSONEncode(TemplateData))
			return nil
		end

		return CurrentData
	elseif RequestType == "POST" then
		Persistence:SetAsync(Player.UserId, HttpService:JSONEncode(Payload))

		return true
	end

	return false
end

--// Return
return function(Remotes: Events.Remotes)
	game:BindToClose(function()
		for _, Player in Players:GetPlayers() do
			task.spawn(Request, Player, "POST", "queue", PlayerData.queues[Player])
			task.spawn(Request, Player, "POST", "playing", PlayerData.playing[Player])
		end
	end)

	Players.PlayerRemoving:Connect(function(Player)
		task.spawn(Request, Player, "POST", "queue", PlayerData.queues[Player])
		task.spawn(Request, Player, "POST", "playing", PlayerData.playing[Player])
	end)

	Remotes.Persistence.OnServerInvoke = function(Player: Player, RequestType: string, Action: string, Payload)
		if RequestType == "POST" then
			if Action == "queue" then
				PlayerData.queues[Player] = Payload

				return PlayerData.queues[Player]
			elseif Action == "playing" then
				PlayerData.playing[Player] = Payload

				return PlayerData.playing[Player]
			end
		else
			return Request(Player, RequestType, Action, Payload)
		end
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2224eb45650f4fbfbc0059f4277c182d">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">API_Telemetry</string>
						<string name="ScriptGuid">{ef406475-dda1-435b-a14f-a5474b37729c}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

--// Debug
local Debug = require(script.Parent.Parent.Debug)

--// DeveloperKey
local DeveloperKey = script.Parent.Parent.Parent.Developer_API_Key

--// Events
local Events = require(script.Parent.Parent.Events)

--// Settings
local QuerySettings = {
	SearchLimit = 10,
}

--// Game Name
local GameName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name

--// API KEY
local API_KEY = RunService:IsStudio() and DeveloperKey.Value or HttpService:GetSecret("audioscape_boombox_api_key")

--// Private Function
local function GetKeyName()
	local Name = script.Name
	local Split = string.split(Name, "_")

	return `{Split[2]}_{Split[1]}_Key`
end

local function GetPayload(Player: Player, Action: string, Payload: any, Data, url)
	local action = Action:lower()

	--warn(Action)
	if action == "search" then -- Search for an asset
		-- print(Payload)

		-- Data["event_type"] = action -- event type should be 'search'
		Data["query"] = Payload.query -- The search term the user entered
		Data["genre"] = Payload.genre -- The results of the search
		Data["emotion"] = Payload.emotion -- The results of the search

		Data["game_id"] = game.PlaceId -- The Game Id
		Data["game_name"] = GameName -- The Game Name

		Data["RequestType"] = "POST"

		return `{url}search`
	elseif action == "details" then -- Play an asset
		Data["event_type"] = "/assets/details"
		Data["asset_ids"] = Payload
		Data["RequestType"] = "POST"

		return `{url}/assets/details`
	elseif action == "like" or action == "unlike" then -- Like an asset
		Data["asset_id"] = tonumber(Payload.asset_id)
		Data["RequestType"] = "POST"

		return `{url}{action}`
	elseif action == "emotions" or action == "genres" then -- Get all the assets the user has liked
		Data["RequestType"] = "GET"

		return `{url}{action}`
	elseif action == "likes" then -- Get all the assets the user has liked
		Data["RequestType"] = "GET"

		return `{url}{action}?user_id={Player.UserId}`
	elseif action == "settings" then -- Get all the assets the user has liked
		Data["RequestType"] = "GET"

		return `{url}{action}?game_id={game.PlaceId}`
		--elseif action == "batchTelemety" then
		--	Data["RequestType"] = "POST"
		--	return `{url}{action}`
	end

	return url
end

local function SendRequestFromType(API_KEY, url, jsonData, headers, Data)
	if Debug.AudioscapeDebug then
		print(`Request Type: {Data.RequestType}`)
	end

	if Data.RequestType == "POST" then
		if Debug.AudioscapeDebug then
			print(
				"POST REQUEST:",
				"\n",
				url,
				"\n",
				jsonData,
				"\n",
				Enum.HttpContentType.ApplicationJson,
				"\n",
				false,
				"\n",
				headers,
				"\n"
			)
		end

		local Request = HttpService:RequestAsync({
			Url = url, -- This website helps debug HTTP requests
			Method = Data.RequestType,
			Headers = {
				["Content-Type"] = "application/json", -- When sending JSON, set this!
				["X-API-Key"] = API_KEY,
			},
			Body = jsonData,
		})

		return Request.Body -- Unable to cast Dictionary to token
	elseif Data.RequestType == "GET" then
		local Request = HttpService:RequestAsync({
			Url = url, -- This website helps debug HTTP requests
			Method = Data.RequestType,
			Headers = {
				["Content-Type"] = "application/json", -- When sending JSON, set this!
				["X-API-Key"] = API_KEY,
			},
		})

		return Request.Body
	else
		error("Invalid Request Type")
	end
end

local function Request(Player: Player, Action: string, Payload: string | { [any]: any })
	local SecretIsString = type(API_KEY) == "string"

	local url = SecretIsString and "https://0ibi1y5igg.execute-api.us-east-2.amazonaws.com/dev/"
		or "https://api.audioscape.ai/boombox/"

	local headers = {
		["content"] = "application/json",
		["X-API-Key"] = API_KEY,
	}
	local data = {}

	data["game_id"] = game.PlaceId -- The Game Id
	data["game_name"] = GameName -- The Game Name
	data["AS-BoomBox-GameId"] = game.PlaceId
	data["AS-BoomBox-GameName"] = GameName
	data["AS-BoomBox-ClientDeviceType"] = RunService:IsStudio() and "Studio" or "Game"

	if Player then
		data["user_id"] = Player.UserId
		data["player_id"] = Player.UserId
		data["AS-BoomBox-PlayerId"] = Player.UserId
	end

	url = GetPayload(Player, Action, Payload, data, url)

	local jsonData = HttpService:JSONEncode(data)

	local response = SendRequestFromType(API_KEY, url, jsonData, headers, data)

	if Debug.AudioscapeDebug then
		print("URL: ", url, "\n")
		print("From: ", data["user_id"], "\n")
		print("Current Payload: ", Payload, "\n")
		print("JSON Data: ", data, "\n")
		print("Response Decode: ", HttpService:JSONDecode(response), "\n")
	end

	return response
end

--// Return
return function(Remotes: Events.Remotes)
	-- Remotes.Audioscape.OnServerInvoke = Request
	-- Remotes.ServerAudioscape.OnInvoke = Request
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBXe9a5d740be724083a653237fc861a020">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AudioCanCollide">true</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>-20.2984371</X>
						<Y>0.75</Y>
						<Z>-0.603844643</Z>
						<R00>0</R00>
						<R01>0</R01>
						<R02>1</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>-0</R12>
						<R20>-1</R20>
						<R21>0</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="CanCollide">false</bool>
					<bool name="CanQuery">false</bool>
					<bool name="CanTouch">false</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">BoomBox</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>0.303000003</X>
						<Y>1.41600001</Y>
						<Z>2.35299993</Z>
					</Vector3>
				</Properties>
				<Item class="Attachment" referent="RBX2bdb44fea95f453e9bda077ef1fbe977">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0.186668396</X>
							<Y>-0.209274054</Y>
							<Z>0.679765701</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>-0</R12>
							<R20>-1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">LeftSpeakerAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="AudioFader" referent="RBX0f714c11affb48328a7fadbb6503c8f7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Bypass">false</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">AudioFader</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="Volume">1</float>
					</Properties>
					<Item class="Wire" referent="RBXc7342f1de9724f7d9c41f3f72463be6a">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Wire</string>
							<int64 name="SourceAssetId">-1</int64>
							<Ref name="SourceInstance">RBXa41604b4e6ee4ac4be28e0fd00fc80e9</Ref>
							<string name="SourceName">Output</string>
							<BinaryString name="Tags"></BinaryString>
							<Ref name="TargetInstance">RBX0f714c11affb48328a7fadbb6503c8f7</Ref>
							<string name="TargetName">Input</string>
						</Properties>
					</Item>
				</Item>
				<Item class="Attachment" referent="RBXb29e576e40304a5fbf6f34e86c23b18c">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0.213569641</X>
							<Y>-0.20851171</Y>
							<Z>-0.694911957</Z>
							<R00>0</R00>
							<R01>0</R01>
							<R02>-1</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>1</R20>
							<R21>0</R21>
							<R22>0</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">RightSpeakerAttachment</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">false</bool>
					</Properties>
				</Item>
				<Item class="Part" referent="RBXaacc4657874c48d6901693d7de2d03df">
					<Properties>
						<bool name="Anchored">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-19.6186714</X>
							<Y>0.540725946</Y>
							<Z>-0.83051306</Z>
							<R00>-1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>-1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<bool name="CanQuery">false</bool>
						<bool name="CanTouch">false</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">LeftSpeaker</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">1</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>0.600000024</X>
							<Y>0.600000024</Y>
							<Z>0.099999994</Z>
						</Vector3>
					</Properties>
					<Item class="Attachment" referent="RBX140d2f9106e94b4dbb203f021e0bdef1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<CoordinateFrame name="CFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>-0.0400000066</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">LeftSpeakerReciever</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">false</bool>
						</Properties>
					</Item>
					<Item class="RigidConstraint" referent="RBX7657e0bbddd548c09193d121136ecfd7">
						<Properties>
							<Ref name="Attachment0">RBX140d2f9106e94b4dbb203f021e0bdef1</Ref>
							<Ref name="Attachment1">RBX2bdb44fea95f453e9bda077ef1fbe977</Ref>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<int name="Color">194</int>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Enabled">true</bool>
							<string name="Name">RigidConstraint</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">false</bool>
						</Properties>
					</Item>
					<Item class="AudioEmitter" referent="RBX7e3b935e92554499ac0215557fa199c4">
						<Properties>
							<BinaryString name="AngleAttenuation">AA==</BinaryString>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="AudioInteractionGroup"></string>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<BinaryString name="DistanceAttenuation">AA==</BinaryString>
							<string name="Name">AudioEmitter</string>
							<token name="SimulationFidelity">1</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Wire" referent="RBXf9c175f25bef4d4c8ad94e930b1ed7a8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Wire</string>
								<int64 name="SourceAssetId">-1</int64>
								<Ref name="SourceInstance">RBX0f714c11affb48328a7fadbb6503c8f7</Ref>
								<string name="SourceName">Output</string>
								<BinaryString name="Tags"></BinaryString>
								<Ref name="TargetInstance">RBX7e3b935e92554499ac0215557fa199c4</Ref>
								<string name="TargetName">Input</string>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Part" referent="RBX7cebdc875a064992a2bda2a6f1da57cc">
					<Properties>
						<bool name="Anchored">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AudioCanCollide">true</bool>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>-20.9933491</X>
							<Y>0.54148829</Y>
							<Z>-0.777414262</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<bool name="CanQuery">false</bool>
						<bool name="CanTouch">false</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="CastShadow">true</bool>
						<string name="CollisionGroup">Default</string>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="EnableFluidForces">true</bool>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="MaterialVariantSerialized"></string>
						<string name="Name">RightSpeaker</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">1</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<token name="shape">1</token>
						<Vector3 name="size">
							<X>0.600000024</X>
							<Y>0.600000024</Y>
							<Z>0.099999994</Z>
						</Vector3>
					</Properties>
					<Item class="Attachment" referent="RBX1fbe2101a73046a981ce6e13d2705bdd">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<CoordinateFrame name="CFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>-0.0400000066</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">RightSpeakerReciever</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">false</bool>
						</Properties>
					</Item>
					<Item class="RigidConstraint" referent="RBX28dfc05acca44a18985876f9db7a8d28">
						<Properties>
							<Ref name="Attachment0">RBX1fbe2101a73046a981ce6e13d2705bdd</Ref>
							<Ref name="Attachment1">RBXb29e576e40304a5fbf6f34e86c23b18c</Ref>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<int name="Color">194</int>
							<bool name="DefinesCapabilities">false</bool>
							<bool name="Enabled">true</bool>
							<string name="Name">RigidConstraint</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">false</bool>
						</Properties>
					</Item>
					<Item class="AudioEmitter" referent="RBXe052f9a1af684a13aafb303ce92dd379">
						<Properties>
							<BinaryString name="AngleAttenuation">AA==</BinaryString>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="AudioInteractionGroup"></string>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<BinaryString name="DistanceAttenuation">AA==</BinaryString>
							<string name="Name">AudioEmitter</string>
							<token name="SimulationFidelity">1</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Wire" referent="RBX8fd282d37d0e4b448bc50ed9070e13ea">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Wire</string>
								<int64 name="SourceAssetId">-1</int64>
								<Ref name="SourceInstance">RBX0f714c11affb48328a7fadbb6503c8f7</Ref>
								<string name="SourceName">Output</string>
								<BinaryString name="Tags"></BinaryString>
								<Ref name="TargetInstance">RBXe052f9a1af684a13aafb303ce92dd379</Ref>
								<string name="TargetName">Input</string>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="AudioPlayer" referent="RBXa41604b4e6ee4ac4be28e0fd00fc80e9">
					<Properties>
						<string name="AssetId">rbxassetid://1837560230</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLoad">true</bool>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<NumberRange name="LoopRegion">0 60000 </NumberRange>
						<bool name="Looping">false</bool>
						<string name="Name">AudioPlayer</string>
						<NumberRange name="PlaybackRegion">0 60000 </NumberRange>
						<double name="PlaybackSpeed">1</double>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<double name="TimePosition">2.9833060181153996382</double>
						<float name="Volume">1</float>
					</Properties>
				</Item>
				<Item class="SpecialMesh" referent="RBX8991e9aef8534ed987436eb8503f07e7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="MeshId"><url>rbxassetid://82078384451285</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>0.00625000009</X>
							<Y>0.00625000009</Y>
							<Z>0.00625000009</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<Content name="TextureId"><url>rbxassetid://81968105333241</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="StringValue" referent="RBXfb9992c2165e4e98b7f92249ef635310">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">DataHeader</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<string name="Value">AudioscapeBoombox</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX9cf0dc153de04446a30fa1384264f2e0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">DataStoreVersion</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<string name="Value">0.0.2</string>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX29320296c2db4143b3fc236f3a7f0064">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Debug</string>
					<string name="ScriptGuid">{7397ee23-d35b-49e3-9546-98660be46e7c}</string>
					<ProtectedString name="Source"><![CDATA[return {
	SearchDebug = false,
	AudioscapeDebug = false,
	OperationsDebug = false,
	NetworkFunnelDebug = false,
	GlobalDatabaseDebug = false,

	GlobalDatabaseGenereUpdateDebug = false,
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9bec7a8906cd406792100dc17e623eba">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Events</string>
					<string name="ScriptGuid">{4c590f0f-8a48-4d0f-a6f9-0d2d9447fe7d}</string>
					<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Types
export type Remotes = {
	--// Remote Events
	DataCache: RemoteEvent,
	CreatePublicSound: RemoteEvent,

	--// Remote Functions
	Audioscape: RemoteFunction,
	ServerAudioscape: BindableFunction,
	PriortiyServerAudioscape: BindableFunction,

	Persistence: RemoteFunction,
}

--// Variables
local BoomboxRemotes = Instance.new("Folder")
BoomboxRemotes.Name = "BoomboxRemotes"
BoomboxRemotes.Parent = ReplicatedStorage

--// Private Functions
local function CreateRemoteEvent(Name: string)
	local RemoteEvent = Instance.new("RemoteEvent")
	RemoteEvent.Name = Name
	RemoteEvent.Parent = BoomboxRemotes

	return RemoteEvent
end

local function CreateRemoteFunction(Name: string)
	local RemoteFunction = Instance.new("RemoteFunction")
	RemoteFunction.Name = Name
	RemoteFunction.Parent = BoomboxRemotes

	return RemoteFunction
end

local function CreateBindableFunction(Name: string)
	local BindableFunction = Instance.new("BindableFunction")
	BindableFunction.Name = Name
	BindableFunction.Parent = BoomboxRemotes

	return BindableFunction
end

--// Return
local Events = {
	--// Remote Events
	DataCache = CreateRemoteEvent("DataCache"),
	BoomboxEvent = CreateRemoteEvent("BoomboxEvent"),
	ToggleBoombox = CreateRemoteEvent("ToggleBoombox"),
	HeadlessEvents = CreateRemoteEvent("HeadlessEvents"),
	CreatePublicSound = CreateRemoteEvent("CreatePublicSound"),

	--// Remote Functions
	-- Audioscape
	Audioscape = CreateRemoteFunction("Audioscape"),
	ServerAudioscape = CreateBindableFunction("ServerAudioscape"),
	PriortiyServerAudioscape = CreateBindableFunction("PriortiyServerAudioscape"),

	-- Persistence
	Persistence = CreateRemoteFunction("Persistence"),

	-- Else
	HeadlessFunctions = CreateRemoteFunction("HeadlessFunctions"),
	BoomboxStateRetrieval = CreateRemoteFunction("BoomboxStateRetrieval"),
}

return Events]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX7c6ece7d506543bcacee817ee578e4e9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Modules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX58dc4832d4e346fe81e034132ad654e1">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioAssembly</string>
						<string name="ScriptGuid">{73737c1d-bfd2-4a6c-8760-1be5564fdf2a}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Modules
local Presets = require(script.Presets)

--// Variables
local Boombox = script.Parent.Parent.BoomBox

--// AudioAssembly Class
local AudioAssembly = {
	Players = {}, -- Structure to hold layers per player by UserId
	AudioPlayers = {}, -- Structure to hold audio players per player by UserId
	LayerNerveEndings = {}, -- Structure to hold layer nerve endings per player by UserId
}

function AudioAssembly.ApplyPreset(Player: Player, Layer: string, Preset: number)
	local playerLayers = AudioAssembly.Players[Player.UserId]
	if not playerLayers or not playerLayers[Layer] then
		return
	end

	local LayerInstance = playerLayers[Layer]

	for Property, Value in Presets[Layer][Preset] do
		LayerInstance[Property] = Value
	end
end

function AudioAssembly.AudioPitchShifter(AudioPlayer: AudioPlayer, AudioPitchShifter: AudioPitchShifter)
	local Connections = {}
	local ScreenGui = nil

	Connections[#Connections + 1] = AudioPlayer:GetPropertyChangedSignal("PlaybackSpeed"):Connect(function()
		AudioPlayer.PlaybackSpeed = math.clamp(AudioPlayer.PlaybackSpeed, 0.6, 1.5)
		-- AudioPitchShifter.Pitch = 1 / AudioPlayer.PlaybackSpeed
	end)

	AudioPlayer.Destroying:Once(function()
		for _, Connection in Connections do
			Connection:Disconnect()
		end

		table.clear(Connections)

		if ScreenGui then
			ScreenGui:Destroy()
		end
	end)
end

function AudioAssembly.AudioReverb(AudioPlayer: AudioPlayer, AudioReverb: AudioReverb)
	local Connections = {}
	local ScreenGui = nil

	AudioReverb.Bypass = true

	AudioPlayer.Destroying:Once(function()
		for _, Connection in Connections do
			Connection:Disconnect()
		end

		table.clear(Connections)

		if ScreenGui then
			ScreenGui:Destroy()
		end
	end)
end

function AudioAssembly.AudioEqualizer(AudioPlayer: AudioPlayer, AudioEqualizer: AudioEqualizer) end

function AudioAssembly.CreateLayer(
	Player: Player,
	AudioPlayer: AudioPlayer,
	PreviousLayer: Instance,
	Layer: string,
	Wire: Wire
)
	local NewLayer = Instance.new(Layer)
	NewLayer.Name = Layer
	NewLayer.Parent = PreviousLayer

	if Wire then
		local NewWire = Instance.new("Wire")
		NewWire.Parent = NewLayer
		NewWire.SourceInstance = Wire.TargetInstance
		NewWire.TargetInstance = NewLayer
	else
		local NewWire = Instance.new("Wire")
		NewWire.Parent = NewLayer
		NewWire.SourceInstance = PreviousLayer
		NewWire.TargetInstance = NewLayer
	end

	if Layer == "AudioPitchShifter" then
		NewLayer.Pitch = 1
		AudioAssembly.AudioPitchShifter(AudioPlayer, NewLayer)
	elseif Layer == "AudioReverb" then
		AudioAssembly.AudioReverb(AudioPlayer, NewLayer)
	elseif Layer == "AudioEqualizer" then
		AudioAssembly.AudioEqualizer(AudioPlayer, NewLayer)
	end

	-- Store layer in player's structure
	AudioAssembly.Players[Player.UserId][Layer] = NewLayer

	return NewLayer
end

function AudioAssembly.CreateLayers(Player: Player, BoomBox: typeof(Boombox), Layers: { string })
	AudioAssembly.Players[Player.UserId] = AudioAssembly.Players[Player.UserId] or {}

	local AudioPlayer = Instance.new("AudioPlayer")
	AudioPlayer.Parent = BoomBox

	AudioAssembly.AudioPlayers[Player.UserId] = AudioPlayer
	AudioAssembly.Players[Player.UserId]["AudioPlayer"] = AudioPlayer

	local LayerInstances = {}

	local LastLayer = nil

	for _, Layer in Layers do
		table.insert(LayerInstances, AudioAssembly.CreateLayer(Player, AudioPlayer, LastLayer or AudioPlayer, Layer))
		LastLayer = LayerInstances[#LayerInstances]
	end

	AudioAssembly.LayerNerveEndings[Player.UserId] = LastLayer

	return AudioPlayer, LayerInstances
end

local function cleanUpPreviousEmitters(Speaker: Part)
	local AudioEmitter = Speaker:FindFirstChildWhichIsA("AudioEmitter")
	if AudioEmitter then
		AudioEmitter:Destroy()
	end
end

function AudioAssembly.CreateSpeakers(NerveEnding: Instance, BoomBox: typeof(Boombox))
	local LeftSpeaker = BoomBox.LeftSpeaker
	local RightSpeaker = BoomBox.RightSpeaker

	for _, Speaker in { LeftSpeaker, RightSpeaker } do
		cleanUpPreviousEmitters(Speaker)

		local AudioEmitter = Instance.new("AudioEmitter")
		AudioEmitter.Parent = Speaker

		local NewWire = Instance.new("Wire")
		NewWire.Parent = Speaker
		NewWire.SourceInstance = NerveEnding
		NewWire.TargetInstance = AudioEmitter
	end
end

return AudioAssembly]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXaebe627ea2ed41c98dec5843287efd39">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Presets</string>
							<string name="ScriptGuid">{7c3c4f7b-2018-47b3-964c-f73913f3fd0a}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	AudioReverb = {
		{
			DecayRatio = 0.811,
			DecayTime = 7.403,
			Density = 0.92,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0.022,
			HighCutFrequency = 5863.443,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = 5,
		},
	},
]]

local Presets = {
	AudioPlayer = {
		{
			PlaybackSpeed = 1,
		},
		{
			PlaybackSpeed = 0.7,
		},
		{
			PlaybackSpeed = 0.7,
		},
		{
			PlaybackSpeed = 1.3,
		},
		{
			PlaybackSpeed = 1.3,
		},
	},

	AudioFader = {
		{
			Volume = 1,
		},
		{
			Volume = 0.5,
		},
		{
			Volume = 0.5,
		},
		{
			Volume = 0.5,
		},
		{
			Volume = 0.5,
		},
	},
	AudioReverb = {
		{ -- Default
			Bypass = true,
			DecayRatio = 0.811,
			DecayTime = 6.189,
			Density = 0.92,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0.022,
			HighCutFrequency = 5863.443,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = -80,
		},
		{ -- 1
			Bypass = false,
			DecayRatio = 0.811,
			DecayTime = 6.189,
			Density = 0.92,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0.022,
			HighCutFrequency = 5863.443,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = 5,
		},
		{ -- 2
			Bypass = false,
			DecayRatio = 0.811,
			DecayTime = 1.314,
			Density = 1,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0,
			HighCutFrequency = 5863.443,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = 5,
		},
		{ -- 3
			Bypass = false,
			DecayRatio = 0.811,
			DecayTime = 1.314,
			Density = 1,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0,
			HighCutFrequency = 5863.443,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = 5,
		},
		{ -- 4
			Bypass = false,
			DecayRatio = 0.811,
			DecayTime = 3.344,
			Density = 1,
			Diffusion = 1,
			DryLevel = 10,
			EarlyDelayTime = 0,
			HighCutFrequency = 3689.429,
			LateDelayTime = 0.1,
			LowShelfFrequency = 450,
			LowShelfGain = -36,
			ReferenceFrequency = 5000,
			WetLevel = 5,
		},
	},
}

return Presets]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX419a60813aae45f2a629cbdb4adde6d4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Types</string>
					<string name="ScriptGuid">{a4d24a19-c8c6-4843-ae53-e0bc727a4ccf}</string>
					<ProtectedString name="Source"><![CDATA[export type BoomBox = Part & {
	AudioPlayer: AudioPlayer,
	RightSpeakerAttachment: Attachment,
	RightSpeaker: Part & {
		RightSpeakerReciever: Attachment,
		RigidConstraint: RigidConstraint,
		AudioEmitter: AudioEmitter & {
			Wire: Wire,
		},
	},
	AudioFader: AudioFader & {
		Wire: Wire,
	},
	LeftSpeakerAttachment: Attachment,
	Mesh: SpecialMesh,
	LeftSpeaker: Part & {
		LeftSpeakerReciever: Attachment,
		RigidConstraint: RigidConstraint,
		AudioEmitter: AudioEmitter & {
			Wire: Wire,
		},
	},
}

return {}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="StringValue" referent="RBX334c78c5b26048d988af9a099703756e">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Version</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<string name="Value">0.0.8</string>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBXfecc7ce686234b3c88527ca1efc7badd">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">BoomBoxPackages</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXfb1ea670480c40e1b90d1b3831c69184">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Fusion</string>
					<string name="ScriptGuid">{5d0070c9-5d6a-439b-bd83-26971bbf781c}</string>
					<ProtectedString name="Source">return require(script.Parent._Index[&quot;elttob_fusion@0.2.0&quot;][&quot;fusion&quot;])</ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX976966d5767847ee88a1e1342d096641">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Maid</string>
					<string name="ScriptGuid">{dc31da4f-8667-4bb1-95e7-5398eb468923}</string>
					<ProtectedString name="Source">return require(script.Parent._Index[&quot;flamenco687_maid@3.2.2&quot;][&quot;maid&quot;])</ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXc1e31f9e26bc4b9e844dce13bfa2ac95">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">_Index</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXf050506f23614ce9b6feeb488d82dd68">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">elttob_fusion@0.2.0</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX6fc3f23fb7d74dd19f17099438031922">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">fusion</string>
							<string name="ScriptGuid">{b69a38f3-aec4-4ac8-9252-b28047ee33c4}</string>
							<ProtectedString name="Source"><![CDATA[--!strict

--[[
	The entry point for the Fusion library.
]]

local PubTypes = require(script.PubTypes)
local restrictRead = require(script.Utility.restrictRead)

export type StateObject<T> = PubTypes.StateObject<T>
export type CanBeState<T> = PubTypes.CanBeState<T>
export type Symbol = PubTypes.Symbol
export type Value<T> = PubTypes.Value<T>
export type Computed<T> = PubTypes.Computed<T>
export type ForPairs<KO, VO> = PubTypes.ForPairs<KO, VO>
export type ForKeys<KI, KO> = PubTypes.ForKeys<KI, KO>
export type ForValues<VI, VO> = PubTypes.ForKeys<VI, VO>
export type Observer = PubTypes.Observer
export type Tween<T> = PubTypes.Tween<T>
export type Spring<T> = PubTypes.Spring<T>

type Fusion = {
	version: PubTypes.Version,

	New: (className: string) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Hydrate: (target: Instance) -> ((propertyTable: PubTypes.PropertyTable) -> Instance),
	Ref: PubTypes.SpecialKey,
	Cleanup: PubTypes.SpecialKey,
	Children: PubTypes.SpecialKey,
	Out: PubTypes.SpecialKey,
	OnEvent: (eventName: string) -> PubTypes.SpecialKey,
	OnChange: (propertyName: string) -> PubTypes.SpecialKey,

	Value: <T>(initialValue: T) -> Value<T>,
	Computed: <T>(callback: () -> T, destructor: (T) -> ()?) -> Computed<T>,
	ForPairs: <KI, VI, KO, VO, M>(inputTable: CanBeState<{[KI]: VI}>, processor: (KI, VI) -> (KO, VO, M?), destructor: (KO, VO, M?) -> ()?) -> ForPairs<KO, VO>,
	ForKeys: <KI, KO, M>(inputTable: CanBeState<{[KI]: any}>, processor: (KI) -> (KO, M?), destructor: (KO, M?) -> ()?) -> ForKeys<KO, any>,
	ForValues: <VI, VO, M>(inputTable: CanBeState<{[any]: VI}>, processor: (VI) -> (VO, M?), destructor: (VO, M?) -> ()?) -> ForValues<any, VO>,
	Observer: (watchedState: StateObject<any>) -> Observer,

	Tween: <T>(goalState: StateObject<T>, tweenInfo: TweenInfo?) -> Tween<T>,
	Spring: <T>(goalState: StateObject<T>, speed: number?, damping: number?) -> Spring<T>,

	cleanup: (...any) -> (),
	doNothing: (...any) -> ()
}

return restrictRead("Fusion", {
	version = {major = 0, minor = 2, isRelease = true},

	New = require(script.Instances.New),
	Hydrate = require(script.Instances.Hydrate),
	Ref = require(script.Instances.Ref),
	Out = require(script.Instances.Out),
	Cleanup = require(script.Instances.Cleanup),
	Children = require(script.Instances.Children),
	OnEvent = require(script.Instances.OnEvent),
	OnChange = require(script.Instances.OnChange),

	Value = require(script.State.Value),
	Computed = require(script.State.Computed),
	ForPairs = require(script.State.ForPairs),
	ForKeys = require(script.State.ForKeys),
	ForValues = require(script.State.ForValues),
	Observer = require(script.State.Observer),

	Tween = require(script.Animation.Tween),
	Spring = require(script.Animation.Spring),

	cleanup = require(script.Utility.cleanup),
	doNothing = require(script.Utility.doNothing)
}) :: Fusion]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX38a2cd5fd6fc407c821515fa3f3adb46">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Animation</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXdff3c58ec28542579741004824080bf8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Spring</string>
									<string name="ScriptGuid">{7330c827-c5e3-477f-a535-5ef141a61f3a}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a spring simulation.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local unpackType = require(Package.Animation.unpackType)
local SpringScheduler = require(Package.Animation.SpringScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local xtypeof = require(Package.Utility.xtypeof)
local unwrap = require(Package.State.unwrap)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Spring object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Sets the position of the internal springs, meaning the value of this
	Spring will jump to the given value. This doesn't affect velocity.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setPosition(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springPositions = unpackType(newValue, newType)
	self._currentValue = newValue
	SpringScheduler.add(self)
	updateAll(self)
end

--[[
	Sets the velocity of the internal springs, overwriting the existing velocity
	of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:setVelocity(newValue: PubTypes.Animatable)
	local newType = typeof(newValue)
	if newType ~= self._currentType then
		logError("springTypeMismatch", nil, newType, self._currentType)
	end

	self._springVelocities = unpackType(newValue, newType)
	SpringScheduler.add(self)
end

--[[
	Adds to the velocity of the internal springs, on top of the existing
	velocity of this Spring. This doesn't affect position.

	If the type doesn't match the current type of the spring, an error will be
	thrown.
]]
function class:addVelocity(deltaValue: PubTypes.Animatable)
	local deltaType = typeof(deltaValue)
	if deltaType ~= self._currentType then
		logError("springTypeMismatch", nil, deltaType, self._currentType)
	end

	local springDeltas = unpackType(deltaValue, deltaType)
	for index, delta in ipairs(springDeltas) do
		self._springVelocities[index] += delta
	end
	SpringScheduler.add(self)
end

--[[
	Called when the goal state changes value, or when the speed or damping has
	changed.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- figure out if this was a goal change or a speed/damping change
	if goalValue == self._goalValue then
		-- speed/damping change
		local damping = unwrap(self._damping)
		if typeof(damping) ~= "number" then
			logErrorNonFatal("mistypedSpringDamping", nil, typeof(damping))
		elseif damping < 0 then
			logErrorNonFatal("invalidSpringDamping", nil, damping)
		else
			self._currentDamping = damping
		end

		local speed = unwrap(self._speed)
		if typeof(speed) ~= "number" then
			logErrorNonFatal("mistypedSpringSpeed", nil, typeof(speed))
		elseif speed < 0 then
			logErrorNonFatal("invalidSpringSpeed", nil, speed)
		else
			self._currentSpeed = speed
		end

		return false
	else
		-- goal change - reconfigure spring to target new goal
		self._goalValue = goalValue

		local oldType = self._currentType
		local newType = typeof(goalValue)
		self._currentType = newType

		local springGoals = unpackType(goalValue, newType)
		local numSprings = #springGoals
		self._springGoals = springGoals

		if newType ~= oldType then
			-- if the type changed, snap to the new value and rebuild the
			-- position and velocity tables
			self._currentValue = self._goalValue

			local springPositions = table.create(numSprings, 0)
			local springVelocities = table.create(numSprings, 0)
			for index, springGoal in ipairs(springGoals) do
				springPositions[index] = springGoal
			end
			self._springPositions = springPositions
			self._springVelocities = springVelocities

			-- the spring may have been animating before, so stop that
			SpringScheduler.remove(self)
			return true

			-- otherwise, the type hasn't changed, just the goal...
		elseif numSprings == 0 then
			-- if the type isn't animatable, snap to the new value
			self._currentValue = self._goalValue
			return true

		else
			-- if it's animatable, let it animate to the goal
			SpringScheduler.add(self)
			return false
		end
	end
end

local function Spring<T>(
	goalState: PubTypes.Value<T>,
	speed: PubTypes.CanBeState<number>?,
	damping: PubTypes.CanBeState<number>?
): Types.Spring<T>
	-- apply defaults for speed and damping
	if speed == nil then
		speed = 10
	end
	if damping == nil then
		damping = 1
	end

	local dependencySet = {[goalState] = true}
	if xtypeof(speed) == "State" then
		dependencySet[speed] = true
	end
	if xtypeof(damping) == "State" then
		dependencySet[damping] = true
	end

	local self = setmetatable({
		type = "State",
		kind = "Spring",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_speed = speed,
		_damping = damping,

		_goalState = goalState,
		_goalValue = nil,

		_currentType = nil,
		_currentValue = nil,
		_currentSpeed = unwrap(speed),
		_currentDamping = unwrap(damping),

		_springPositions = nil,
		_springGoals = nil,
		_springVelocities = nil
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true
	self:update()

	return self
end

return Spring]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4e3aee094c0240a4b290fb5b3a986bcc">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SpringScheduler</string>
									<string name="ScriptGuid">{816816eb-4211-4490-abf5-5f065e4472cb}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Manages batch updating of spring objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local packType = require(Package.Animation.packType)
local springCoefficients = require(Package.Animation.springCoefficients)
local updateAll = require(Package.Dependencies.updateAll)

type Set<T> = {[T]: any}
type Spring = Types.Spring<any>

local SpringScheduler = {}

local EPSILON = 0.0001
local activeSprings: Set<Spring> = {}
local lastUpdateTime = os.clock()

function SpringScheduler.add(spring: Spring)
	-- we don't necessarily want to use the most accurate time - here we snap to
	-- the last update time so that springs started within the same frame have
	-- identical time steps
	spring._lastSchedule = lastUpdateTime
	spring._startDisplacements = {}
	spring._startVelocities = {}
	for index, goal in ipairs(spring._springGoals) do
		spring._startDisplacements[index] = spring._springPositions[index] - goal
		spring._startVelocities[index] = spring._springVelocities[index]
	end

	activeSprings[spring] = true
end

function SpringScheduler.remove(spring: Spring)
	activeSprings[spring] = nil
end


local function updateAllSprings()
	local springsToSleep: Set<Spring> = {}
	lastUpdateTime = os.clock()

	for spring in pairs(activeSprings) do
		local posPos, posVel, velPos, velVel = springCoefficients(lastUpdateTime - spring._lastSchedule, spring._currentDamping, spring._currentSpeed)

		local positions = spring._springPositions
		local velocities = spring._springVelocities
		local startDisplacements = spring._startDisplacements
		local startVelocities = spring._startVelocities
		local isMoving = false

		for index, goal in ipairs(spring._springGoals) do
			local oldDisplacement = startDisplacements[index]
			local oldVelocity = startVelocities[index]
			local newDisplacement = oldDisplacement * posPos + oldVelocity * posVel
			local newVelocity = oldDisplacement * velPos + oldVelocity * velVel

			if math.abs(newDisplacement) > EPSILON or math.abs(newVelocity) > EPSILON then
				isMoving = true
			end

			positions[index] = newDisplacement + goal
			velocities[index] = newVelocity
		end

		if not isMoving then
			springsToSleep[spring] = true
		end
	end

	for spring in pairs(activeSprings) do
		spring._currentValue = packType(spring._springPositions, spring._currentType)
		updateAll(spring)
	end

	for spring in pairs(springsToSleep) do
		activeSprings[spring] = nil
	end
end

RunService:BindToRenderStep(
	"__FusionSpringScheduler",
	Enum.RenderPriority.First.Value,
	updateAllSprings
)

return SpringScheduler]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX181dec66ad4743a6a1afe39e03997ae3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Tween</string>
									<string name="ScriptGuid">{e072b6d9-df65-41f0-833a-30aa3b602495}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new computed state object, which follows the value of another
	state object using a tween.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local TweenScheduler = require(Package.Animation.TweenScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local logError = require(Package.Logging.logError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local xtypeof = require(Package.Utility.xtypeof)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this Tween object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value; this will initiate a new tween.
	Returns false as the current value doesn't change right away.
]]
function class:update(): boolean
	local goalValue = self._goalState:get(false)

	-- if the goal hasn't changed, then this is a TweenInfo change.
	-- in that case, if we're not currently animating, we can skip everything
	if goalValue == self._nextValue and not self._currentlyAnimating then
		return false
	end

	local tweenInfo = self._tweenInfo
	if self._tweenInfoIsState then
		tweenInfo = tweenInfo:get()
	end

	-- if we receive a bad TweenInfo, then error and stop the update
	if typeof(tweenInfo) ~= "TweenInfo" then
		logErrorNonFatal("mistypedTweenInfo", nil, typeof(tweenInfo))
		return false
	end

	self._prevValue = self._currentValue
	self._nextValue = goalValue

	self._currentTweenStartTime = os.clock()
	self._currentTweenInfo = tweenInfo

	local tweenDuration = tweenInfo.DelayTime + tweenInfo.Time
	if tweenInfo.Reverses then
		tweenDuration += tweenInfo.Time
	end
	tweenDuration *= tweenInfo.RepeatCount + 1
	self._currentTweenDuration = tweenDuration

	-- start animating this tween
	TweenScheduler.add(self)

	return false
end

local function Tween<T>(
	goalState: PubTypes.StateObject<PubTypes.Animatable>,
	tweenInfo: PubTypes.CanBeState<TweenInfo>?
): Types.Tween<T>
	local currentValue = goalState:get(false)

	-- apply defaults for tween info
	if tweenInfo == nil then
		tweenInfo = TweenInfo.new()
	end

	local dependencySet = {[goalState] = true}
	local tweenInfoIsState = xtypeof(tweenInfo) == "State"

	if tweenInfoIsState then
		dependencySet[tweenInfo] = true
	end

	local startingTweenInfo = tweenInfo
	if tweenInfoIsState then
		startingTweenInfo = startingTweenInfo:get()
	end

	-- If we start with a bad TweenInfo, then we don't want to construct a Tween
	if typeof(startingTweenInfo) ~= "TweenInfo" then
		logError("mistypedTweenInfo", nil, typeof(startingTweenInfo))
	end

	local self = setmetatable({
		type = "State",
		kind = "Tween",
		dependencySet = dependencySet,
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_goalState = goalState,
		_tweenInfo = tweenInfo,
		_tweenInfoIsState = tweenInfoIsState,

		_prevValue = currentValue,
		_nextValue = currentValue,
		_currentValue = currentValue,

		-- store current tween into separately from 'real' tween into, so it
		-- isn't affected by :setTweenInfo() until next change
		_currentTweenInfo = tweenInfo,
		_currentTweenDuration = 0,
		_currentTweenStartTime = 0,
		_currentlyAnimating = false
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true

	return self
end

return Tween]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2a0b1cdfe24440dd8aa29d32121097e8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TweenScheduler</string>
									<string name="ScriptGuid">{36f77ba3-6daf-4f15-bdab-20b7e4ea3290}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Manages batch updating of tween objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local lerpType = require(Package.Animation.lerpType)
local getTweenRatio = require(Package.Animation.getTweenRatio)
local updateAll = require(Package.Dependencies.updateAll)

local TweenScheduler = {}

type Set<T> = {[T]: any}
type Tween = Types.Tween<any>

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- all the tweens currently being updated
local allTweens: Set<Tween> = {}
setmetatable(allTweens, WEAK_KEYS_METATABLE)

--[[
	Adds a Tween to be updated every render step.
]]
function TweenScheduler.add(tween: Tween)
	allTweens[tween] = true
end

--[[
	Removes a Tween from the scheduler.
]]
function TweenScheduler.remove(tween: Tween)
	allTweens[tween] = nil
end

--[[
	Updates all Tween objects.
]]
local function updateAllTweens()
	local now = os.clock()
	-- FIXME: Typed Luau doesn't understand this loop yet
	for tween: Tween in pairs(allTweens :: any) do
		local currentTime = now - tween._currentTweenStartTime

		if currentTime > tween._currentTweenDuration then
			if tween._currentTweenInfo.Reverses then
				tween._currentValue = tween._prevValue
			else
				tween._currentValue = tween._nextValue
			end
			tween._currentlyAnimating = false
			updateAll(tween)
			TweenScheduler.remove(tween)
		else
			local ratio = getTweenRatio(tween._currentTweenInfo, currentTime)
			local currentValue = lerpType(tween._prevValue, tween._nextValue, ratio)
			tween._currentValue = currentValue
			tween._currentlyAnimating = true
			updateAll(tween)
		end
	end
end

RunService:BindToRenderStep(
	"__FusionTweenScheduler",
	Enum.RenderPriority.First.Value,
	updateAllTweens
)

return TweenScheduler]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX82089faa5e6a4ac0a02df009bd3a4000">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">getTweenRatio</string>
									<string name="ScriptGuid">{19e96b17-fb90-4fcd-b2d0-4dc0e9aa8664}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Given a `tweenInfo` and `currentTime`, returns a ratio which can be used to
	tween between two values over time.
]]

local TweenService = game:GetService("TweenService")

local function getTweenRatio(tweenInfo: TweenInfo, currentTime: number): number
	local delay = tweenInfo.DelayTime
	local duration = tweenInfo.Time
	local reverses = tweenInfo.Reverses
	local numCycles = 1 + tweenInfo.RepeatCount
	local easeStyle = tweenInfo.EasingStyle
	local easeDirection = tweenInfo.EasingDirection

	local cycleDuration = delay + duration
	if reverses then
		cycleDuration += duration
	end

	if currentTime >= cycleDuration * numCycles then
		return 1
	end

	local cycleTime = currentTime % cycleDuration

	if cycleTime <= delay then
		return 0
	end

	local tweenProgress = (cycleTime - delay) / duration
	if tweenProgress > 1 then
		tweenProgress = 2 - tweenProgress
	end

	local ratio = TweenService:GetValue(tweenProgress, easeStyle, easeDirection)
	return ratio
end

return getTweenRatio]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXb06d1e4f1f604a658771e2ecd434495c">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">lerpType</string>
									<string name="ScriptGuid">{33eae218-355c-4a0a-8254-0b815940db37}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Linearly interpolates the given animatable types by a ratio.
	If the types are different or not animatable, then the first value will be
	returned for ratios below 0.5, and the second value for 0.5 and above.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function lerpType(from: any, to: any, ratio: number): any
	local typeString = typeof(from)

	if typeof(to) == typeString then
		-- both types must match for interpolation to make sense
		if typeString == "number" then
			local to, from = to :: number, from :: number
			return (to - from) * ratio + from

		elseif typeString == "CFrame" then
			local to, from = to :: CFrame, from :: CFrame
			return from:Lerp(to, ratio)

		elseif typeString == "Color3" then
			local to, from = to :: Color3, from :: Color3
			local fromLab = Oklab.to(from)
			local toLab = Oklab.to(to)
			return Oklab.from(
				fromLab:Lerp(toLab, ratio),
				false
			)

		elseif typeString == "ColorSequenceKeypoint" then
			local to, from = to :: ColorSequenceKeypoint, from :: ColorSequenceKeypoint
			local fromLab = Oklab.to(from.Value)
			local toLab = Oklab.to(to.Value)
			return ColorSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				Oklab.from(
					fromLab:Lerp(toLab, ratio),
					false
				)
			)

		elseif typeString == "DateTime" then
			local to, from = to :: DateTime, from :: DateTime
			return DateTime.fromUnixTimestampMillis(
				(to.UnixTimestampMillis - from.UnixTimestampMillis) * ratio + from.UnixTimestampMillis
			)

		elseif typeString == "NumberRange" then
			local to, from = to :: NumberRange, from :: NumberRange
			return NumberRange.new(
				(to.Min - from.Min) * ratio + from.Min,
				(to.Max - from.Max) * ratio + from.Max
			)

		elseif typeString == "NumberSequenceKeypoint" then
			local to, from = to :: NumberSequenceKeypoint, from :: NumberSequenceKeypoint
			return NumberSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				(to.Value - from.Value) * ratio + from.Value,
				(to.Envelope - from.Envelope) * ratio + from.Envelope
			)

		elseif typeString == "PhysicalProperties" then
			local to, from = to :: PhysicalProperties, from :: PhysicalProperties
			return PhysicalProperties.new(
				(to.Density - from.Density) * ratio + from.Density,
				(to.Friction - from.Friction) * ratio + from.Friction,
				(to.Elasticity - from.Elasticity) * ratio + from.Elasticity,
				(to.FrictionWeight - from.FrictionWeight) * ratio + from.FrictionWeight,
				(to.ElasticityWeight - from.ElasticityWeight) * ratio + from.ElasticityWeight
			)

		elseif typeString == "Ray" then
			local to, from = to :: Ray, from :: Ray
			return Ray.new(
				from.Origin:Lerp(to.Origin, ratio),
				from.Direction:Lerp(to.Direction, ratio)
			)

		elseif typeString == "Rect" then
			local to, from = to :: Rect, from :: Rect
			return Rect.new(
				from.Min:Lerp(to.Min, ratio),
				from.Max:Lerp(to.Max, ratio)
			)

		elseif typeString == "Region3" then
			local to, from = to :: Region3, from :: Region3
			-- FUTURE: support rotated Region3s if/when they become constructable
			local position = from.CFrame.Position:Lerp(to.CFrame.Position, ratio)
			local halfSize = from.Size:Lerp(to.Size, ratio) / 2
			return Region3.new(position - halfSize, position + halfSize)

		elseif typeString == "Region3int16" then
			local to, from = to :: Region3int16, from :: Region3int16
			return Region3int16.new(
				Vector3int16.new(
					(to.Min.X - from.Min.X) * ratio + from.Min.X,
					(to.Min.Y - from.Min.Y) * ratio + from.Min.Y,
					(to.Min.Z - from.Min.Z) * ratio + from.Min.Z
				),
				Vector3int16.new(
					(to.Max.X - from.Max.X) * ratio + from.Max.X,
					(to.Max.Y - from.Max.Y) * ratio + from.Max.Y,
					(to.Max.Z - from.Max.Z) * ratio + from.Max.Z
				)
			)

		elseif typeString == "UDim" then
			local to, from = to :: UDim, from :: UDim
			return UDim.new(
				(to.Scale - from.Scale) * ratio + from.Scale,
				(to.Offset - from.Offset) * ratio + from.Offset
			)

		elseif typeString == "UDim2" then
			local to, from = to :: UDim2, from :: UDim2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2" then
			local to, from = to :: Vector2, from :: Vector2
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2int16" then
			local to, from = to :: Vector2int16, from :: Vector2int16
			return Vector2int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y
			)

		elseif typeString == "Vector3" then
			local to, from = to :: Vector3, from :: Vector3
			return from:Lerp(to, ratio)

		elseif typeString == "Vector3int16" then
			local to, from = to :: Vector3int16, from :: Vector3int16
			return Vector3int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y,
				(to.Z - from.Z) * ratio + from.Z
			)
		end
	end

	-- fallback case: the types are different or not animatable
	if ratio < 0.5 then
		return from
	else
		return to
	end
end

return lerpType]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX40faeaa02bcd4f58b70f4a47d0af3b98">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">packType</string>
									<string name="ScriptGuid">{fa420ede-6cc2-4dd2-b8f2-d656bb855f92}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Packs an array of numbers into a given animatable data type.
	If the type is not animatable, nil will be returned.

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function packType(numbers: {number}, typeString: string): PubTypes.Animatable?
	if typeString == "number" then
		return numbers[1]

	elseif typeString == "CFrame" then
		return
			CFrame.new(numbers[1], numbers[2], numbers[3]) *
			CFrame.fromAxisAngle(
				Vector3.new(numbers[4], numbers[5], numbers[6]).Unit,
				numbers[7]
			)

	elseif typeString == "Color3" then
		return Oklab.from(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			false
		)

	elseif typeString == "ColorSequenceKeypoint" then
		return ColorSequenceKeypoint.new(
			numbers[4],
			Oklab.from(
				Vector3.new(numbers[1], numbers[2], numbers[3]),
				false
			)
		)

	elseif typeString == "DateTime" then
		return DateTime.fromUnixTimestampMillis(numbers[1])

	elseif typeString == "NumberRange" then
		return NumberRange.new(numbers[1], numbers[2])

	elseif typeString == "NumberSequenceKeypoint" then
		return NumberSequenceKeypoint.new(numbers[2], numbers[1], numbers[3])

	elseif typeString == "PhysicalProperties" then
		return PhysicalProperties.new(numbers[1], numbers[2], numbers[3], numbers[4], numbers[5])

	elseif typeString == "Ray" then
		return Ray.new(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			Vector3.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "Rect" then
		return Rect.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		local position = Vector3.new(numbers[1], numbers[2], numbers[3])
		local halfSize = Vector3.new(numbers[4] / 2, numbers[5] / 2, numbers[6] / 2)
		return Region3.new(position - halfSize, position + halfSize)

	elseif typeString == "Region3int16" then
		return Region3int16.new(
			Vector3int16.new(numbers[1], numbers[2], numbers[3]),
			Vector3int16.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "UDim" then
		return UDim.new(numbers[1], numbers[2])

	elseif typeString == "UDim2" then
		return UDim2.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Vector2" then
		return Vector2.new(numbers[1], numbers[2])

	elseif typeString == "Vector2int16" then
		return Vector2int16.new(numbers[1], numbers[2])

	elseif typeString == "Vector3" then
		return Vector3.new(numbers[1], numbers[2], numbers[3])

	elseif typeString == "Vector3int16" then
		return Vector3int16.new(numbers[1], numbers[2], numbers[3])
	else
		return nil
	end
end

return packType]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXa2ee3e93453f499585d38fc816b8e80e">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">springCoefficients</string>
									<string name="ScriptGuid">{0f64bdfa-ed64-448c-bb11-ceae340cd9e2}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Returns a 2x2 matrix of coefficients for a given time, damping and speed.
	Specifically, this returns four coefficients - posPos, posVel, velPos, and
	velVel - which can be multiplied with position and velocity like so:

	local newPosition = oldPosition * posPos + oldVelocity * posVel
	local newVelocity = oldPosition * velPos + oldVelocity * velVel

	Special thanks to AxisAngle for helping to improve numerical precision.
]]

local function springCoefficients(time: number, damping: number, speed: number): (number, number, number, number)
	-- if time or speed is 0, then the spring won't move
	if time == 0 or speed == 0 then
		return 1, 0, 0, 1
	end
	local posPos, posVel, velPos, velVel

	if damping > 1 then
		-- overdamped spring
		-- solution to the characteristic equation:
		-- z = -  Sqrt[^2 - 1] 
		-- x[t] -> x0(e^(t z2) z1 - e^(t z1) z2)/(z1 - z2)
		--		 + v0(e^(t z1) - e^(t z2))/(z1 - z2)
		-- v[t] -> x0(z1 z2(-e^(t z1) + e^(t z2)))/(z1 - z2)
		--		 + v0(z1 e^(t z1) - z2 e^(t z2))/(z1 - z2)

		local scaledTime = time * speed
		local alpha = math.sqrt(damping^2 - 1)
		local scaledInvAlpha = -0.5 / alpha
		local z1 = -alpha - damping
		local z2 = 1 / z1
		local expZ1 = math.exp(scaledTime * z1)
		local expZ2 = math.exp(scaledTime * z2)

		posPos = (expZ2*z1 - expZ1*z2) * scaledInvAlpha
		posVel = (expZ1 - expZ2) * scaledInvAlpha / speed
		velPos = (expZ2 - expZ1) * scaledInvAlpha * speed
		velVel = (expZ1*z1 - expZ2*z2) * scaledInvAlpha

	elseif damping == 1 then
		-- critically damped spring
		-- x[t] -> x0(e^-t)(1+t) + v0(e^-t)t
		-- v[t] -> x0(t ^2)(-e^-t) + v0(1 - t)(e^-t)

		local scaledTime = time * speed
		local expTerm = math.exp(-scaledTime)

		posPos = expTerm * (1 + scaledTime)
		posVel = expTerm * time
		velPos = expTerm * (-scaledTime*speed)
		velVel = expTerm * (1 - scaledTime)

	else
		-- underdamped spring
		-- factored out of the solutions to the characteristic equation:
		--  = Sqrt[1 - ^2]
		-- x[t] -> x0(e^-t)( Cos[t] +  Sin[t])/
		--       + v0(e^-t)(Sin[t])/
		-- v[t] -> x0(-e^-t)(^2 + ^2 ^2)(Sin[t])/
		--       + v0(e^-t)( Cos[t] -  Sin[t])/

		local scaledTime = time * speed
		local alpha = math.sqrt(1 - damping^2)
		local invAlpha = 1 / alpha
		local alphaTime = alpha * scaledTime
		local expTerm = math.exp(-scaledTime*damping)
		local sinTerm = expTerm * math.sin(alphaTime)
		local cosTerm = expTerm * math.cos(alphaTime)
		local sinInvAlpha = sinTerm*invAlpha
		local sinInvAlphaDamp = sinInvAlpha*damping

		posPos = sinInvAlphaDamp + cosTerm
		posVel = sinInvAlpha
		velPos = -(sinInvAlphaDamp*damping + sinTerm*alpha)
		velVel = cosTerm - sinInvAlphaDamp
	end

	return posPos, posVel, velPos, velVel
end

return springCoefficients]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX09f25c26a875485aa86a0242397f3e24">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">unpackType</string>
									<string name="ScriptGuid">{0ec7888c-458c-409f-bd20-9613daf5027e}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Unpacks an animatable type into an array of numbers.
	If the type is not animatable, an empty array will be returned.

	FIXME: This function uses a lot of redefinitions to suppress false positives
	from the Luau typechecker - ideally these wouldn't be required

	FUTURE: When Luau supports singleton types, those could be used in
	conjunction with intersection types to make this function fully statically
	type checkable.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Oklab = require(Package.Colour.Oklab)

local function unpackType(value: any, typeString: string): {number}
	if typeString == "number" then
		local value = value :: number
		return {value}

	elseif typeString == "CFrame" then
		-- FUTURE: is there a better way of doing this? doing distance
		-- calculations on `angle` may be incorrect
		local axis, angle = value:ToAxisAngle()
		return {value.X, value.Y, value.Z, axis.X, axis.Y, axis.Z, angle}

	elseif typeString == "Color3" then
		local lab = Oklab.to(value)
		return {lab.X, lab.Y, lab.Z}

	elseif typeString == "ColorSequenceKeypoint" then
		local lab = Oklab.to(value.Value)
		return {lab.X, lab.Y, lab.Z, value.Time}

	elseif typeString == "DateTime" then
		return {value.UnixTimestampMillis}

	elseif typeString == "NumberRange" then
		return {value.Min, value.Max}

	elseif typeString == "NumberSequenceKeypoint" then
		return {value.Value, value.Time, value.Envelope}

	elseif typeString == "PhysicalProperties" then
		return {value.Density, value.Friction, value.Elasticity, value.FrictionWeight, value.ElasticityWeight}

	elseif typeString == "Ray" then
		return {value.Origin.X, value.Origin.Y, value.Origin.Z, value.Direction.X, value.Direction.Y, value.Direction.Z}

	elseif typeString == "Rect" then
		return {value.Min.X, value.Min.Y, value.Max.X, value.Max.Y}

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		return {
			value.CFrame.X, value.CFrame.Y, value.CFrame.Z,
			value.Size.X, value.Size.Y, value.Size.Z
		}

	elseif typeString == "Region3int16" then
		return {value.Min.X, value.Min.Y, value.Min.Z, value.Max.X, value.Max.Y, value.Max.Z}

	elseif typeString == "UDim" then
		return {value.Scale, value.Offset}

	elseif typeString == "UDim2" then
		return {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset}

	elseif typeString == "Vector2" then
		return {value.X, value.Y}

	elseif typeString == "Vector2int16" then
		return {value.X, value.Y}

	elseif typeString == "Vector3" then
		return {value.X, value.Y, value.Z}

	elseif typeString == "Vector3int16" then
		return {value.X, value.Y, value.Z}
	else
		return {}
	end
end

return unpackType]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXfbc4b501c27948b988daf8a6209d4749">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Colour</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX6bf79a9215c74fae83eba40462b4ae49">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Oklab</string>
									<string name="ScriptGuid">{7141e55e-1a15-40cf-bd02-4521525cad99}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Provides functions for converting Color3s into Oklab space, for more
	perceptually uniform colour blending.

	See: https://bottosson.github.io/posts/oklab/
]]

local Oklab = {}

-- Converts a Color3 in RGB space to a Vector3 in Oklab space.
function Oklab.to(rgb: Color3): Vector3
	local l = rgb.R * 0.4122214708 + rgb.G * 0.5363325363 + rgb.B * 0.0514459929
	local m = rgb.R * 0.2119034982 + rgb.G * 0.6806995451 + rgb.B * 0.1073969566
	local s = rgb.R * 0.0883024619 + rgb.G * 0.2817188376 + rgb.B * 0.6299787005

	local lRoot = l ^ (1/3)
	local mRoot = m ^ (1/3)
	local sRoot = s ^ (1/3)

	return Vector3.new(
		lRoot * 0.2104542553 + mRoot * 0.7936177850 - sRoot * 0.0040720468,
		lRoot * 1.9779984951 - mRoot * 2.4285922050 + sRoot * 0.4505937099,
		lRoot * 0.0259040371 + mRoot * 0.7827717662 - sRoot * 0.8086757660
	)
end

-- Converts a Vector3 in CIELAB space to a Color3 in RGB space.
-- The Color3 will be clamped by default unless specified otherwise.
function Oklab.from(lab: Vector3, unclamped: boolean?): Color3
	local lRoot = lab.X + lab.Y * 0.3963377774 + lab.Z * 0.2158037573
	local mRoot = lab.X - lab.Y * 0.1055613458 - lab.Z * 0.0638541728
	local sRoot = lab.X - lab.Y * 0.0894841775 - lab.Z * 1.2914855480

	local l = lRoot ^ 3
	local m = mRoot ^ 3
	local s = sRoot ^ 3

	local red = l * 4.0767416621 - m * 3.3077115913 + s * 0.2309699292
	local green = l * -1.2684380046 + m * 2.6097574011 - s * 0.3413193965
	local blue = l * -0.0041960863 - m * 0.7034186147 + s * 1.7076147010

	if not unclamped then
		red = math.clamp(red, 0, 1)
		green = math.clamp(green, 0, 1)
		blue = math.clamp(blue, 0, 1)
	end

	return Color3.new(red, green, blue)
end

return Oklab]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX16a5afb44f3d4c60a6af6e9a37f41f60">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Dependencies</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXa850f811d0304da0a69836560ee4e7ca">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">captureDependencies</string>
									<string name="ScriptGuid">{e93b694e-33dd-45d7-929d-23a24375ab93}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Calls the given callback, and stores any used external dependencies.
	Arguments can be passed in after the callback.
	If the callback completed successfully, returns true and the returned value,
	otherwise returns false and the error thrown.
	The callback shouldn't yield or run asynchronously.

	NOTE: any calls to useDependency() inside the callback (even if inside any
	nested captureDependencies() call) will not be included in the set, to avoid
	self-dependencies.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local parseError = require(Package.Logging.parseError)
local sharedState = require(Package.Dependencies.sharedState)

type Set<T> = {[T]: any}

local initialisedStack = sharedState.initialisedStack
local initialisedStackCapacity = 0

local function captureDependencies(
	saveToSet: Set<PubTypes.Dependency>,
	callback: (...any) -> any,
	...
): (boolean, any)

	local prevDependencySet = sharedState.dependencySet
	sharedState.dependencySet = saveToSet

	sharedState.initialisedStackSize += 1
	local initialisedStackSize = sharedState.initialisedStackSize

	local initialisedSet
	if initialisedStackSize > initialisedStackCapacity then
		initialisedSet = {}
		initialisedStack[initialisedStackSize] = initialisedSet
		initialisedStackCapacity = initialisedStackSize
	else
		initialisedSet = initialisedStack[initialisedStackSize]
		table.clear(initialisedSet)
	end

	local data = table.pack(xpcall(callback, parseError, ...))

	sharedState.dependencySet = prevDependencySet
	sharedState.initialisedStackSize -= 1

	return table.unpack(data, 1, data.n)
end

return captureDependencies]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXab3f2ead84ba4333a183022ad520ab76">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">initDependency</string>
									<string name="ScriptGuid">{b5abeec5-8fc5-4b3d-8c52-dd972baae95a}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Registers the creation of an object which can be used as a dependency.

	This is used to make sure objects don't capture dependencies originating
	from inside of themselves.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function initDependency(dependency: PubTypes.Dependency)
	local initialisedStackSize = sharedState.initialisedStackSize

	for index, initialisedSet in ipairs(initialisedStack) do
		if index > initialisedStackSize then
			return
		end

		initialisedSet[dependency] = true
	end
end

return initDependency]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6ae964c998a3488cb523f3d943d70c41">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">sharedState</string>
									<string name="ScriptGuid">{2265e448-70d1-42cb-8c66-b38babd814fb}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores shared state for dependency management functions.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}

-- The set where used dependencies should be saved to.
local dependencySet: Set<PubTypes.Dependency>? = nil

-- A stack of sets where newly created dependencies should be stored.
local initialisedStack: {Set<PubTypes.Dependency>} = {}
local initialisedStackSize = 0

return {
	dependencySet = dependencySet,
	initialisedStack = initialisedStack,
	initialisedStackSize = initialisedStackSize
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXceebba414fb14d79be6f7e17a4310b47">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">updateAll</string>
									<string name="ScriptGuid">{d3217393-a364-4421-a611-bf164232b6f3}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Given a reactive object, updates all dependent reactive objects.
	Objects are only ever updated after all of their dependencies are updated,
	are only ever updated once, and won't be updated if their dependencies are
	unchanged.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}
type Descendant = (PubTypes.Dependent & PubTypes.Dependency) | PubTypes.Dependent

-- Credit: https://blog.elttob.uk/2022/11/07/sets-efficient-topological-search.html
local function updateAll(root: PubTypes.Dependency)
	local counters: {[Descendant]: number} = {}
	local flags: {[Descendant]: boolean} = {}
	local queue: {Descendant} = {}
	local queueSize = 0
	local queuePos = 1

	for object in root.dependentSet do
		queueSize += 1
		queue[queueSize] = object
		flags[object] = true
	end

	-- Pass 1: counting up
	while queuePos <= queueSize do
		local next = queue[queuePos]
		local counter = counters[next]
		counters[next] = if counter == nil then 1 else counter + 1
		if (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				queueSize += 1
				queue[queueSize] = object
			end
		end
		queuePos += 1
	end

	-- Pass 2: counting down + processing
	queuePos = 1
	while queuePos <= queueSize do
		local next = queue[queuePos]
		local counter = counters[next] - 1
		counters[next] = counter
		if counter == 0 and flags[next] and next:update() and (next :: any).dependentSet ~= nil then
			for object in (next :: any).dependentSet do
				flags[object] = true
			end
		end
		queuePos += 1
	end
end

return updateAll]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXd3e15fb3ec5943909528eeef4ebc0bb3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">useDependency</string>
									<string name="ScriptGuid">{de60366f-b7a4-4cf2-aa17-2cc99ce5207d}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	If a target set was specified by captureDependencies(), this will add the
	given dependency to the target set.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function useDependency(dependency: PubTypes.Dependency)
	local dependencySet = sharedState.dependencySet

	if dependencySet ~= nil then
		local initialisedStackSize = sharedState.initialisedStackSize
		if initialisedStackSize > 0 then
			local initialisedSet = initialisedStack[initialisedStackSize]
			if initialisedSet[dependency] ~= nil then
				return
			end
		end
		dependencySet[dependency] = true
	end
end

return useDependency]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX60e09f4ea97d4b33ba39c7d602344d0c">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Instances</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX3b2ac199162e46158a428db3ffa5a4c7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Children</string>
									<string name="ScriptGuid">{1f23734d-d0fe-4469-999f-f1b052d592fa}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which parents any given descendants into
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logWarn = require(Package.Logging.logWarn)
local Observer = require(Package.State.Observer)
local xtypeof = require(Package.Utility.xtypeof)

type Set<T> = {[T]: boolean}

-- Experimental flag: name children based on the key used in the [Children] table
local EXPERIMENTAL_AUTO_NAMING = false

local Children = {}
Children.type = "SpecialKey"
Children.kind = "Children"
Children.stage = "descendants"

function Children:apply(propValue: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	local newParented: Set<Instance> = {}
	local oldParented: Set<Instance> = {}

	-- save disconnection functions for state object observers
	local newDisconnects: {[PubTypes.StateObject<any>]: () -> ()} = {}
	local oldDisconnects: {[PubTypes.StateObject<any>]: () -> ()} = {}

	local updateQueued = false
	local queueUpdate: () -> ()

	-- Rescans this key's value to find new instances to parent and state objects
	-- to observe for changes; then unparents instances no longer found and
	-- disconnects observers for state objects no longer present.
	local function updateChildren()
		if not updateQueued then
			return -- this update may have been canceled by destruction, etc.
		end
		updateQueued = false

		oldParented, newParented = newParented, oldParented
		oldDisconnects, newDisconnects = newDisconnects, oldDisconnects
		table.clear(newParented)
		table.clear(newDisconnects)

		local function processChild(child: any, autoName: string?)
			local kind = xtypeof(child)

			if kind == "Instance" then
				-- case 1; single instance

				newParented[child] = true
				if oldParented[child] == nil then
					-- wasn't previously present

					-- TODO: check for ancestry conflicts here
					child.Parent = applyTo
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldParented[child] = nil
				end

				if EXPERIMENTAL_AUTO_NAMING and autoName ~= nil then
					child.Name = autoName
				end

			elseif kind == "State" then
				-- case 2; state object

				local value = child:get(false)
				-- allow nil to represent the absence of a child
				if value ~= nil then
					processChild(value, autoName)
				end

				local disconnect = oldDisconnects[child]
				if disconnect == nil then
					-- wasn't previously present
					disconnect = Observer(child):onChange(queueUpdate)
				else
					-- previously here; we want to reuse, so remove from old
					-- set so we don't encounter it during unparenting
					oldDisconnects[child] = nil
				end

				newDisconnects[child] = disconnect

			elseif kind == "table" then
				-- case 3; table of objects

				for key, subChild in pairs(child) do
					local keyType = typeof(key)
					local subAutoName: string? = nil

					if keyType == "string" then
						subAutoName = key
					elseif keyType == "number" and autoName ~= nil then
						subAutoName = autoName .. "_" .. key
					end

					processChild(subChild, subAutoName)
				end

			else
				logWarn("unrecognisedChildType", kind)
			end
		end

		if propValue ~= nil then
			-- `propValue` is set to nil on cleanup, so we don't process children
			-- in that case
			processChild(propValue)
		end

		-- unparent any children that are no longer present
		for oldInstance in pairs(oldParented) do
			oldInstance.Parent = nil
		end

		-- disconnect observers which weren't reused
		for oldState, disconnect in pairs(oldDisconnects) do
			disconnect()
		end
	end

	queueUpdate = function()
		if not updateQueued then
			updateQueued = true
			task.defer(updateChildren)
		end
	end

	table.insert(cleanupTasks, function()
		propValue = nil
		updateQueued = true
		updateChildren()
	end)

	-- perform initial child parenting
	updateQueued = true
	updateChildren()
end

return Children :: PubTypes.SpecialKey]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXd67e800514bb4d79af5fe1acfd7d689e">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Cleanup</string>
									<string name="ScriptGuid">{db356a67-36c5-45e2-9351-4a996625c8f7}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which adds user-specified tasks to be run
	when the instance is destroyed.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)

local Cleanup = {}
Cleanup.type = "SpecialKey"
Cleanup.kind = "Cleanup"
Cleanup.stage = "observer"

function Cleanup:apply(userTask: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	table.insert(cleanupTasks, userTask)
end

return Cleanup]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2b9dd0fea081421cb2d02fed72f6960e">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Hydrate</string>
									<string name="ScriptGuid">{1903b1b5-b16a-4bb5-a182-8eb020325faa}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Processes and returns an existing instance, with options for setting
	properties, event handlers and other attributes on the instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)

local function Hydrate(target: Instance)
	return function(props: PubTypes.PropertyTable): Instance
		applyInstanceProps(props, target)
		return target
	end
end

return Hydrate]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXe01a4633d21c47d888e6280505d12509">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">New</string>
									<string name="ScriptGuid">{c2a3f1e5-bd03-4253-a49d-0c3d1465f1ac}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs and returns a new instance, with options for setting properties,
	event handlers and other attributes on the instance right away.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local defaultProps = require(Package.Instances.defaultProps)
local applyInstanceProps = require(Package.Instances.applyInstanceProps)
local logError= require(Package.Logging.logError)

local function New(className: string)
	return function(props: PubTypes.PropertyTable): Instance
		local ok, instance = pcall(Instance.new, className)

		if not ok then
			logError("cannotCreateClass", nil, className)
		end

		local classDefaults = defaultProps[className]
		if classDefaults ~= nil then
			for defaultProp, defaultValue in pairs(classDefaults) do
				instance[defaultProp] = defaultValue
			end
		end

		applyInstanceProps(props, instance)

		return instance
	end
end

return New]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX974cdd320cdf46d09c33e520b0b2af84">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">OnChange</string>
									<string name="ScriptGuid">{8ed99022-cbb8-40a5-8459-f58bbcc3fd2b}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs special keys for property tables which connect property change
	listeners to an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function OnChange(propertyName: string): PubTypes.SpecialKey
	local changeKey = {}
	changeKey.type = "SpecialKey"
	changeKey.kind = "OnChange"
	changeKey.stage = "observer"

	function changeKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("cannotConnectChange", nil, applyTo.ClassName, propertyName)
		elseif typeof(callback) ~= "function" then
			logError("invalidChangeHandler", nil, propertyName)
		else
			table.insert(cleanupTasks, event:Connect(function()
				callback((applyTo :: any)[propertyName])
			end))
		end
	end

	return changeKey
end

return OnChange]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXaeee72e2cdd34c3d81b26307ea813dbc">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">OnEvent</string>
									<string name="ScriptGuid">{e1d1da1a-0c79-4fee-b4ee-f9124a9cac16}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Constructs special keys for property tables which connect event listeners to
	an instance.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)

local function getProperty_unsafe(instance: Instance, property: string)
	return (instance :: any)[property]
end

local function OnEvent(eventName: string): PubTypes.SpecialKey
	local eventKey = {}
	eventKey.type = "SpecialKey"
	eventKey.kind = "OnEvent"
	eventKey.stage = "observer"

	function eventKey:apply(callback: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
		local ok, event = pcall(getProperty_unsafe, applyTo, eventName)
		if not ok or typeof(event) ~= "RBXScriptSignal" then
			logError("cannotConnectEvent", nil, applyTo.ClassName, eventName)
		elseif typeof(callback) ~= "function" then
			logError("invalidEventHandler", nil, eventName)
		else
			table.insert(cleanupTasks, event:Connect(callback))
		end
	end

	return eventKey
end

return OnEvent]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5f3ba03ae0624075a7027d01c6aff331">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Out</string>
									<string name="ScriptGuid">{1338596e-b96e-4ce6-a75b-19e9f57731fb}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which allows users to extract values from
	an instance into an automatically-updated Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local function Out(propertyName: string): PubTypes.SpecialKey
	local outKey = {}
	outKey.type = "SpecialKey"
	outKey.kind = "Out"
	outKey.stage = "observer"

	function outKey:apply(outState: any, applyTo: Instance, cleanupTasks: { PubTypes.Task })
		local ok, event = pcall(applyTo.GetPropertyChangedSignal, applyTo, propertyName)
		if not ok then
			logError("invalidOutProperty", nil, applyTo.ClassName, propertyName)
		elseif xtypeof(outState) ~= "State" or outState.kind ~= "Value" then
			logError("invalidOutType")
		else
			outState:set((applyTo :: any)[propertyName])
			table.insert(
				cleanupTasks,
				event:Connect(function()
					outState:set((applyTo :: any)[propertyName])
				end)
			)
			table.insert(cleanupTasks, function()
				outState:set(nil)
			end)
		end
	end

	return outKey
end

return Out]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX129ce5398cf9402aaa9a7ebebfe67193">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Ref</string>
									<string name="ScriptGuid">{e2a4efab-8c8c-4967-87f5-0bd9af17761b}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A special key for property tables, which stores a reference to the instance
	in a user-provided Value object.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local logError = require(Package.Logging.logError)
local xtypeof = require(Package.Utility.xtypeof)

local Ref = {}
Ref.type = "SpecialKey"
Ref.kind = "Ref"
Ref.stage = "observer"

function Ref:apply(refState: any, applyTo: Instance, cleanupTasks: {PubTypes.Task})
	if xtypeof(refState) ~= "State" or refState.kind ~= "Value" then
		logError("invalidRefType")
	else
		refState:set(applyTo)
		table.insert(cleanupTasks, function()
			refState:set(nil)
		end)
	end
end

return Ref]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXc33dcd4cdb80432b8ba87c88fbd384e6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">applyInstanceProps</string>
									<string name="ScriptGuid">{d4d363a1-ad0f-44ad-b486-26354ebe1c01}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Applies a table of properties to an instance, including binding to any
	given state objects and applying any special keys.

	No strong reference is kept by default - special keys should take care not
	to accidentally hold strong references to instances forever.

	If a key is used twice, an error will be thrown. This is done to avoid
	double assignments or double bindings. However, some special keys may want
	to enable such assignments - in which case unique keys should be used for
	each occurence.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local cleanup = require(Package.Utility.cleanup)
local xtypeof = require(Package.Utility.xtypeof)
local logError = require(Package.Logging.logError)
local Observer = require(Package.State.Observer)

local function setProperty_unsafe(instance: Instance, property: string, value: any)
	(instance :: any)[property] = value
end

local function testPropertyAssignable(instance: Instance, property: string)
	(instance :: any)[property] = (instance :: any)[property]
end

local function setProperty(instance: Instance, property: string, value: any)
	if not pcall(setProperty_unsafe, instance, property, value) then
		if not pcall(testPropertyAssignable, instance, property) then
			if instance == nil then
				-- reference has been lost
				logError("setPropertyNilRef", nil, property, tostring(value))
			else
				-- property is not assignable
				logError("cannotAssignProperty", nil, instance.ClassName, property)
			end
		else
			-- property is assignable, but this specific assignment failed
			-- this typically implies the wrong type was received
			local givenType = typeof(value)
			local expectedType = typeof((instance :: any)[property])
			logError("invalidPropertyType", nil, instance.ClassName, property, expectedType, givenType)
		end
	end
end

local function bindProperty(instance: Instance, property: string, value: PubTypes.CanBeState<any>, cleanupTasks: {PubTypes.Task})
	if xtypeof(value) == "State" then
		-- value is a state object - assign and observe for changes
		local willUpdate = false
		local function updateLater()
			if not willUpdate then
				willUpdate = true
				task.defer(function()
					willUpdate = false
					setProperty(instance, property, value:get(false))
				end)
			end
		end

		setProperty(instance, property, value:get(false))
		table.insert(cleanupTasks, Observer(value :: any):onChange(updateLater))
	else
		-- value is a constant - assign once only
		setProperty(instance, property, value)
	end
end

local function applyInstanceProps(props: PubTypes.PropertyTable, applyTo: Instance)
	local specialKeys = {
		self = {} :: {[PubTypes.SpecialKey]: any},
		descendants = {} :: {[PubTypes.SpecialKey]: any},
		ancestor = {} :: {[PubTypes.SpecialKey]: any},
		observer = {} :: {[PubTypes.SpecialKey]: any}
	}
	local cleanupTasks = {}

	for key, value in pairs(props) do
		local keyType = xtypeof(key)

		if keyType == "string" then
			if key ~= "Parent" then
				bindProperty(applyTo, key :: string, value, cleanupTasks)
			end
		elseif keyType == "SpecialKey" then
			local stage = (key :: PubTypes.SpecialKey).stage
			local keys = specialKeys[stage]
			if keys == nil then
				logError("unrecognisedPropertyStage", nil, stage)
			else
				keys[key] = value
			end
		else
			-- we don't recognise what this key is supposed to be
			logError("unrecognisedPropertyKey", nil, xtypeof(key))
		end
	end

	for key, value in pairs(specialKeys.self) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.descendants) do
		key:apply(value, applyTo, cleanupTasks)
	end

	if props.Parent ~= nil then
		bindProperty(applyTo, "Parent", props.Parent, cleanupTasks)
	end

	for key, value in pairs(specialKeys.ancestor) do
		key:apply(value, applyTo, cleanupTasks)
	end
	for key, value in pairs(specialKeys.observer) do
		key:apply(value, applyTo, cleanupTasks)
	end

	applyTo.Destroying:Connect(function()
		cleanup(cleanupTasks)
	end)
end

return applyInstanceProps]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5c8cdedef0c347cab66de2bf5ae20644">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">defaultProps</string>
									<string name="ScriptGuid">{19af673d-d847-42cd-bc06-6edf1a995cbd}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

return {
	ScreenGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	BillboardGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	},

	SurfaceGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = Enum.ZIndexBehavior.Sibling,

		SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud,
		PixelsPerStud = 50
	},

	Frame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ScrollingFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ScrollBarImageColor3 = Color3.new(0, 0, 0)
	},

	TextLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextBox = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ClearTextOnFocus = false,

		Font = Enum.Font.SourceSans,
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	ImageLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ImageButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false
	},

	ViewportFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	VideoFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},
	
	CanvasGroup = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	}
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX02b0d98a49b949d99db9671be18a9c6f">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Logging</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBXf4e6ca5abbe140fea9bf51dde0301221">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">logError</string>
									<string name="ScriptGuid">{c01881bc-85f1-41bf-9358-7fa5c8c0a6c0}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific error.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logError(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	error(errorString:gsub("\n", "\n    "), 0)
end

return logError]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXeba9317c7c1c425e8450d5b6f1a11be7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">logErrorNonFatal</string>
									<string name="ScriptGuid">{50d49336-430b-4682-ab1b-a7261013cbe6}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific error, without halting execution.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logErrorNonFatal(messageID: string, errObj: Types.Error?, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	task.spawn(function(...)
		error(errorString:gsub("\n", "\n    "), 0)
	end, ...)
end

return logErrorNonFatal]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXddfb347c90fe4e1f86f3e949f9881df2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">logWarn</string>
									<string name="ScriptGuid">{200a65f1-1957-4c19-bead-7bef8fd7c10b}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Utility function to log a Fusion-specific warning.
]]

local Package = script.Parent.Parent
local messages = require(Package.Logging.messages)

local function logWarn(messageID, ...)
	local formatString: string

	if messages[messageID] ~= nil then
		formatString = messages[messageID]
	else
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	warn(string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...))
end

return logWarn]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX33d7611123b54b1fa604c3a49c515206">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">messages</string>
									<string name="ScriptGuid">{10bd1bdc-5569-47de-99e4-1f1ed1f5fece}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores templates for different kinds of logging messages.
]]

return {
	cannotAssignProperty = "The class type '%s' has no assignable property '%s'.",
	cannotConnectChange = "The %s class doesn't have a property called '%s'.",
	cannotConnectEvent = "The %s class doesn't have an event called '%s'.",
	cannotCreateClass = "Can't create a new instance of class '%s'.",
	computedCallbackError = "Computed callback error: ERROR_MESSAGE",
	destructorNeededValue = "To save instances into Values, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededComputed = "To return instances from Computeds, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	multiReturnComputed = "Returning multiple values from Computeds is discouraged, as behaviour will change soon - see discussion #189 on GitHub.",
	destructorNeededForKeys = "To return instances from ForKeys, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForValues = "To return instances from ForValues, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	destructorNeededForPairs = "To return instances from ForPairs, provide a destructor function. This will be an error soon - see discussion #183 on GitHub.",
	duplicatePropertyKey = "",
	forKeysProcessorError = "ForKeys callback error: ERROR_MESSAGE",
	forKeysKeyCollision = "ForKeys should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previously input key: '%s'; New input key: '%s'",
	forKeysDestructorError = "ForKeys destructor error: ERROR_MESSAGE",
	forPairsDestructorError = "ForPairs destructor error: ERROR_MESSAGE",
	forPairsKeyCollision = "ForPairs should only write to output key '%s' once when processing key changes, but it wrote to it twice. Previous input pair: '[%s] = %s'; New input pair: '[%s] = %s'",
	forPairsProcessorError = "ForPairs callback error: ERROR_MESSAGE",
	forValuesProcessorError = "ForValues callback error: ERROR_MESSAGE",
	forValuesDestructorError = "ForValues destructor error: ERROR_MESSAGE",
	invalidChangeHandler = "The change handler for the '%s' property must be a function.",
	invalidEventHandler = "The handler for the '%s' event must be a function.",
	invalidPropertyType = "'%s.%s' expected a '%s' type, but got a '%s' type.",
	invalidRefType = "Instance refs must be Value objects.",
	invalidOutType = "[Out] properties must be given Value objects.",
	invalidOutProperty = "The %s class doesn't have a property called '%s'.",
	invalidSpringDamping = "The damping ratio for a spring must be >= 0. (damping was %.2f)",
	invalidSpringSpeed = "The speed of a spring must be >= 0. (speed was %.2f)",
	mistypedSpringDamping = "The damping ratio for a spring must be a number. (got a %s)",
	mistypedSpringSpeed = "The speed of a spring must be a number. (got a %s)",
	mistypedTweenInfo = "The tween info of a tween must be a TweenInfo. (got a %s)",
	springTypeMismatch = "The type '%s' doesn't match the spring's type '%s'.",
	strictReadError = "'%s' is not a valid member of '%s'.",
	unknownMessage = "Unknown error: ERROR_MESSAGE",
	unrecognisedChildType = "'%s' type children aren't accepted by `[Children]`.",
	unrecognisedPropertyKey = "'%s' keys aren't accepted in property tables.",
	unrecognisedPropertyStage = "'%s' isn't a valid stage for a special key to be applied at."
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX195b1346b65a40a6bed897f9a5ff9dfd">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">parseError</string>
									<string name="ScriptGuid">{76e5214c-292b-471f-b133-80a4c30c935a}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	An xpcall() error handler to collect and parse useful information about
	errors, such as clean messages and stack traces.

	TODO: this should have a 'type' field for runtime type checking!
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function parseError(err: string): Types.Error
	return {
		type = "Error",
		raw = err,
		message = err:gsub("^.+:%d+:%s*", ""),
		trace = debug.traceback(nil, 2)
	}
end

return parseError]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXa6dbe8381b7c40a3b1cd505547684113">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PubTypes</string>
								<string name="ScriptGuid">{6c883c98-b0b4-4ffa-b05a-e0a8eadc5289}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores common public-facing type information for Fusion APIs.
]]

type Set<T> = {[T]: any}

--[[
	General use types
]]

-- A unique symbolic value.
export type Symbol = {
	type: string, -- replace with "Symbol" when Luau supports singleton types
	name: string
}

-- Types that can be expressed as vectors of numbers, and so can be animated.
export type Animatable =
	number |
	CFrame |
	Color3 |
	ColorSequenceKeypoint |
	DateTime |
	NumberRange |
	NumberSequenceKeypoint |
	PhysicalProperties |
	Ray |
	Rect |
	Region3 |
	Region3int16 |
	UDim |
	UDim2 |
	Vector2 |
	Vector2int16 |
	Vector3 |
	Vector3int16

-- A task which can be accepted for cleanup.
export type Task =
	Instance |
	RBXScriptConnection |
	() -> () |
	{destroy: (any) -> ()} |
	{Destroy: (any) -> ()} |
	{Task}

-- Script-readable version information.
export type Version = {
	major: number,
	minor: number,
	isRelease: boolean
}
--[[
	Generic reactive graph types
]]

-- A graph object which can have dependents.
export type Dependency = {
	dependentSet: Set<Dependent>
}

-- A graph object which can have dependencies.
export type Dependent = {
	update: (Dependent) -> boolean,
	dependencySet: Set<Dependency>
}

-- An object which stores a piece of reactive state.
export type StateObject<T> = Dependency & {
	type: string, -- replace with "State" when Luau supports singleton types
	kind: string,
	get: (StateObject<T>, asDependency: boolean?) -> T
}

-- Either a constant value of type T, or a state object containing type T.
export type CanBeState<T> = StateObject<T> | T

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type Value<T> = StateObject<T> & {
	-- kind: "State" (add this when Luau supports singleton types)
 	set: (Value<T>, newValue: any, force: boolean?) -> ()
}

-- A state object whose value is derived from other objects using a callback.
export type Computed<T> = StateObject<T> & Dependent & {
	-- kind: "Computed" (add this when Luau supports singleton types)
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs<KO, VO> = StateObject<{ [KO]: VO }> & Dependent & {
	-- kind: "ForPairs" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForKeys<KO, V> = StateObject<{ [KO]: V }> & Dependent & {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}
-- A state object whose value is derived from other objects using a callback.
export type ForValues<K, VO> = StateObject<{ [K]: VO }> & Dependent & {
	-- kind: "ForKeys" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using tweens.
export type Tween<T> = StateObject<T> & Dependent & {
	-- kind: "Tween" (add this when Luau supports singleton types)
}

-- A state object which follows another state object using spring simulation.
export type Spring<T> = StateObject<T> & Dependent & {
	-- kind: "Spring" (add this when Luau supports singleton types)
	-- Uncomment when ENABLE_PARAM_SETTERS is enabled
	-- setPosition: (Spring<T>, newValue: Animatable) -> (),
	-- setVelocity: (Spring<T>, newValue: Animatable) -> (),
	-- addVelocity: (Spring<T>, deltaValue: Animatable) -> ()
}

-- An object which can listen for updates on another state object.
export type Observer = Dependent & {
	-- kind: "Observer" (add this when Luau supports singleton types)
  	onChange: (Observer, callback: () -> ()) -> (() -> ())
}

--[[
	Instance related types
]]

-- Denotes children instances in an instance or component's property table.
export type SpecialKey = {
	type: string, -- replace with "SpecialKey" when Luau supports singleton types
	kind: string,
	stage: string, -- replace with "self" | "descendants" | "ancestor" | "observer" when Luau supports singleton types
	apply: (SpecialKey, value: any, applyTo: Instance, cleanupTasks: {Task}) -> ()
}

-- A collection of instances that may be parented to another instance.
export type Children = Instance | StateObject<Children> | {[any]: Children}

-- A table that defines an instance's properties, handlers and children.
export type PropertyTable = {[string | SpecialKey]: any}

return nil]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX05ed9338071e4320b62fa03105cf946a">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">State</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX654657ac4953488e963ba32916ac186d">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Computed</string>
									<string name="ScriptGuid">{bc7705f9-c2cd-436c-a947-3993b9bc5280}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs and returns objects which can be used to model derived reactive
	state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local isSimilar = require(Package.Utility.isSimilar)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the last cached value calculated by this Computed object.
	The computed object will be registered as a dependency unless `asDependency`
	is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Recalculates this Computed's cached value and dependencies.
	Returns true if it changed, or false if it's identical.
]]
function class:update(): boolean
	-- remove this object from its dependencies' dependent sets
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	-- we need to create a new, empty dependency set to capture dependencies
	-- into, but in case there's an error, we want to restore our old set of
	-- dependencies. by using this table-swapping solution, we can avoid the
	-- overhead of allocating new tables each update.
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	local ok, newValue, newMetaValue = captureDependencies(self.dependencySet, self._processor)

	if ok then
		if self._destructor == nil and needsDestruction(newValue) then
			logWarn("destructorNeededComputed")
		end

		if newMetaValue ~= nil then
			logWarn("multiReturnComputed")
		end

		local oldValue = self._value
		local similar = isSimilar(oldValue, newValue)
		if self._destructor ~= nil then
			self._destructor(oldValue)
		end
		self._value = newValue

		-- add this object to the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return not similar
	else
		-- this needs to be non-fatal, because otherwise it'd disrupt the
		-- update process
		logErrorNonFatal("computedCallbackError", newValue)

		-- restore old dependencies, because the new dependencies may be corrupt
		self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet

		-- restore this object in the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return false
	end
end

local function Computed<T>(processor: () -> T, destructor: ((T) -> ())?): Types.Computed<T>
	local self = setmetatable({
		type = "State",
		kind = "Computed",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},
		_processor = processor,
		_destructor = destructor,
		_value = nil,
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return Computed]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4e3f706d49094405bfa6315797c3e8d2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ForKeys</string>
									<string name="ScriptGuid">{21b44cb0-3b82-4c39-9ab6-3a708cb51db8}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForKeys state object which maps keys of an array using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up
	calculated keys. If omitted, the default cleanup function will be used instead.

	Optionally, a `meta` value can be returned in the processor function as the
	second value to pass data from the processor to the destructor.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForKeys object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end


--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those key pairs, storing information about any
	dependencies used in the processor callback during output key generation,
	and save the new key to the output array with the same value. If it is
	overwriting an older value, that older value will be passed to the
	destructor for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their output keys from the output table and pass them to the destructor.
]]

function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable
	local outputTable = self._outputTable

	local keyOIMap = self._keyOIMap
	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find keys that changed or were not previously present
	for newInKey, value in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end

		-- check if the key is new
		local shouldRecalculate = oldInputTable[newInKey] == nil

		-- check if the key's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output key if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForKeys")
				end

				local oldInKey = keyOIMap[newOutKey]
				local oldOutKey = keyIOMap[newInKey]

				-- check for key collision
				if oldInKey ~= newInKey and newInputTable[oldInKey] ~= nil then
					logError("forKeysKeyCollision", nil, tostring(newOutKey), tostring(oldInKey), tostring(newOutKey))
				end

				-- check for a changed output key
				if oldOutKey ~= newOutKey and keyOIMap[oldOutKey] == newInKey then
					-- clean up the old calculated value
					local oldMetaValue = meta[oldOutKey]

					local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldMetaValue)
					if not destructOK then
						logErrorNonFatal("forKeysDestructorError", err)
					end

					keyOIMap[oldOutKey] = nil
					outputTable[oldOutKey] = nil
					meta[oldOutKey] = nil
				end

				-- update the stored data for this key
				oldInputTable[newInKey] = value
				meta[newOutKey] = newMetaValue
				keyOIMap[newOutKey] = newInKey
				keyIOMap[newInKey] = newOutKey
				outputTable[newOutKey] = value

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forKeysProcessorError", newOutKey)
			end
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find keys that were removed
	for outputKey, inputKey in pairs(keyOIMap) do
		if newInputTable[inputKey] == nil then
			-- clean up the old calculated value
			local oldMetaValue = meta[outputKey]

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, outputKey, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forKeysDestructorError", err)
			end

			-- remove data
			oldInputTable[inputKey] = nil
			meta[outputKey] = nil
			keyOIMap[outputKey] = nil
			keyIOMap[inputKey] = nil
			outputTable[outputKey] = nil
			self._keyData[inputKey] = nil

			-- if we removed a key, then the table/state changed
			didChange = true
		end
	end

	return didChange
end

local function ForKeys<KI, KO, M>(
	inputTable: PubTypes.CanBeState<{ [KI]: any }>,
	processor: (KI) -> (KO, M?),
	destructor: (KO, M?) -> ()?
): Types.ForKeys<KI, KO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForKeys",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_keyOIMap = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForKeys]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX021ff07a5bb740299499d934af6bd61d">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ForPairs</string>
									<string name="ScriptGuid">{bd099885-9734-4aa9-8783-28414b701d3d}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForPairs object which maps pairs of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForPairs object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- their associated value has changed
	- a dependency used during generation of this value has changed

	It will recalculate those key/value pairs, storing information about any
	dependencies used in the processor callback during value generation, and
	save the new key/value pair to the output array. If it is overwriting an
	older key/value pair, that older pair will be passed to the destructor
	for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their key/value pairs from the output table and pass them to the destructor.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local newInputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local oldInputTable = self._oldInputTable

	local keyIOMap = self._keyIOMap
	local meta = self._meta

	local didChange = false


	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- clean out output table
	self._oldOutputTable, self._outputTable = self._outputTable, self._oldOutputTable

	local oldOutputTable = self._oldOutputTable
	local newOutputTable = self._outputTable
	table.clear(newOutputTable)

	-- Step 1: find key/value pairs that changed or were not previously present

	for newInKey, newInValue in pairs(newInputTable) do
		-- get or create key data
		local keyData = self._keyData[newInKey]

		if keyData == nil then
			keyData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
			self._keyData[newInKey] = keyData
		end


		-- check if the pair is new or changed
		local shouldRecalculate = oldInputTable[newInKey] ~= newInValue

		-- check if the pair's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end


		-- recalculate the output pair if necessary
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local processOK, newOutKey, newOutValue, newMetaValue = captureDependencies(
				keyData.dependencySet,
				self._processor,
				newInKey,
				newInValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutKey) or needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForPairs")
				end

				-- if this key was already written to on this run-through, throw a fatal error.
				if newOutputTable[newOutKey] ~= nil then
					-- figure out which key/value pair previously wrote to this key
					local previousNewKey, previousNewValue
					for inKey, outKey in pairs(keyIOMap) do
						if outKey == newOutKey then
							previousNewValue = newInputTable[inKey]
							if previousNewValue ~= nil then
								previousNewKey = inKey
								break
							end
						end
					end

					if previousNewKey ~= nil then
						logError(
							"forPairsKeyCollision",
							nil,
							tostring(newOutKey),
							tostring(previousNewKey),
							tostring(previousNewValue),
							tostring(newInKey),
							tostring(newInValue)
						)
					end
				end

				local oldOutValue = oldOutputTable[newOutKey]

				if oldOutValue ~= newOutValue then
					local oldMetaValue = meta[newOutKey]
					if oldOutValue ~= nil then
						local destructOK, err = xpcall(self._destructor or cleanup, parseError, newOutKey, oldOutValue, oldMetaValue)
						if not destructOK then
							logErrorNonFatal("forPairsDestructorError", err)
						end
					end

					oldOutputTable[newOutKey] = nil
				end

				-- update the stored data for this key/value pair
				oldInputTable[newInKey] = newInValue
				keyIOMap[newInKey] = newOutKey
				meta[newOutKey] = newMetaValue
				newOutputTable[newOutKey] = newOutValue

				-- if we had to recalculate the output, then we did change
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("forPairsProcessorError", newOutKey)
			end
		else
			local storedOutKey = keyIOMap[newInKey]

			-- check for key collision
			if newOutputTable[storedOutKey] ~= nil then
				-- figure out which key/value pair previously wrote to this key
				local previousNewKey, previousNewValue
				for inKey, outKey in pairs(keyIOMap) do
					if storedOutKey == outKey then
						previousNewValue = newInputTable[inKey]

						if previousNewValue ~= nil then
							previousNewKey = inKey
							break
						end
					end
				end

				if previousNewKey ~= nil then
					logError(
						"forPairsKeyCollision",
						nil,
						tostring(storedOutKey),
						tostring(previousNewKey),
						tostring(previousNewValue),
						tostring(newInKey),
						tostring(newInValue)
					)
				end
			end

			-- copy the stored key/value pair into the new output table
			newOutputTable[storedOutKey] = oldOutputTable[storedOutKey]
		end


		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end

	-- STEP 2: find keys that were removed
	for oldOutKey, oldOutValue in pairs(oldOutputTable) do
		-- check if this key/value pair is in the new output table
		if newOutputTable[oldOutKey] ~= oldOutValue then
			-- clean up the old output pair
			local oldMetaValue = meta[oldOutKey]
			if oldOutValue ~= nil then
				local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldOutKey, oldOutValue, oldMetaValue)
				if not destructOK then
					logErrorNonFatal("forPairsDestructorError", err)
				end
			end

			-- check if the key was completely removed from the output table
			if newOutputTable[oldOutKey] == nil then
				meta[oldOutKey] = nil
				self._keyData[oldOutKey] = nil
			end

			didChange = true
		end
	end

	for key in pairs(oldInputTable) do
		if newInputTable[key] == nil then
			oldInputTable[key] = nil
			keyIOMap[key] = nil
		end
	end

	return didChange
end

local function ForPairs<KI, VI, KO, VO, M>(
	inputTable: PubTypes.CanBeState<{ [KI]: VI }>,
	processor: (KI, VI) -> (KO, VO, M?),
	destructor: (KO, VO, M?) -> ()?
): Types.ForPairs<KI, VI, KO, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForPairs",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_oldOutputTable = {},
		_keyIOMap = {},
		_keyData = {},
		_meta = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForPairs]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9e2151e3c88d4d029f3534bdeb34ac57">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ForValues</string>
									<string name="ScriptGuid">{c45c102a-8c71-48a0-ab9c-0011daab271b}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new ForValues object which maps values of a table using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.

	Additionally, a `meta` table/value can optionally be returned to pass data created
	when running the processor to the destructor when the created object is cleaned up.
]]
local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local logWarn = require(Package.Logging.logWarn)
local cleanup = require(Package.Utility.cleanup)
local needsDestruction = require(Package.Utility.needsDestruction)

local class = {}

local CLASS_METATABLE = { __index = class }
local WEAK_KEYS_METATABLE = { __mode = "k" }

--[[
	Returns the current value of this ForValues object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any values meeting any of the following criteria:

	- they were not previously present
	- a dependency used during generation of this value has changed

	It will recalculate those values, storing information about any dependencies
	used in the processor callback during value generation, and save the new value
	to the output array with the same key. If it is overwriting an older value,
	that older value will be passed to the destructor for cleanup.

	Finally, this function will find values that are no longer present, and remove
	their values from the output table and pass them to the destructor. You can re-use
	the same value multiple times and this will function will update them as little as
	possible; reusing the same values where possible.
]]
function class:update(): boolean
	local inputIsState = self._inputIsState
	local inputTable = if inputIsState then self._inputTable:get(false) else self._inputTable
	local outputValues = {}

	local didChange = false

	-- clean out value cache
	self._oldValueCache, self._valueCache = self._valueCache, self._oldValueCache
	local newValueCache = self._valueCache
	local oldValueCache = self._oldValueCache
	table.clear(newValueCache)

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add it as a dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end


	-- STEP 1: find values that changed or were not previously present
	for inKey, inValue in pairs(inputTable) do
		-- check if the value is new or changed
		local oldCachedValues = oldValueCache[inValue]
		local shouldRecalculate = oldCachedValues == nil

		-- get a cached value and its dependency/meta data if available
		local value, valueData, meta

		if type(oldCachedValues) == "table" and #oldCachedValues > 0 then
			local valueInfo = table.remove(oldCachedValues, #oldCachedValues)
			value = valueInfo.value
			valueData = valueInfo.valueData
			meta = valueInfo.meta

			if #oldCachedValues <= 0 then
				oldValueCache[inValue] = nil
			end
		elseif oldCachedValues ~= nil then
			oldValueCache[inValue] = nil
			shouldRecalculate = true
		end

		if valueData == nil then
			valueData = {
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE),
			}
		end

		-- check if the value's dependencies have changed
		if shouldRecalculate == false then
			for dependency, oldValue in pairs(valueData.dependencyValues) do
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end

		-- recalculate the output value if necessary
		if shouldRecalculate then
			valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet
			table.clear(valueData.dependencySet)

			local processOK, newOutValue, newMetaValue = captureDependencies(
				valueData.dependencySet,
				self._processor,
				inValue
			)

			if processOK then
				if self._destructor == nil and (needsDestruction(newOutValue) or needsDestruction(newMetaValue)) then
					logWarn("destructorNeededForValues")
				end

				-- pass the old value to the destructor if it exists
				if value ~= nil then
					local destructOK, err = xpcall(self._destructor or cleanup, parseError, value, meta)
					if not destructOK then
						logErrorNonFatal("forValuesDestructorError", err)
					end
				end

				-- store the new value and meta data
				value = newOutValue
				meta = newMetaValue
				didChange = true
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				valueData.oldDependencySet, valueData.dependencySet = valueData.dependencySet, valueData.oldDependencySet

				logErrorNonFatal("forValuesProcessorError", newOutValue)
			end
		end


		-- store the value and its dependency/meta data
		local newCachedValues = newValueCache[inValue]
		if newCachedValues == nil then
			newCachedValues = {}
			newValueCache[inValue] = newCachedValues
		end

		table.insert(newCachedValues, {
			value = value,
			valueData = valueData,
			meta = meta,
		})

		outputValues[inKey] = value


		-- save dependency values and add to main dependency set
		for dependency in pairs(valueData.dependencySet) do
			valueData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end


	-- STEP 2: find values that were removed
	-- for tables of data, we just need to check if it's still in the cache
	for _oldInValue, oldCachedValueInfo in pairs(oldValueCache) do
		for _, valueInfo in ipairs(oldCachedValueInfo) do
			local oldValue = valueInfo.value
			local oldMetaValue = valueInfo.meta

			local destructOK, err = xpcall(self._destructor or cleanup, parseError, oldValue, oldMetaValue)
			if not destructOK then
				logErrorNonFatal("forValuesDestructorError", err)
			end

			didChange = true
		end

		table.clear(oldCachedValueInfo)
	end

	self._outputTable = outputValues

	return didChange
end

local function ForValues<VI, VO, M>(
	inputTable: PubTypes.CanBeState<{ [any]: VI }>,
	processor: (VI) -> (VO, M?),
	destructor: (VO, M?) -> ()?
): Types.ForValues<VI, VO, M>

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ForValues",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_outputTable = {},
		_valueCache = {},
		_oldValueCache = {},
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ForValues]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXfdccd36915d44cf0903d3bf9a91af477">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Observer</string>
									<string name="ScriptGuid">{434a4fba-3f8f-455f-86b6-eb57149617b1}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs a new state object which can listen for updates on another state
	object.

	FIXME: enabling strict types here causes free types to leak
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local Types = require(Package.Types)
local initDependency = require(Package.Dependencies.initDependency)

type Set<T> = {[T]: any}

local class = {}
local CLASS_METATABLE = {__index = class}

-- Table used to hold Observer objects in memory.
local strongRefs: Set<Types.Observer> = {}

--[[
	Called when the watched state changes value.
]]
function class:update(): boolean
	for _, callback in pairs(self._changeListeners) do
		task.spawn(callback)
	end
	return false
end

--[[
	Adds a change listener. When the watched state changes value, the listener
	will be fired.

	Returns a function which, when called, will disconnect the change listener.
	As long as there is at least one active change listener, this Observer
	will be held in memory, preventing GC, so disconnecting is important.
]]
function class:onChange(callback: () -> ()): () -> ()
	local uniqueIdentifier = {}

	self._numChangeListeners += 1
	self._changeListeners[uniqueIdentifier] = callback

	-- disallow gc (this is important to make sure changes are received)
	strongRefs[self] = true

	local disconnected = false
	return function()
		if disconnected then
			return
		end
		disconnected = true
		self._changeListeners[uniqueIdentifier] = nil
		self._numChangeListeners -= 1

		if self._numChangeListeners == 0 then
			-- allow gc if all listeners are disconnected
			strongRefs[self] = nil
		end
	end
end

local function Observer(watchedState: PubTypes.Value<any>): Types.Observer
	local self = setmetatable({
		type = "State",
		kind = "Observer",
		dependencySet = {[watchedState] = true},
		dependentSet = {},
		_changeListeners = {},
		_numChangeListeners = 0,
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the watched state's dependent set
	watchedState.dependentSet[self] = true

	return self
end

return Observer]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX94e2f786445b4664ae249a190c272511">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Value</string>
									<string name="ScriptGuid">{ff00ac94-b177-40af-847c-a5fdd3686a15}</string>
									<ProtectedString name="Source"><![CDATA[--!nonstrict

--[[
	Constructs and returns objects which can be used to model independent
	reactive state.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)
local isSimilar = require(Package.Utility.isSimilar)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the value currently stored in this State object.
	The state object will be registered as a dependency unless `asDependency` is
	false.
]]
function class:get(asDependency: boolean?): any
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Updates the value stored in this State object.

	If `force` is enabled, this will skip equality checks and always update the
	state object and any dependents - use this with care as this can lead to
	unnecessary updates.
]]
function class:set(newValue: any, force: boolean?)
	local oldValue = self._value
	if force or not isSimilar(oldValue, newValue) then
		self._value = newValue
		updateAll(self)
	end
end

local function Value<T>(initialValue: T): Types.State<T>
	local self = setmetatable({
		type = "State",
		kind = "Value",
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_value = initialValue
	}, CLASS_METATABLE)

	initDependency(self)

	return self
end

return Value]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXb689e55656814a85999901c529d1cfb8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">unwrap</string>
									<string name="ScriptGuid">{4db0c898-32ec-4954-84ae-019966c39639}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A common interface for accessing the values of state objects or constants.
]]

local Package = script.Parent.Parent
local PubTypes = require(Package.PubTypes)
local xtypeof = require(Package.Utility.xtypeof)

local function unwrap<T>(item: PubTypes.CanBeState<T>, useDependency: boolean?): T
	return if xtypeof(item) == "State" then (item :: PubTypes.StateObject<T>):get(useDependency) else (item :: T)
end

return unwrap]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX97994e67130544ca95401a2edb55cbfe">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Types</string>
								<string name="ScriptGuid">{ed27d35b-c6aa-4fa1-91e5-c61fee52664d}</string>
								<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Stores common type information used internally.

	These types may be used internally so Fusion code can type-check, but
	should never be exposed to public users, as these definitions are fair game
	for breaking changes.
]]

local Package = script.Parent
local PubTypes = require(Package.PubTypes)

type Set<T> = {[T]: any}

--[[
	General use types
]]

-- A symbol that represents the absence of a value.
export type None = PubTypes.Symbol & {
	-- name: "None" (add this when Luau supports singleton types)
}

-- Stores useful information about Luau errors.
export type Error = {
	type: string, -- replace with "Error" when Luau supports singleton types
	raw: string,
	message: string,
	trace: string
}

--[[
	Specific reactive graph types
]]

-- A state object whose value can be set at any time by the user.
export type State<T> = PubTypes.Value<T> & {
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type Computed<T> = PubTypes.Computed<T> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_callback: () -> T,
	_value: T
}

-- A state object whose value is derived from other objects using a callback.
export type ForPairs<KI, VI, KO, VO, M> = PubTypes.ForPairs<KO, VO> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (KI, VI) -> (KO, VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [KI]: VI }>,
	_oldInputTable: { [KI]: VI },
	_outputTable: { [KO]: VO },
	_oldOutputTable: { [KO]: VO },
	_keyIOMap: { [KI]: KO },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForKeys<KI, KO, M> = PubTypes.ForKeys<KO, any> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (KI) -> (KO),
	_destructor: (KO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [KI]: KO }>,
	_oldInputTable: { [KI]: KO },
	_outputTable: { [KO]: any },
	_keyOIMap: { [KO]: KI },
	_meta: { [KO]: M? },
	_keyData: {
		[KI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object whose value is derived from other objects using a callback.
export type ForValues<VI, VO, M> = PubTypes.ForValues<any, VO> & {
	_oldDependencySet: Set<PubTypes.Dependency>,
	_processor: (VI) -> (VO),
	_destructor: (VO, M?) -> (),
	_inputIsState: boolean,
	_inputTable: PubTypes.CanBeState<{ [VI]: VO }>,
	_outputTable: { [any]: VI },
	_valueCache: { [VO]: any },
	_oldValueCache: { [VO]: any },
	_meta: { [VO]: M? },
	_valueData: {
		[VI]: {
			dependencySet: Set<PubTypes.Dependency>,
			oldDependencySet: Set<PubTypes.Dependency>,
			dependencyValues: { [PubTypes.Dependency]: any },
		},
	},
}

-- A state object which follows another state object using tweens.
export type Tween<T> = PubTypes.Tween<T> & {
	_goalState: State<T>,
	_tweenInfo: TweenInfo,
	_prevValue: T,
	_nextValue: T,
	_currentValue: T,
	_currentTweenInfo: TweenInfo,
	_currentTweenDuration: number,
	_currentTweenStartTime: number,
	_currentlyAnimating: boolean
}

-- A state object which follows another state object using spring simulation.
export type Spring<T> = PubTypes.Spring<T> & {
	_speed: PubTypes.CanBeState<number>,
	_speedIsState: boolean,
	_lastSpeed: number,
	_damping: PubTypes.CanBeState<number>,
	_dampingIsState: boolean,
	_lastDamping: number,
	_goalState: State<T>,
	_goalValue: T,
	_currentType: string,
	_currentValue: T,
	_springPositions: {number},
	_springGoals: {number},
	_springVelocities: {number}
}

-- An object which can listen for updates on another state object.
export type Observer = PubTypes.Observer & {
	_changeListeners: Set<() -> ()>,
	_numChangeListeners: number
}

return nil]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX96476e5c29264d47b3c8a36347cd7184">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<string name="Name">Utility</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX82d4f1f1644e4c72807d8b921c473bcc">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">None</string>
									<string name="ScriptGuid">{9627a6e0-3981-4c02-bcf1-5efdf6b31821}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	A symbol for representing nil values in contexts where nil is not usable.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

return {
	type = "Symbol",
	name = "None"
} :: Types.None]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXbe0db304527f41919692978706ef1b91">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">cleanup</string>
									<string name="ScriptGuid">{6940fdf4-e2c2-4f6a-a8bd-e602267acbe1}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Cleans up the tasks passed in as the arguments.
	A task can be any of the following:

	- an Instance - will be destroyed
	- an RBXScriptConnection - will be disconnected
	- a function - will be run
	- a table with a `Destroy` or `destroy` function - will be called
	- an array - `cleanup` will be called on each item
]]

local function cleanupOne(task: any)
	local taskType = typeof(task)

	-- case 1: Instance
	if taskType == "Instance" then
		task:Destroy()

	-- case 2: RBXScriptConnection
	elseif taskType == "RBXScriptConnection" then
		task:Disconnect()

	-- case 3: callback
	elseif taskType == "function" then
		task()

	elseif taskType == "table" then
		-- case 4: destroy() function
		if typeof(task.destroy) == "function" then
			task:destroy()

		-- case 5: Destroy() function
		elseif typeof(task.Destroy) == "function" then
			task:Destroy()

		-- case 6: array of tasks
		elseif task[1] ~= nil then
			for _, subtask in ipairs(task) do
				cleanupOne(subtask)
			end
		end
	end
end

local function cleanup(...: any)
	for index = 1, select("#", ...) do
		cleanupOne(select(index, ...))
	end
end

return cleanup]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX021f14bed5534fdca5d232d69f8c0c31">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">doNothing</string>
									<string name="ScriptGuid">{3ab4ca46-3136-4fc5-9ebc-1e7c92dc30be}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	An empty function. Often used as a destructor to indicate no destruction.
]]

local function doNothing(...: any)
end

return doNothing]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXe8de98bdf80c4577ae81fa086deca4b2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">isSimilar</string>
									<string name="ScriptGuid">{ac26b6d1-e761-407c-9457-140c3df227e7}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
--[[
    Returns true if A and B are 'similar' - i.e. any user of A would not need
    to recompute if it changed to B.
]]

local function isSimilar(a: any, b: any): boolean
    -- HACK: because tables are mutable data structures, don't make assumptions
    -- about similarity from equality for now (see issue #44)
    if typeof(a) == "table" then
        return false
    else
        return a == b
    end
end

return isSimilar]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX1773132b16394814bb627d28a3722af9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">needsDestruction</string>
									<string name="ScriptGuid">{00ff37e2-74d6-4346-a8f5-15a1b9ed47bc}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
    Returns true if the given value is not automatically memory managed, and
    requires manual cleanup.
]]

local function needsDestruction(x: any): boolean
    return typeof(x) == "Instance"
end

return needsDestruction]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXeb31c72d2e5c49a28a89b6384e4a3d8a">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">restrictRead</string>
									<string name="ScriptGuid">{f4aaaf9a-5a85-48aa-9f52-5b78299965a2}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Restricts the reading of missing members for a table.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)

type table = {[any]: any}

local function restrictRead(tableName: string, strictTable: table): table
	-- FIXME: Typed Luau doesn't recognise this correctly yet
	local metatable = getmetatable(strictTable :: any)

	if metatable == nil then
		metatable = {}
		setmetatable(strictTable, metatable)
	end

	function metatable:__index(memberName)
		logError("strictReadError", nil, tostring(memberName), tableName)
	end

	return strictTable
end

return restrictRead]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX67efc950418349f19f69ea54d609cf9a">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">xtypeof</string>
									<string name="ScriptGuid">{0a456a85-cf7e-4a51-bfd5-d8cbc8b31c0d}</string>
									<ProtectedString name="Source"><![CDATA[--!strict

--[[
	Extended typeof, designed for identifying custom objects.
	If given a table with a `type` string, returns that.
	Otherwise, returns `typeof()` the argument.
]]

local function xtypeof(x: any)
	local typeString = typeof(x)

	if typeString == "table" and typeof(x.type) == "string" then
		return x.type
	else
		return typeString
	end
end

return xtypeof]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX1d009a4b3d5d4e32aa8bbfa50ed49dce">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">flamenco687_maid@3.2.2</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXf55c99bbe80949a2b4663cdfbd1c16b0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">maid</string>
							<string name="ScriptGuid">{4ccfdc8e-68a5-40a0-9aff-ee5dcb0fb5cf}</string>
							<ProtectedString name="Source"><![CDATA[-- finobinos - Original author - 16 October 2021
-- flamenco687 - Modified for personal use - 1 November 2021

--[[
	-- Static methods:

	Maid.new() --> table
	Maid.IsMaid(self : any) --> boolean

	-- Instance methods:

	Maid:GiveTask(task : table | function | RBXScriptConnection | Instance) --> task
	Maid:Cleanup() --> ()
	Maid:EndTask(task: table | function | RBXScriptConnection | Instanceble) --> ()
	Maid:RemoveTask(task: table | function | RBXScriptConnection | Instance) --> ()
	Maid:LinkToInstance(instance: Instance) --> (instance, ManualConnection)
		ManualConnection:Disconnect() --> ()
		ManualConnection:IsConnected() --> boolean
	Maid:Destroy() --> ()
]]

--[=[
	@class Maid
	Maids track tasks and clean them when needed.

	For e.g:
	```lua
	local maid = Maid.new()
	local connection = workspace.ChildAdded:Connect(function()

	end)
	maid:GiveTask(connection)
	maid:Cleanup()

	-- Connections aren't necessarily immediately disconnected when `Disconnect` is called on the.
	-- Much reliable to check in the next engine execution step:
	task.defer(function()
		print(connection.Connected) --> false
	end)
	```
]=]

local Maid = {}
Maid.__index = Maid

local Players = game:GetService("Players")

local LocalConstants = {
	ErrorMessages = {
		InvalidArgument = "Invalid argument#%d to %s: expected %s, got %s",
	},
}

local function IsInstanceDestroyed(instance)
	-- This function call is used to determine if an instance is ALREADY destroyed,
	-- and has been edited to be more reliable but still quite hacky due to Roblox
	-- not giving us a method to determine if an instance is already destroyed
	local _, response = pcall(function()
		instance.Parent = instance
	end)

	return (response:find("locked") and response:find("NULL") or nil) ~= nil
end

local function DisconnectTask(task)
	if typeof(task) == "function" then
		task()
	elseif typeof(task) == "RBXScriptConnection" then
		-- Task was a RBXScriptConneciton or a table with a Disconnect method
		task:Disconnect()
	else
		if task.Destroy then
			task:Destroy()
		else
			task:Disconnect()
		end
	end
end

--[=[
	A constructor method which creates a new maid.

	@return Maid 
]=]

function Maid.new()
	return setmetatable({
		_tasks = {},
	}, Maid)
end

--[=[
	A method which is used to check if the given argument is a maid or not.

	@param self any 
	@return boolean 
]=]

function Maid.IsMaid(self)
	return getmetatable(self) == Maid
end

--[=[
	Adds a task for the maid to cleanup. Note that `table` must have a `Destroy` or `Disconnect` method.

	@tag Maid
	@param task function | RBXScriptConnection | table | Instance
	@return task
]=]

function Maid:GiveTask(task)
	assert(
		typeof(task) == "function"
			or typeof(task) == "RBXScriptConnection"
			or typeof(task) == "table" and (typeof(task.Destroy) == "function" or typeof(task.Disconnect) == "function")
			or typeof(task) == "Instance",

		LocalConstants.ErrorMessages.InvalidArgument:format(
			1,
			"Maid:GiveTask()",
			"function or RBXScriptConnection or Instance or table with Destroy or Disconnect method",
			typeof(task)
		)
	)

	self._tasks[task] = task

	return task
end

--[=[
	Removes the task so that it will not be cleaned up. 

	@tag Maid
	@param task function | RBXScriptConnection | table | Instance 
]=]

function Maid:RemoveTask(task)
	self._tasks[task] = nil
end

--[=[
	Cleans up all the added tasks.
	@tag Maid

	| Task      | Type                          |
	| ----------- | ------------------------------------ |
	| `function`  | The function will be called.  |
	| `table`     | Any `Destroy` or `Disconnect` method in the table will be called. |
	| `Instance`    | The instance will be destroyed. |
	| `RBXScriptConnection`    | The connection will be disconnected. |
]=]

function Maid:Cleanup()
	-- Next allows us to easily traverse the table accounting for more values being added. This allows us to clean
	-- up tasks spawned by the cleaning up of current tasks.

	local tasks = self._tasks
	local key, task = next(tasks)

	while task do
		tasks[key] = nil

		DisconnectTask(task)

		key, task = next(tasks)
	end
end

--[=[
	@tag Maid

	Disconnect a specific task

	@param task -- Task to disconnect
]=]

function Maid:EndTask(task)
	self._tasks[task] = nil
	DisconnectTask(task)
end

--[=[
	@tag Maid

	Destroys the maid by first cleaning up all tasks, and then setting all the keys in it to `nil`
	and lastly, sets the metatable of the maid to `nil`.

	:::warning
	Trivial errors will occur if your code unintentionally works on a destroyed maid, only call this method when you're done working with the maid.
	:::
]=]

function Maid:Destroy()
	self:Cleanup()

	for key, _ in pairs(self) do
		self[key] = nil
	end

	setmetatable(self, nil)
end

local ManualConnection = {}
ManualConnection.__index = ManualConnection

do
	function ManualConnection.new()
		return setmetatable({ _isConnected = true }, ManualConnection)
	end

	function ManualConnection:Disconnect()
		self._isConnected = false
	end

	function ManualConnection:IsConnected()
		return self._isConnected
	end
end

--[=[
	Links the given instance to the maid so that the maid will clean up all the tasks once the instance has been destroyed
	via `Instance:Destroy`. The connection returned by this maid contains the following methods:

	| Methods      | Description                          |
	| ----------- | ------------------------------------ |
	| `Disconnect`  | The connection will be disconnected and the maid will unlink to the instance it was linked to.  |
	| `IsConnected` | Returns a boolean indicating if the connection has been disconnected. |

	Note that the maid will still unlink to the given instance if it has been cleaned up!

	@param instance Instance
	@return Connection 
]=]

function Maid:LinkToInstance(instance)
	assert(
		typeof(instance) == "Instance",
		LocalConstants.ErrorMessages.InvalidArgument:format(1, "Maid:LinkToInstance()", "Instance", typeof(instance))
	)

	local manualConnection = ManualConnection.new()
	self:GiveTask(manualConnection)

	local function TrackInstanceConnectionForCleanup(mainConnection)
		while mainConnection.Connected and not instance.Parent and manualConnection:IsConnected() do
			task.wait()
		end

		if not instance.Parent and manualConnection:IsConnected() then
			self:Cleanup()
		end
	end

	local mainConnection
	mainConnection = self:GiveTask(instance:GetPropertyChangedSignal("Parent"):Connect(function()
		if not instance.Parent then
			task.defer(function()
				if not manualConnection:IsConnected() then
					return
				end

				-- If the connection has also been disconnected, then its
				-- guaranteed that the instance has been destroyed through
				-- Destroy():
				if not mainConnection.Connected then
					self:Cleanup()
				else
					-- The instance was just parented to nil:
					TrackInstanceConnectionForCleanup(mainConnection)
				end
			end)
		end
	end))
	self:GiveTask(mainConnection)

	-- Special case for players as they are destroyed late when they leave:
	if instance:IsA("Player") then
		self:GiveTask(Players.PlayerRemoving:Connect(function(playerRemoved)
			if instance == playerRemoved and manualConnection:IsConnected() then
				self:Cleanup()
			end
		end))
	end

	if not instance.Parent then
		task.spawn(TrackInstanceConnectionForCleanup, mainConnection)
	end

	if IsInstanceDestroyed(instance) then
		self:Cleanup()
	end

	return manualConnection
end

return Maid]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXbf1418ea777b429495704dc3c5f87bab">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">wally</string>
								<string name="ScriptGuid">{36294d12-d014-49d8-b778-1e9c9204e3ef}</string>
								<ProtectedString name="Source"><![CDATA[return {
	package = {
		authors = {"finobinos", "flamenco687"},
		description = "Maid class",
		license = "Apache-2.0",
		name = "flamenco687/maid",
		realm = "shared",
		registry = "https://github.com/UpliftGames/wally-index",
		version = "3.2.2",
	},
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBXe05d741882b847769a1962dd84bde206">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Interface</string>
				<string name="ScriptGuid">{3c8c32d1-dfc7-429b-93e6-6582a76f4886}</string>
				<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Wednesday September 6th 2023 2:21:48 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Tuesday July 9th 2024 10:58:37 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--[[
Interface

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = Interface.TopLevel('foo')
   

DESCRIPTION

    A detailed description of the module.

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of Interface.

--// Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")

--// Modules
local Fusion = require(ReplicatedStorage.BoomBoxPackages.Fusion)
local Maid = require(ReplicatedStorage.BoomBoxPackages.Maid)

--// Types
type Connections = { [string]: RBXScriptConnection }

--// Class
local Interface = {}
Interface.__index = Interface
Interface.ClassName = "Interface"

--// Variables
local PagesFolder = script.Pages
local Handlers = script.Handlers

local Handler_Interface = require(Handlers.Handlers_Interface)

local Pages = {
	["Root"] = require(PagesFolder.Root),
}

local function createScreenGui()
	local ScreenGui = Instance.new("ScreenGui")
	ScreenGui.Parent = Players.LocalPlayer.PlayerGui
	ScreenGui.DisplayOrder = 5
	ScreenGui.IgnoreGuiInset = false
	ScreenGui.ResetOnSpawn = false
	ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	ScreenGui.Name = "AudioscapeBoomBox"

	Handler_Interface:Set("ScreenGui", ScreenGui)

	return ScreenGui
end

function Interface.new()
	local info = {
		Handler = Handler_Interface,
		Connections = {},
	}

	setmetatable(info, Interface):Init()
	return info
end

function Interface:ToggleBlur(Blur: BlurEffect, Active: boolean)
	if Blur.Parent == nil then
		self.Blur = Instance.new("BlurEffect")
		self.Blur.Size = 0
		self.Blur.Parent = game.Lighting
		Blur = self.Blur
	end
end

function Interface:Init()
	self.Blur = Instance.new("BlurEffect")
	self.Blur.Size = 0
	self.Blur.Parent = game.Lighting

	self.Trees = {}
	self.ScreenGui = createScreenGui()
	self.Connections = Maid.new()

	self:signals()
	self:mountScreen("Root")
end

function Interface:signals()
	Handler_Interface:SubscribeToState("Page", function(Page: string, Active: boolean, ToggleBlur: boolean)
		if ToggleBlur then
			self:ToggleBlur(self.Blur, Active)
		end

		if Page == "Store" then
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, not Active)
		end
	end)
end

function Interface:connections()
	Handler_Interface.UnmountScreen.Event:Connect(function(ScreenName)
		self:unmountScreen(ScreenName)
	end)
	Handler_Interface.MountScreen.Event:Connect(function(ScreenName)
		self:mountScreen(ScreenName)
	end)
end

function Interface:unmountSafeGuard(ScreenName)
	local ActiveTree = self.Trees[ScreenName]
	if ActiveTree then
		return ActiveTree
	end
	return false
end

function Interface:mountSafeGuard(ScreenName)
	local Page = Pages[ScreenName]
	local ActiveTree = self.Trees[ScreenName]
	if Page and not ActiveTree then
		return true
	end
	return false
end

function Interface:mountScreen(ScreenName, props, Cleanup)
	if self:mountSafeGuard(ScreenName) then
		self.Trees[ScreenName] = Pages[ScreenName](props or {}, Cleanup or function()
			print("Cleaning up " .. ScreenName)
		end)
		self.Trees[ScreenName].Parent = self.ScreenGui
	end
end

function Interface:unmountScreen(ScreenName)
	local ActiveTree = self.Trees[ScreenName]
	if self:unmountSafeGuard(ScreenName) then
		ActiveTree:Destroy()
		self.Trees[ScreenName] = nil
	end
end

function Interface:disconnect()
	local Connections: typeof(Maid.new()) = self.Connections
end

function Interface:destroy()
	self:Disconnect()

	setmetatable(self, nil)
	table.clear(self)
	table.freeze(self)
end

return Interface.new()]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBX5297316701eb4419abcd1b6e31c4ce2b">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Components</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXc386d4b749cf441c9b53aab506c26aad">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">AudioPlayer</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXe4971e27294c4248b98a3c284d196959">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AudioControls</string>
							<string name="ScriptGuid">{e8ef751a-8d84-4322-8b69-31bf21bd70b1}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local Like = require(script.Like)
local Skip = require(script.Skip)
local Play = require(script.Play)
local Queue = require(script.Queue)
local Rewind = require(script.Rewind)
local Volume = require(script.Volume)
local Shuffle = require(script.Shuffle)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type AudioControlsProps = {}

return function(props: AudioControlsProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local AudioControls = New("Frame")({
		Name = "AudioControls",
		AnchorPoint = Vector2.new(0, 1),
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.new(0, 0, 1, -15),
		Size = UDim2.new(1, 0, 0.0628, 25),

		[Children] = {
			Like({}),
			Skip({}),
			Play({}),
			Queue({}),
			Rewind({}),
			Volume({}),
			Shuffle({}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0, 5),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Bottom,
			}),
		},
	})

	return AudioControls
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXe88dfb126c6b4b03a71a671a3d0b4674">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Like</string>
								<string name="ScriptGuid">{7ed42405-abfb-462d-8bad-8afb5af7ee4b}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PlayProps = {}

return function(props: PlayProps)
	--// Value States
	local Active = Value(true)

	local Play = ImageButton({
		Name = "Play",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 3,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		Image = "",
		BackgroundTransparency = 1,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,
		AspectRatio = 1.2,

		OnClick = function()
			local Liked = Handler_Interface:GetState("PlayingLiked")

			Liked:set(not Liked:get())

			local Song = Handler_Interface:Get("Sound")

			if not Song then
				return
			end

			local Payload = {
				asset_id = Song.asset_id,
			}

			Handler_Interface:Fire("LikeEvent", Payload, Liked:get())
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = Computed(function()
					return Handler_Interface:Get("PlayingLiked") and Images.Icons.LikedImage
						or Images.Icons.UnlikedImage
				end),
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.5, 0.5),
			}),
		},
	})

	return Play
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0d4d264cba5a444a9eecbca79b2cb771">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Play</string>
								<string name="ScriptGuid">{d4d8aa49-adec-4342-bfa2-35715f3fec8d}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PlayProps = {}

return function(props: PlayProps)
	--// Value States
	local Active = Value(true)

	local Play = ImageButton({
		Name = "Play",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 1,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", 0)

			Handler_Interface:Set("AutoPlay", true)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = Computed(function()
					return Handler_Interface:Get("SoundPlaying") and "rbxassetid://18935458228"
						or "rbxassetid://18935457772"
				end),
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.5, 0.5),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),
		},
	})

	return Play
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX027a8fdb06ab4f9f9941cf1e890258e0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Queue</string>
								<string name="ScriptGuid">{dd46af06-c4df-4401-939c-5817f4c5b628}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type QueueProps = {}

return function(props: QueueProps)
	--// Value States
	local Active = Value(true)

	local Queue = ImageButton({
		Name = "Queue",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -3,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 1,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Set("Page", "Queue")
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = Images.Icons.Queue,
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.5, 0.5),
			}),
		},
	})

	return Queue
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX50ca3335a3d34113948156806cb6a4db">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Rewind</string>
								<string name="ScriptGuid">{bc70cc33-9d7c-4bd1-a773-20d3222b6309}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type RewindProps = {}

return function(props: RewindProps)
	--// Value States
	local Active = Value(true)

	local Rewind = ImageButton({
		Name = "Rewind",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -1,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", -1)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935457399",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.44, 0.294),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 1.5,
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),
		},
	})

	return Rewind
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX837a02c735c24097bed07186feda62fb">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Shuffle</string>
								<string name="ScriptGuid">{c6f8493a-cc64-4407-9cfa-1bc9509893b7}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type ShuffleProps = {}

return function(props: ShuffleProps)
	--// Value States
	local Active = Value(true)

	local Shuffle = ImageButton({
		Name = "Shuffle",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -2,

		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		Image = "",
		BackgroundTransparency = 1,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,
		AspectRatio = 1,

		OnClick = function()
			Handler_Interface:Set("Shuffling", not Handler_Interface:Get("Shuffling"))
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = Images.Icons.Shuffle,
				AnchorPoint = Vector2.new(0.5, 0.5),
				ImageTransparency = Tween(
					Computed(function()
						return Handler_Interface:Get("Shuffling") and 0 or 0.5
					end),
					Tweens.Fast
				),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.5, 0.5),
			}),
		},
	})

	return Shuffle
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX79287df646584bd3909344bbfedd1308">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Skip</string>
								<string name="ScriptGuid">{0caa5ebb-bee6-49de-aff2-6cae19d94f42}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SkipProps = {}

return function(props: SkipProps)
	--// Value States
	local Active = Value(true)

	local Skip = ImageButton({
		Name = "Skip",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 2,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.556, 1),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", 1)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935457202",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.44, 0.294),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 1.5,
					}),
				},
			}),
		},
	})

	return Skip
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXba705fb1f9f14e61ae70d29b68bc4c65">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Volume</string>
								<string name="ScriptGuid">{3cc6eb05-5cdb-4cce-9e91-d72efb2087b4}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type VolumeBarProps = {}

return function(props: VolumeBarProps)
	--// Value States
	local Active = Value(false)
	local Dragging = Value(false)

	--// Refs
	local MarkerRef = Value()
	local ProgressBarRef = Value()

	local VolumeBar = New("Frame")({
		Name = "VolumeBarContainer",
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 4,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(0.2, 1),

		Visible = Computed(function()
			return Handler_Interface:Get("PlayerVisible")
		end),

		[Children] = {
			New("ImageButton")({
				[Ref] = ProgressBarRef,
				Name = "VolumeBar",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 0.8,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 4,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.new(1, 0, 0, 5),

				[OnEvent("MouseButton1Click")] = function()
					local Mouse = Players.LocalPlayer:GetMouse()
					local ProgressBar = ProgressBarRef:get() :: ImageButton
					local AudioPlayer = Handler_Interface:Get("AudioPlayer") :: Sound

					local ClickedPercent = math.clamp(
						(Vector2.new(Mouse.X, Mouse.Y) - ProgressBar.AbsolutePosition).X,
						0,
						ProgressBar.AbsoluteSize.X
					) / ProgressBar.AbsoluteSize.X

					Handler_Interface:Set("VolumePercent", ClickedPercent)
					Handler_Interface:Set("Volume", ClickedPercent * Handler_Interface:Get("MaxVolume"))
					if not Handler_Interface:Get("BoomboxVisible") then
						AudioPlayer.Volume = ClickedPercent * Handler_Interface:Get("MaxVolume")
					else
						AudioPlayer.Volume = 0
					end

					Handler_Interface:Fire("BoomboxEventMediator", "Volume")
				end,

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
					}),

					New("Frame")({
						Name = "VolumeBarFill",
						AnchorPoint = Vector2.new(0, 1),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0, 1),
						Size = UDim2.fromScale(0.5, 1),

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
							}),

							New("ImageButton")({
								[Ref] = MarkerRef,
								Name = "ProgressMark",
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(1, 0.5),
								Size = UDim2.fromOffset(10, 10),

								[OnEvent("MouseButton1Down")] = function(Temp, Temp2)
									Dragging:set(true)

									local Connection
									local ImageButton = MarkerRef:get() :: ImageButton

									local Mouse = Players.LocalPlayer:GetMouse()
									local ProgressBar = ProgressBarRef:get() :: ImageButton
									local AudioPlayer = Handler_Interface:Get("AudioPlayer") :: Sound

									Connection = UserInputService.InputEnded:Connect(function(input)
										if input.UserInputType == Enum.UserInputType.MouseButton1 then
											Connection:Disconnect()
											Dragging:set(false)
											RunService:UnbindFromRenderStep("Dragging")
											Handler_Interface:Fire("BoomboxEventMediator", "Volume")
										end
									end)

									RunService:BindToRenderStep("Dragging", 0, function(delta: number)
										local ClickedPercent = math.clamp(
											(Vector2.new(Mouse.X, Mouse.Y) - ProgressBar.AbsolutePosition).X,
											0,
											ProgressBar.AbsoluteSize.X
										) / ProgressBar.AbsoluteSize.X

										ImageButton.Parent.Size = UDim2.fromScale(ClickedPercent, 1)
										Handler_Interface:Set("VolumePercent", ClickedPercent)
										Handler_Interface:Set(
											"Volume",
											ClickedPercent * Handler_Interface:Get("MaxVolume")
										)

										if not Handler_Interface:Get("BoomboxVisible") then
											AudioPlayer.Volume = ClickedPercent * Handler_Interface:Get("MaxVolume")
										else
											AudioPlayer.Volume = 0
										end
									end)
								end,

								[OnEvent("MouseButton1Up")] = function(Temp, Temp2)
									Dragging:set(false)
									RunService:UnbindFromRenderStep("Dragging")
								end,

								[Children] = {
									New("UIAspectRatioConstraint")({
										Name = "UIAspectRatioConstraint",
									}),

									New("UICorner")({
										Name = "UICorner",
										CornerRadius = UDim.new(1, 0),
									}),
								},
							}),
						},
					}),

					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 8.43,
					}),
				},
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),
		},
	})

	return VolumeBar
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX770e81ae5ce5407ba15b9122aa4c5a6c">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AudioControlsVertical</string>
							<string name="ScriptGuid">{388f965c-1d2a-4cc6-b514-35e83765d26d}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
	ListPadding = 0.1,
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local Play = require(script.Play)
local Skip = require(script.Skip)
local Rewind = require(script.Rewind)

local AudioScapeButton = require(LocalComponents.AudioscapeButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type AudioControlsProps = {}

return function(props: AudioControlsProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local AudioControls = New("Frame")({
		Name = "AudioControls",
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.5, 0.5),
		Size = UDim2.fromScale(1, 1),

		[Children] = {
			AudioScapeButton({}),
			Play({}),
			Skip({}),
			Rewind({}),

			New("UIPadding")({
				Name = "UIPadding",
				PaddingBottom = UDim.new(Settings.ListPadding, 0),
				PaddingLeft = UDim.new(Settings.ListPadding, 0),
				PaddingRight = UDim.new(Settings.ListPadding, 0),
				PaddingTop = UDim.new(Settings.ListPadding, 0),
			}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0, 5),
				FillDirection = Enum.FillDirection.Vertical,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),
		},
	})

	return AudioControls
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXf0b8622a89814622a263eaf05cca7404">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Play</string>
								<string name="ScriptGuid">{cfd4d00d-a411-4973-bc10-d72e4bf67872}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PlayProps = {}

return function(props: PlayProps)
	--// Value States
	local Active = Value(true)

	local Play = ImageButton({
		Name = "Play",
		Active = Handler_Interface:GetState("PlayerHidden"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 1,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(1, 0.25),

		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", 0)
			Handler_Interface:Set("AutoPlay", true)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = Computed(function()
					return Handler_Interface:Get("SoundPlaying") and "rbxassetid://18935458228"
						or "rbxassetid://18935457772"
				end),
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.5, 0.5),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),
		},
	})

	return Play
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX9ed3d897dae445ed866620d3022cdb9a">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Rewind</string>
								<string name="ScriptGuid">{3095d995-b076-4e11-885a-0fd18d3c7440}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type RewindProps = {}

return function(props: RewindProps)
	--// Value States
	local Active = Value(true)

	local Rewind = ImageButton({
		Name = "Rewind",
		Active = Handler_Interface:GetState("PlayerHidden"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -1,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(1, 0.25),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", -1)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935457399",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.44, 0.294),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 1.5,
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),
		},
	})

	return Rewind
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX9884571e31f7403790e7072747ea273a">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Skip</string>
								<string name="ScriptGuid">{75e27e28-b4d4-4d53-8a5b-9de010572e47}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SkipProps = {}

return function(props: SkipProps)
	--// Value States
	local Active = Value(true)

	local Skip = ImageButton({
		Name = "Skip",
		Active = Handler_Interface:GetState("PlayerHidden"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 2,
		Position = UDim2.fromScale(0.873, 0.06),
		Size = UDim2.fromScale(1, 0.25),

		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,

		OnClick = function()
			Handler_Interface:Fire("ToggleSong", 1)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935457202",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.44, 0.294),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 1.5,
					}),
				},
			}),
		},
	})

	return Skip
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXce89d049ec814c9ba7bed1e7cc4542d9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AudioscapeButton</string>
							<string name="ScriptGuid">{0d85ebca-df88-4448-b21a-0343f253a3fa}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
	Sizing = 0.25,
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type AudioscapeButtonProps = {}

return function(props: AudioscapeButtonProps)
	local ShowTooltip = Value(false)
	local Active = Value(not Handler_Interface:Get("PlayerVisible"))

	Handler_Interface:SubscribeToState("PlayerVisible", function(visible)
		Active:set(not visible)
	end)

	local AudioscapeButton = ImageButton({
		Name = "AudioScape",
		Active = Active,
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Size = UDim2.fromScale(1, Settings.Sizing),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,
		Position = UDim2.fromScale(0.5, 0.5),
		AnchorPoint = Vector2.new(0.5, 0.5),
		LayoutOrder = -10,

		OnClick = function()
			Handler_Interface:Set("PlayerVisible", true)
			Handler_Interface:Set("PlayerHidden", false)
		end,

		OnHover = function()
			ShowTooltip:set(true)
		end,
		OnLeave = function()
			ShowTooltip:set(false)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935312391",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.6, 0.52),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),

			Computed(function()
				if ShowTooltip:get() then
					return New("TextLabel")({
						Name = "Tooltip",
						BackgroundTransparency = 0.5,
						BackgroundColor3 = Color3.new(0, 0, 0),
						AnchorPoint = Vector2.new(1, 0),
						Position = UDim2.fromScale(0, 0),
						Size = UDim2.fromScale(4, 1),
						Text = "Expand",
						TextScaled = true,
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextSize = 14,
						Font = Enum.Font.GothamSemibold,
						TextXAlignment = Enum.TextXAlignment.Center,
						TextYAlignment = Enum.TextYAlignment.Center,
						ZIndex = 2,

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),
						},
					})
				end
				return {}
			end, function() end),
		},
	})

	return AudioscapeButton
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX994ed7679d9546f9a41bb19b92b10ded">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Buttons</string>
							<string name="ScriptGuid">{663de819-11e8-4550-824e-7cc644a5fe99}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type ButtonsProps = {}

return function(props: ButtonsProps)
	--// Value States
	local Active = Value(true)
	local Minimize = Value(false)
	local Page = Handler_Interface:GetState("Page")

	local Buttons = New("Frame")({
		Name = "Buttons",
		AnchorPoint = Vector2.new(1, 0),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 2,
		Position = UDim2.fromScale(1, 0),
		Size = UDim2.fromScale(0.228, 0.25),

		[Children] = {
			ImageButton({
				Active = Active,
				Name = "Search",
				BackgroundTransparency = 0,
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.873, 0.06),
				Size = UDim2.fromScale(0.556, 1.11),
				Image = "",
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				AnimationSpeed = 0.1,

				OnClick = function()
					Handler_Interface:Set("SearchTab", "Library")
					Page:set("Search")
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = "rbxassetid://18935266802",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.5, 0.5),
					}),

					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
					}),
				},
			}),
			ImageButton({
				Active = Active,
				Name = "FX",
				BackgroundTransparency = 0,
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Position = UDim2.fromScale(0.873, 0.06),
				Size = UDim2.fromScale(0.556, 1.11),
				Image = "",
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				AnimationSpeed = 0.1,

				OnClick = function()
					Handler_Interface:Set("ShowFXModal", true)
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("TextLabel")({
						Name = "Icon",
						Text = "FX",
						FontFace = Font.new(
							"rbxasset://fonts/families/SourceSansPro.json",
							Enum.FontWeight.Bold,
							Enum.FontStyle.Normal
						),
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.55, 0.55),
						TextScaled = true,
						TextColor3 = Color3.new(1, 1, 1),
					}),

					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
					}),
				},
			}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0, 5),
				FillDirection = Enum.FillDirection.Vertical,
				HorizontalAlignment = Enum.HorizontalAlignment.Right,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 2,
			}),
		},
	})

	return Buttons
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4ba0fbe36fe449dd98f4a3dfcdd5e16b">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Playing</string>
							<string name="ScriptGuid">{c9c52d30-a693-4bc0-8496-af3f39828888}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local SongInfo = require(script.SongInfo)
local AudioscapeButtonMaximized = require(script.AudioscapeButtonMaximized)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PlayingProps = {}

return function(props: PlayingProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	local Playing = New("Frame")({
		Name = "Playing",
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 2,
		Size = UDim2.fromScale(0.5, 0.4),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0, 5),
				FillDirection = Enum.FillDirection.Horizontal,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			SongInfo({}),
			AudioscapeButtonMaximized({}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 2,
			}),
		},
	})

	return Playing
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXfb1aacd07af04fd4b28d8a95352040d9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">AudioscapeButtonMaximized</string>
								<string name="ScriptGuid">{5dc2df15-1261-4314-951e-53b4a7ffba44}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type AudioscapeButtonProps = {}

return function(props: AudioscapeButtonProps)
	local ShowTooltip = Value(false)

	local AudioscapeButton = ImageButton({
		Name = "AudioScape",
		Active = Handler_Interface:GetState("PlayerVisible"),
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -1,
		Size = UDim2.fromScale(0.667, 1.682),
		AspectRatio = 1,
		Image = "",
		BackgroundTransparency = 0,
		AnimationSpeed = 0.2,
		GrowthSize = 1.1,
		Position = UDim2.fromScale(0.5, 0.5),
		AnchorPoint = Vector2.new(0.5, 0.5),

		OnClick = function()
			-- Handler_Interface:Set("PlayerVisible", false)
			-- Handler_Interface:Set("PlayerHidden", true)
			Handler_Interface:Fire("ToggleBoombox")
		end,

		OnHover = function()
			ShowTooltip:set(true)
		end,
		OnLeave = function()
			ShowTooltip:set(false)
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageLabel")({
				Name = "Icon",
				Image = "rbxassetid://18935312391",
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.6, 0.52),
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
			}),

			Computed(function()
				if ShowTooltip:get() then
					return New("TextLabel")({
						Name = "Tooltip",
						BackgroundTransparency = 0.5,
						BackgroundColor3 = Color3.new(0, 0, 0),
						AnchorPoint = Vector2.new(0.5, 1),
						Position = UDim2.fromScale(0.5, 0),
						Size = UDim2.fromScale(3, 1),
						Text = "Join the Audioscape group to add this player to your game!",
						TextScaled = true,
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextSize = 14,
						Font = Enum.Font.GothamSemibold,
						TextXAlignment = Enum.TextXAlignment.Center,
						TextYAlignment = Enum.TextYAlignment.Center,
						ZIndex = 2,

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("UIPadding")({
								Name = "UIPadding",
								PaddingBottom = UDim.new(0, 5),
								PaddingLeft = UDim.new(0, 5),
								PaddingRight = UDim.new(0, 5),
								PaddingTop = UDim.new(0, 5),
							}),
						},
					})
				end
				return {}
			end, function() end),
		},
	})

	return AudioscapeButton
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1d9316b24d0c4245bb18bbe0378327c4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SongInfo</string>
								<string name="ScriptGuid">{0ca29609-53c9-4957-bc0d-f49fc33a1686}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Capitalize = require(Util.Capitalize)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SongInfoProps = {
	["asset_audio_details_artist"]: string,
	["asset_audio_details_music_album"]: string,
	["asset_audio_details_music_genre"]: string,
	["asset_audio_details_sound_effect_category"]: string | nil,
	["asset_audio_details_sound_effect_subcategory"]: string | nil,
	["asset_audio_details_tags"]: string,
	["asset_created_utc"]: string,
	["asset_description"]: string,
	["asset_duration"]: string,
	["asset_id"]: string,
	["asset_name"]: string,
	["asset_updated_utc"]: string,
	["creator_id"]: string,
	["creator_is_verified_creator"]: boolean,
	["creator_name"]: string,
	["asset_bpm"]: number | nil,
	["asset_first_beat_offset"]: number | nil,
	["asset_first_downbeat"]: number | nil,
}

return function(props: SongInfoProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local SongInfo = New("Frame")({
		Name = "SongInfo",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 2,
		Position = UDim2.fromScale(0.667, 0),
		Size = Tween(
			Computed(function()
				return Handler_Interface:Get("PlayerVisible") and UDim2.fromScale(1.8, 1) or UDim2.fromScale(0, 1)
			end),
			Tweens.Fast
		),

		[Children] = {
			New("TextLabel")({
				Name = "SongTitle",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = Computed(function()
					local CurrentSound = Handler_Interface:Get("Sound")
					if CurrentSound and typeof(CurrentSound) == "table" and CurrentSound["asset_name"] then
						return CurrentSound["asset_name"]
					end

					if not Handler_Interface:Get("Loaded") then
						return "Loading..."
					end

					return "Loading..."
				end),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextTransparency = Tween(
					Computed(function()
						return Handler_Interface:Get("PlayerVisible") and 0 or 1
					end),
					Tweens.Fast
				),
				TextXAlignment = Enum.TextXAlignment.Left,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(1, 0.6),
			}),

			New("TextLabel")({
				Name = "SongAlbum",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = Computed(function()
					local CurrentSound = Handler_Interface:Get("Sound")
					if
						CurrentSound
						and typeof(CurrentSound) == "table"
						and CurrentSound["asset_audio_details_music_album"]
					then
						return Capitalize(CurrentSound["asset_audio_details_music_album"]:lower())
					end

					if not Handler_Interface:Get("Loaded") then
						return "Loading..."
					end

					return "Loading..."
				end),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextTransparency = Tween(
					Computed(function()
						return Handler_Interface:Get("PlayerVisible") and 0.5 or 1
					end),
					Tweens.Fast
				),
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(5.48e-07, 0.722),
				Size = UDim2.fromScale(0.75, 0.7),
				[Children] = {
					New("UITextSizeConstraint")({
						Name = "UITextSizeConstraint",
						MaxTextSize = 15,
					}),
				},
			}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0, -2),
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),
		},
	})

	return SongInfo
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXde08443de00945a5a4dca08a373f1311">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TimeBar</string>
							<string name="ScriptGuid">{bfa3303b-8ea1-4768-b9f8-4c9a79c86825}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

local function ConvertSecondsToMinutes(Seconds: number): string
	local Minutes = math.floor(Seconds / 60)
	Seconds = math.floor(Seconds % 60)

	return string.format("%d:%02d", Minutes, Seconds)
end

type TimeBarProps = {}

return function(props: TimeBarProps)
	--// Value States
	local Active = Value(false)
	local Dragging = Value(false)

	local MarkerRef = Value()
	local ProgressBarRef = Value()

	local TimeBar = New("Frame")({
		[Ref] = ProgressBarRef,
		Name = "TimeBar",
		AnchorPoint = Vector2.new(0.5, 1),
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 0.9,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.5, 1),
		Size = UDim2.new(1, 0, 0, 5),
		Visible = Computed(function()
			return Handler_Interface:Get("PlayerVisible")
		end),

		[Children] = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("TextLabel")({
				Name = "Elapsed",
				FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json"),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextSize = 14,
				AnchorPoint = Vector2.new(0, 1),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.new(0, 10, -1, 0),
				Size = UDim2.fromOffset(5, 2),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 3.2,
					}),
				},
			}),

			New("TextLabel")({
				Name = "Duration",
				FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json"),
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextSize = 14,
				AnchorPoint = Vector2.new(1, 1),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.new(1, -10, -1, 0),
				Size = UDim2.fromOffset(5, 2),
				Text = Computed(function()
					return ConvertSecondsToMinutes(Handler_Interface:Get("Length"))
				end),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 3.2,
					}),
				},
			}),

			New("Frame")({
				Name = "TimeBarFill",
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(0.5, 1),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageButton")({
						[Ref] = MarkerRef,
						Name = "ProgressMark",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(1, 0.5),
						Size = UDim2.fromScale(2, 2),

						[OnEvent("MouseButton1Down")] = function(Temp, Temp2)
							Dragging:set(true)

							local Connection
							local ImageButton = MarkerRef:get() :: ImageButton

							local Mouse = Players.LocalPlayer:GetMouse()
							local ProgressBar = ProgressBarRef:get() :: ImageButton
							local AudioPlayer = Handler_Interface:Get("AudioPlayer") :: Sound

							Connection = UserInputService.InputEnded:Connect(function(input)
								if input.UserInputType == Enum.UserInputType.MouseButton1 then
									Connection:Disconnect()
									Dragging:set(false)
									RunService:UnbindFromRenderStep("Dragging")
									Handler_Interface:Fire("BoomboxEventMediator", "TimeChange")
								end
							end)

							RunService:BindToRenderStep("Dragging", 0, function(delta: number)
								local ClickedPercent = math.clamp(
									(Vector2.new(Mouse.X, Mouse.Y) - ProgressBar.AbsolutePosition).X,
									0,
									ProgressBar.AbsoluteSize.X
								) / ProgressBar.AbsoluteSize.X

								ImageButton.Parent.Size = UDim2.fromScale(ClickedPercent, 1)
								AudioPlayer.TimePosition = AudioPlayer.TimeLength * ClickedPercent
							end)
						end,
						[OnEvent("MouseButton1Up")] = function(Temp, Temp2)
							Dragging:set(false)
							RunService:UnbindFromRenderStep("Dragging")
						end,

						[Children] = {
							New("UIAspectRatioConstraint")({
								Name = "UIAspectRatioConstraint",
							}),

							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(1, 0),
							}),
						},
					}),
				},
			}),
		},
	})

	local function Monitor()
		local Sound = Handler_Interface:Get("Sound")
		local AudioPlayer = Handler_Interface:Get("AudioPlayer") :: Sound

		if not Sound then
			repeat
				task.wait()
			until Handler_Interface:Get("Sound")
		end

		RunService:UnbindFromRenderStep("SongProgress")

		TimeBar.Duration.Text = ConvertSecondsToMinutes(AudioPlayer.TimeLength)

		RunService:BindToRenderStep("SongProgress", 0, function(delta: number)
			if Dragging:get() then
				return
			end

			local TimeBarFill = TimeBar.TimeBarFill :: Frame

			TimeBar.Elapsed.Text = ConvertSecondsToMinutes(AudioPlayer.TimePosition)
			TimeBarFill.Size = UDim2.fromScale(AudioPlayer.TimePosition / AudioPlayer.TimeLength, 1)
		end)
	end

	Observer(Handler_Interface:GetState("Length")):onChange(Monitor)

	task.spawn(Monitor)

	return TimeBar
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXeef372155ffa41b587b6f086051ccbe0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Base</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXceb2d0e142a34aa996a6aa68aa262b06">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ImageButton</string>
							<string name="ScriptGuid">{fbb4b550-efd7-4753-8536-39afb3503fc3}</string>
							<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Wednesday October 4th 2023 4:02:12 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 9:11:10 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)

--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Base",
}

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type ImageButtonProps = {
	Active: any?,
	Name: string?,
	Image: string?,
	ZIndex: number?,
	Visible: boolean?,
	ShrinkSize: number?,
	GrowthSize: number?,
	FrameZIndex: number?,
	AspectRatio: number?,
	AnimationSpeed: number?,

	Size: UDim2,
	Position: UDim2?,
	ImageColor3: Color3?,
	LayoutOrder: number?,
	AnchorPoint: Vector2?,
	BackgroundColor3: Color3?,
	BackgroundTransparency: number?,
	RootBackgroundTransparency: number?,

	Ref: Fusion.Value<nil>?,
	OnHover: () -> any?,
	OnLeave: () -> any?,
	OnClick: () -> any?,
	Children: {}?,
}

return function(props: ImageButtonProps)
	--// Value States
	local Active = props.Active or Value(false)
	local Hovering = Value(false)
	local Clicking = Value(false)

	--// Debugging
	if Interface_Settings.BaseDebug then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local ImageButton = New("Frame")({

		[Cleanup] = {},
		[Ref] = props.Ref or nil,
		Name = props.Name or "Button",
		LayoutOrder = props["LayoutOrder"] or 1,

		ZIndex = props["FrameZIndex"] or 1,
		BackgroundTransparency = props["RootBackgroundTransparency"] or 1,
		BackgroundColor3 = props.BackgroundColor3 or Color3.new(1, 1, 1),
		Size = props.Size,
		AnchorPoint = props.AnchorPoint or Vector2.new(0, 0),
		Position = props.Position or UDim2.fromScale(0.5, 0.5),
		Visible = if props["Visible"] ~= nil then props["Visible"] else true,
		[Children] = {
			Computed(function()
				if props["AspectRatio"] then
					return New("UIAspectRatioConstraint")({
						AspectRatio = props["AspectRatio"] or 1,
					})
				end

				return {}
			end, function(a0: Instance)
				-- a0:Destroy()
			end),
			New("ImageButton")({
				[OnEvent("MouseButton1Click")] = function()
					Sounds:Play("Click")

					if props.OnClick then
						props.OnClick()
					end

					Clicking:set(true)
					task.delay(0.25, function()
						Hovering:set(false)
						Clicking:set(false)
					end)
				end,
				[OnEvent("MouseEnter")] = function()
					Hovering:set(true)
					if props.OnHover then
						props.OnHover()
					end
				end,
				[OnEvent("MouseLeave")] = function()
					Hovering:set(false)
					if props.OnLeave then
						props.OnLeave()
					end
				end,

				ZIndex = props["ZIndex"] or 1,
				Name = props.Name or "Button",
				Image = props.Image or "rbxassetid://13190836263",
				ImageColor3 = props.ImageColor3 or Color3.new(1, 1, 1),
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundTransparency = props.BackgroundTransparency or 1,
				BackgroundColor3 = props.BackgroundColor3 or Color3.new(1, 1, 1),
				Position = UDim2.fromScale(0.5, 0.5),
				Size = Tween(
					Computed(function()
						if Clicking:get() then
							local ShrinkSize = props["ShrinkSize"] or 0.75

							return UDim2.fromScale(ShrinkSize, ShrinkSize)
						end
						if Hovering:get() then
							return UDim2.fromScale(props["GrowthSize"] or 1.25, props["GrowthSize"] or 1.25)
						end
						return Active:get() and UDim2.fromScale(1, 1) or UDim2.fromScale(0, 0)
					end),
					Tweens.modifyTween("Toon", {
						EasingDirection = Enum.EasingDirection.Out,
						Time = props["AnimationSpeed"] or Tweens.Toon.Time,
					})
				),

				ImageTransparency = Tween(
					Computed(function()
						return Active:get() and 0 or 1
					end),
					Tweens.modifyTween("Toon", {
						EasingDirection = Enum.EasingDirection.Out,
						Time = props["AnimationSpeed"] or Tweens.Toon.Time,
					})
				),

				[Children] = {
					props["Children"],
				},
			}),
		},
	})

	return ImageButton
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1937ff6b414946acbef9d28275f016a7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">InputLabel</string>
							<string name="ScriptGuid">{4d6b94af-a730-45ea-97b8-a8fdcf880f1f}</string>
							<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Tuesday October 3rd 2023 12:38:13 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 10:31:38 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local _Players = game:GetService("Players")
local _RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local _Sounds = require(Util.Sounds)
local _Images = require(Util.Images)
local UIStroke = require(Util.UIStroke)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)

--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "CharacterCreation",
}

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type InputLabelProps = {
	LabelName: string,

	Size: UDim2?,
	Image: string?,
	Position: UDim2?,
	AnchorPoint: Vector2?,
	TextXAlignment: Enum.TextXAlignment?,
}

return function(props: InputLabelProps)
	--// Value States
	local Active = Value(false)
	local HasText = Value(false)
	local InputFocused = Value(false)

	--// Ref
	local TextBoxRef = Value()

	--// Signals
	-- local ToggleAnimationConnection = Interface_Handler.ToggleAnimation.Event:Connect(
	-- 	function(Page: string, Animate: boolean)
	-- 		if Page == Settings.Page then
	-- 			Active:set(Animate or false)
	-- 		end
	-- 	end
	-- )

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local InputLabel = New("Frame")({
		[Cleanup] = { --[[ToggleAnimationConnection]]
		},
		BackgroundTransparency = 1,
		Size = props["Size"] or UDim2.fromScale(0.25, 0.25),
		AnchorPoint = props["AnchorPoint"] or Vector2.new(0.5, 0.5),
		Position = props["Position"] or UDim2.fromScale(0.5, 0.5),
		[Children] = {
			New("ImageLabel")({
				Name = "InputLabel",
				Image = props["Image"] or "rbxassetid://13190703913",
				BackgroundTransparency = 1,
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.fromScale(0.5, 0.5),
				Size = Tween(
					Computed(function()
						return Active:get() and UDim2.fromScale(1, 1) or UDim2.fromScale(0, 0)
					end),
					Tweens.modifyTween("Toon", {
						EasingDirection = Enum.EasingDirection.Out,
					})
				),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "1",
						AspectRatio = 2.55,
					}),

					New("TextBox")({
						[Ref] = TextBoxRef,
						Name = "Input",
						-- CursorPosition = -1,
						FontFace = Font.new("rbxasset://fonts/families/FredokaOne.json"),
						Text = "",
						TextColor3 = Color3.fromRGB(70, 70, 70),
						TextScaled = true,
						TextSize = 14,
						TextWrapped = true,
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundTransparency = 1,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.742, 0.35),
						TextXAlignment = props["TextXAlignment"] or Enum.TextXAlignment.Left,
						[OnEvent("Focused")] = function()
							InputFocused:set(true)
						end,
						[OnEvent("FocusLost")] = function()
							InputFocused:set(false)
							HasText:set(#TextBoxRef:get().Text > 0)
						end,
					}),

					Computed(function()
						if props.LabelName then
							return New("TextLabel")({
								Name = props.LabelName .. "Label",
								FontFace = Font.new("rbxasset://fonts/families/FredokaOne.json"),
								Text = props.LabelName,
								TextColor3 = Tween(
									Computed(function()
										local ActiveStateSize = Color3.new(1, 1, 1)
										if HasText:get() then
											return ActiveStateSize
										end

										return InputFocused:get() and ActiveStateSize or Color3.new(0.85, 0.85, 0.85)
									end),
									Tweens.modifyTween("Toon", {
										EasingDirection = Enum.EasingDirection.Out,
									})
								),
								TextScaled = true,
								TextSize = Tween(
									Computed(function()
										local ActiveStateSize = 5
										if HasText:get() then
											return ActiveStateSize
										end
										return InputFocused:get() and ActiveStateSize or 14
									end),
									Tweens.Default
								),
								TextWrapped = true,
								TextXAlignment = props["TextXAlignment"] or Enum.TextXAlignment.Left,
								BackgroundTransparency = 1,
								AnchorPoint = Vector2.new(1, 0.5),
								Position = Tween(
									Computed(function()
										local ActiveStateSize = UDim2.fromScale(0.3, -0.2)
										if HasText:get() then
											return ActiveStateSize
										end

										return InputFocused:get() and ActiveStateSize or UDim2.fromScale(0.65, 0.5)
									end),
									Tweens.modifyTween("Toon", {
										EasingDirection = Enum.EasingDirection.Out,
									})
								),
								Size = Tween(
									Computed(function()
										local ActiveStateSize = UDim2.fromScale(0.25, 0.25)
										if HasText:get() then
											return ActiveStateSize
										end

										return InputFocused:get() and ActiveStateSize or UDim2.fromScale(0.5, 0.5)
									end),
									Tweens.modifyTween("Toon", {
										EasingDirection = Enum.EasingDirection.Out,
									})
								),

								[Children] = {
									New("UIStroke")({
										Name = "1",
										Color = Color3.fromRGB(84, 175, 255),
										LineJoinMode = Enum.LineJoinMode.Miter,
										Transparency = Tween(
											Computed(function()
												if HasText:get() then
													return 0
												end

												return InputFocused:get() and 0 or 1
											end),
											Tweens.Default
										),
										Thickness = Tween(
											Computed(function()
												if HasText:get() then
													return UIStroke(1)
												end

												return InputFocused:get() and UIStroke(3) or 0
											end),
											Tweens.Default
										),
									}),
								},
							})
						end

						return {}
					end, function()
						return {}
					end),
				},
			}),
		},
	})

	return InputLabel
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXf52941e2754744a2997d8fe692bb4c7d">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TextLabel</string>
							<string name="ScriptGuid">{df8a3d1e-a389-4db1-b403-332c788c53a5}</string>
							<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Wednesday October 4th 2023 4:02:12 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 9:12:03 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)

--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Base",
}

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type TextLabelProps = {
	Active: any?,
	Name: string?,
	Text: string?,

	Size: UDim2,
	Position: UDim2?,
	AnchorPoint: Vector2?,

	Children: {},
}

return function(props: TextLabelProps)
	--// Value States
	local Active = props["Active"] or Value(false)
	local Hovering = Value(false)
	local Clicking = Value(false)

	--// Signals
	-- local ToggleAnimationConnection = Interface_Handler.ToggleAnimation.Event:Connect(
	-- 	function(Page: string, Animate: boolean)
	-- 		if Page == Settings.Page then
	-- 			Active:set(Animate or false)
	-- 		end
	-- 	end
	-- )

	--// Debugging
	if Interface_Settings.BaseDebug:get() == true then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local TextLabel = New("Frame")({
		[Cleanup] = { --[[ToggleAnimationConnection]]
		},
		BackgroundTransparency = 1,
		Size = props.Size,
		AnchorPoint = props["AnchorPoint"] or Vector2.new(0, 0),
		Position = props["Position"] or UDim2.fromScale(0.5, 0.5),
		[Children] = {
			New("ImageLabel")({
				Name = "NameLabelQCS",
				Image = "rbxassetid://14962576335",
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.fromScale(0.5, 0.5),
				Size = Tween(
					Computed(function()
						if Clicking:get() then
							return UDim2.fromScale(0.75, 0.75)
						end
						if Hovering:get() then
							return UDim2.fromScale(1.25, 1.25)
						end
						return Active:get() and UDim2.fromScale(1, 1) or UDim2.fromScale(0, 0)
					end),
					Tweens.modifyTween("Toon", {
						EasingDirection = Enum.EasingDirection.Out,
					})
				),

				[Children] = {
					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
						AspectRatio = 2.26,
					}),

					New("TextLabel")({
						Name = "Label",
						FontFace = Font.new("rbxasset://fonts/families/FredokaOne.json"),
						Text = props["Text"] or "Empty",
						TextColor3 = Color3.fromRGB(0, 0, 0),
						TextScaled = true,
						TextSize = 14,
						TextWrapped = true,
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.115, 0.24),
						Size = UDim2.fromScale(0.779, 0.38),
					}),
				},
			}),
		},
	})

	return TextLabel
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXf447465554ee4231b68158110dab1c9f">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Queue</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX6234b66128a549d29d47cb0b5bffedb9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Favorites</string>
							<string name="ScriptGuid">{bf38368b-1669-47de-8a27-b8276458fa7a}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local TimeSorter = require(Util.TimeSorter)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local SearchResult = require(script.SearchResult)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultsProps = {}

return function(props: SearchResultsProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local SearchResults = New("ScrollingFrame")({
		[Ref] = Handler_Interface:GetState("FavoritesResultsCanvasRef"),
		Name = "Results",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.0249, 0.2),
		Size = UDim2.fromScale(0.95, 0.799),
		Visible = true,

		ScrollBarThickness = 1,
		AutomaticCanvasSize = Enum.AutomaticSize.Y,

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),

			-- SearchResult({
			-- 	asset_audio_details_artist = "Test",
			-- 	asset_audio_details_music_album = "Tes2",
			-- 	asset_name = "Song",
			-- 	asset_description = "Desc",
			-- 	asset_duration = 50,
			-- 	asset_id = 123124142,
			-- 	asset_name = "string",
			-- }),

			Computed(function()
				local LikesRetrieved = Handler_Interface:Get("LikesRetrieved")

				if not LikesRetrieved then
					return New("TextLabel")({
						Text = "Loading your likes...",
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextSize = 14,
						TextScaled = true,
						TextWrapped = true,
						Size = UDim2.new(1, 0, 0, 35),
						BackgroundTransparency = 1,
					})
				end
			end, function() end),

			Computed(function()
				local SearchTab = Handler_Interface:Get("SearchTab") :: string
				local FavoritesResults = Handler_Interface:Get("FavoritesResults")

				local SongCount = 1
				local SongResultList = {}

				for Index, Song in FavoritesResults do
					Song.Index = SearchTab == "Library" and Index or SongCount
					Song.Dark = SongCount % 2 == 0

					local Current = SearchResult(Song)

					table.insert(SongResultList, Current)

					SongCount += 1
				end

				return SongResultList
			end, function() end),
		},
	})

	return SearchResults
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX9d36cde59e0548b980805374c2fe6633">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SearchResult</string>
								<string name="ScriptGuid">{6f3a3241-6afd-44e0-8860-2b316be59490}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultProps = {
	["asset_audio_details_artist"]: string,
	["asset_audio_details_music_album"]: string,
	["asset_audio_details_music_genre"]: string,
	["asset_audio_details_sound_effect_category"]: string | nil,
	["asset_audio_details_sound_effect_subcategory"]: string | nil,
	["asset_audio_details_tags"]: string,
	["asset_created_utc"]: string,
	["asset_description"]: string,
	["asset_duration"]: string,
	["asset_id"]: string,
	["asset_name"]: string,
	["asset_updated_utc"]: string,
	["creator_id"]: string,
	["creator_is_verified_creator"]: boolean,
	["creator_name"]: string,
	["asset_bpm"]: number | nil,
	["asset_first_beat_offset"]: number | nil,
	["asset_first_downbeat"]: number | nil,

	Liked: boolean,
	Index: number,
	Dark: boolean,
}

return function(props: SearchResultProps)
	--// Value States
	local Active = Value(true)
	local Liked = Value(true)

	-- local LikedImage = "rbxassetid://18952672240"
	local LikedImage = "rbxassetid://70543506632381"
	local UnlikedImage = "rbxassetid://18925349461"
	-- local UnlikedImage = "rbxassetid://18925349461"

	local SearchResult = ImageButton({
		Active = Active,
		GrowthSize = 1.025,
		ShrinkSize = 0.95,
		AnimationSpeed = 0.2,
		Name = "SearchResult",
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = props["Index"] or 1,
		Size = UDim2.new(1, 0, 0, 35),
		BackgroundTransparency = props["Dark"] and 1 or 0,
		Image = "",

		Visible = Computed(function()
			return Liked:get()
		end),

		OnClick = function()
			Handler_Interface:Fire("PlaySound", props)
		end,

		Children = {
			ImageButton({
				Active = Active,
				GrowthSize = 1.1,
				ShrinkSize = 0.5,
				AspectRatio = 1.2,
				AnimationSpeed = 0.2,
				AnchorPoint = Vector2.new(1, 0.5),

				Name = "Like",
				Image = Computed(function()
					return Liked:get() and LikedImage or UnlikedImage
				end),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Size = UDim2.fromScale(0.6, 0.6),

				ImageColor3 = Computed(function()
					return Liked:get() and Handler_Interface:Get("DefaultAccentColor") or Color3.fromRGB(255, 255, 255)
				end),

				OnClick = function()
					Liked:set(false)
					Handler_Interface:Fire("LikeEvent", props, false)
				end,
			}),

			ImageButton({
				Active = Active,
				GrowthSize = 1.1,
				ShrinkSize = 0.5,
				AnimationSpeed = 0.2,

				Name = "AddToQueue",
				Image = "rbxassetid://18925349301",
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(0.6, 0.6),
				ImageColor3 = Computed(function()
					return Handler_Interface:Get("DefaultAccentColor")
				end),

				OnClick = function()
					Handler_Interface:Fire("AddToQueue", props)
				end,

				AspectRatio = 1,
			}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = props["asset_name"] or "Unknown",
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Size = UDim2.fromScale(0.7, 0.8),

				[Children] = {
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 5),
						PaddingRight = UDim.new(0.1, 0),
					}),
				},
			}),
		},
	})

	return SearchResult
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX7aa9b8966b9b4854bf0c033101560caa">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PillsContainer</string>
							<string name="ScriptGuid">{1fce9c0b-2088-4106-93a0-cea9c59582d7}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Genres = require(Util.Genres)
local Search = require(Util.Search)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Queue",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Queue

local Pill = require(script.Pill)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PillsContainerProps = {}

return function(props: PillsContainerProps)
	--// Value States
	local Active = Value(false)
	local ParentalRef = Value(nil)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local PillsContainer = New("Frame")({
		[Ref] = ParentalRef,
		Name = "Pills",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -2,
		Size = UDim2.fromScale(0.998, 0.1),

		Visible = Computed(function()
			if Handler_Interface:Get("QueueTab") == "Favorites" then
				return true
			end

			return false
		end),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				VerticalFlex = Enum.UIFlexAlignment.SpaceBetween,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("Frame")({
				Name = "BottomSeparator",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.new(1, 0, 0, 1),
			}),

			New("Frame")({
				Name = "TopSeparator",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = -2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.new(1, 0, 0, 2),
			}),

			New("Frame")({
				Name = "PillsContainer",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0, -0.16),
				Size = UDim2.fromScale(1, 1),

				[Children] = {
					New("UIFlexItem")({
						Name = "UIFlexItem",
						FlexMode = Enum.UIFlexMode.Fill,
					}),
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 10),
					}),
					Computed(function()
						local KeyboardDetected = Handler_Interface:Get("KeyboardDetected")
						-- AutomaticCanvasSize = Enum.AutomaticSize.X,
						-- CanvasSize = UDim2.fromScale(2, 1),
						-- ScrollingDirection = Enum.ScrollingDirection.X,
						-- ScrollBarThickness = 1,

						return New(KeyboardDetected and "Frame" or "ScrollingFrame")({
							[Ref] = Handler_Interface:GetState("PillsCanvasRef"),

							Name = "Listing",
							Active = true,
							BackgroundColor3 = Color3.fromRGB(255, 255, 255),
							BackgroundTransparency = 1,
							BorderColor3 = Color3.fromRGB(0, 0, 0),
							BorderSizePixel = 0,
							Size = UDim2.fromScale(1, 0.997),

							[Children] = {
								Computed(function()
									local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame
									if PillsCanvasRef and PillsCanvasRef:IsA("ScrollingFrame") then
										PillsCanvasRef.ScrollingDirection = Enum.ScrollingDirection.X
										PillsCanvasRef.AutomaticCanvasSize = Enum.AutomaticSize.X
										PillsCanvasRef.Size = UDim2.new(1, 0, 0, 50)
										PillsCanvasRef.ScrollBarThickness = 0
									end
								end, function() end),

								New("UIListLayout")({
									Name = "UIListLayout",
									Padding = UDim.new(0.02, 0),
									FillDirection = Enum.FillDirection.Horizontal,
									SortOrder = Enum.SortOrder.LayoutOrder,
									VerticalAlignment = Enum.VerticalAlignment.Top,
									HorizontalAlignment = KeyboardDetected and Enum.HorizontalAlignment.Center
										or Enum.HorizontalAlignment.Left,
									Wraps = Computed(function()
										return KeyboardDetected
									end),
								}),

								New("UIPadding")({
									Name = "UIPadding",
									PaddingTop = KeyboardDetected and UDim.new(0, 0) or UDim.new(0.1, 0),
									PaddingBottom = KeyboardDetected and UDim.new(0.2, 0) or UDim.new(0, 0),
								}),

								Computed(function()
									local Parental = ParentalRef:get() :: Frame
									local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame
									local Favorites = Handler_Interface:Get("Favorites") :: { string }

									local PillCount = 0
									local PillComponents = {}

									for _, QueryName in Search.getPillsFromTags(Favorites) do
										PillComponents[QueryName] = Pill({
											Index = PillCount,
											Query = false,
											Text = QueryName,
											-- OnClick = function()
											-- 	local SearchResults =
											-- 		Search.searchSongs(QueryName, Handler_Interface:Get("Favorites"))
											-- 	Handler_Interface:Set("FavoritesResults", SearchResults)

											-- 	local IdStripFromResults = {}

											-- 	for i, v in pairs(Handler_Interface:Get("FavoritesResults")) do
											-- 		table.insert(IdStripFromResults, tonumber(v.asset_id))
											-- 	end

											-- 	Handler_Interface:Fire("InstaQuery", {
											-- 		["filter_value"] = QueryName,
											-- 		["results"] = IdStripFromResults,
											-- 	})
											-- end,
										})

										PillCount += 1
									end

									if #PillComponents > 0 and Parental and PillsCanvasRef then
										local FirstPill = PillComponents[1] :: ImageButton

										Parental.Size = UDim2.new(
											1,
											0,
											0, -- KeyboardDetected and 0 or 0.1,
											KeyboardDetected
													and (math.floor(#PillComponents / 3) * FirstPill.AbsoluteSize.Y) + 30
												or FirstPill.AbsoluteSize.Y + 20
										)

										local InitialSize = Parental.AbsoluteSize
									end

									return PillComponents
								end, function() end),
							},
						})
					end, function() end),

					New("ImageLabel")({
						Name = "ImageLabel",
						Image = "rbxassetid://18925300527",
						AnchorPoint = Vector2.new(1, 0),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(1, 0),
						Size = UDim2.new(-0.159, 100, 0.719, 0),
						Visible = Computed(function()
							return not Handler_Interface:Get("KeyboardDetected")
						end),
					}),
				},
			}),
		},
	})

	return PillsContainer
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXdcf4d8691cfe406eaf0c6ff0df946489">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Pill</string>
								<string name="ScriptGuid">{0a37baad-d1b4-4d27-894e-29914c46b13a}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Tweens = require(Util.Tweens)
local Search = require(Util.Search)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PillProps = {
	Index: number,
	Text: string,
	Query: string,
	Genre: string,
	OnClick: (() -> nil)?,
}

return function(props: PillProps)
	--// Value States
	local Active = Value(true)

	local IsSelected = Handler_Interface:Get("Pill") == props.Text

	local Pill = ImageButton({
		Active = Active,
		Name = "Pill",
		BackgroundColor3 = Computed(function()
			return IsSelected and Handler_Interface:Get("DefaultAccentColor") or Color3.fromRGB(31, 31, 31)
		end),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Size = UDim2.fromOffset(80, 100),
		BackgroundTransparency = 0,
		Image = "",
		GrowthSize = 1.1,
		ShrinkSize = 0.9,
		AnimationSpeed = 0.1,
		LayoutOrder = Computed(function()
			return IsSelected and -1 or props.Index
		end),

		AspectRatio = 3.15,

		OnClick = function()
			local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame

			if IsSelected then
				Handler_Interface:Set("Pill", "")
				Handler_Interface:Set("FavoritesResults", Handler_Interface:Get("Favorites"))
			else
				Handler_Interface:Set("Pill", props.Text)

				local Results = Search.searchFromTag(props.Text, Handler_Interface:Get("Favorites"))

				Handler_Interface:Set(
					"FavoritesResults",
					Search.searchFromTag(props.Text, Handler_Interface:Get("Favorites"))
				)
			end

			local _ = if props["OnClick"] then props["OnClick"]() else nil
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(1, 0),
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				TextColor3 = Computed(function()
					return (
						IsSelected and Luminance(Handler_Interface:Get("DefaultAccentColor"))
						or Color3.fromRGB(255, 255, 255)
					)
				end),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				Text = props.Text,
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.9, 0.9), -- PillTextSize
			}),

			-- New("UIAspectRatioConstraint")({
			-- 	Name = "UIAspectRatioConstraint",
			-- 	AspectRatio = 3.15,
			-- }),
		},
	})

	return Pill
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX74b2b4480bf34308bb75a81e44a7ca8c">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">QueueContainer</string>
							<string name="ScriptGuid">{968ff16c-f8b3-4814-bbb7-5a9c8ad17767}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local QueueItem = require(script.QueueItem)
local QueueItemLite = require(script.QueueItemLite)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

--// Private Functions
local function registerDynamicScrollingFrame(frame)
	local layout = frame:FindFirstChildWhichIsA("UIListLayout")
	local absoluteContentSize = layout.AbsoluteContentSize
	frame.CanvasSize = UDim2.new(0, 0, 0, absoluteContentSize.Y)
	layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		local absoluteContentSize = layout.AbsoluteContentSize
		local Offset = 50

		frame.CanvasSize = UDim2.new(0, 0, 0, absoluteContentSize.Y + Offset)
	end)
end

type QueueContainerProps = {}

return function(props: QueueContainerProps)
	--// Value States
	local ScrollFrameRef = Value()

	task.spawn(function()
		local ScrollFrame = ScrollFrameRef:get()

		repeat
			ScrollFrame = ScrollFrameRef:get()
			task.wait()
		until ScrollFrame

		registerDynamicScrollingFrame(ScrollFrame)
	end)

	local QueueContainer = New("ScrollingFrame")({
		[Ref] = ScrollFrameRef,
		Name = "QueueContainer",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.0249, 0.2),
		Size = UDim2.fromScale(0.95, 0.799),
		AutomaticCanvasSize = Enum.AutomaticSize.Y,

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),

			Computed(function()
				local Queue = Handler_Interface:Get("Queue")
				local SongResultList = {}

				for Index, Song in Queue do
					if not Song or typeof(Song) ~= "table" then
						continue
					end

					Song.Index = Index
					Song.Dark = Index % 2 == 0

					table.insert(SongResultList, QueueItemLite(Song))
				end

				return SongResultList
			end, function() end),
		},
	})

	return QueueContainer
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX8225ed559d8645718a6938ff2afd1266">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">QueueItem</string>
								<string name="ScriptGuid">{de55e443-bf0a-40ba-b6a8-515eb32491d6}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Draggable = require(Util.Draggable)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultProps = {
	["asset_audio_details_artist"]: string,
	["asset_audio_details_music_album"]: string,
	["asset_audio_details_music_genre"]: string,
	["asset_audio_details_sound_effect_category"]: string | nil,
	["asset_audio_details_sound_effect_subcategory"]: string | nil,
	["asset_audio_details_tags"]: string,
	["asset_created_utc"]: string,
	["asset_description"]: string,
	["asset_duration"]: string,
	["asset_id"]: string,
	["asset_name"]: string,
	["asset_updated_utc"]: string,
	["creator_id"]: string,
	["creator_is_verified_creator"]: boolean,
	["creator_name"]: string,
	["asset_bpm"]: number | nil,
	["asset_first_beat_offset"]: number | nil,
	["asset_first_downbeat"]: number | nil,

	Liked: boolean,
	Index: number,
	Dark: boolean,
}

return function(props: SearchResultProps)
	--// Value States
	local Active = Value(true)
	local DragRef = Value(nil)

	local CleanUpConnections = {}

	local CurrentQueueIndex = Handler_Interface:Get("QueueIndex")

	--// Component
	local SearchResult = ImageButton({
		[Cleanup] = {
			function()
				for _, Connection: typeof(Draggable.new()) in ipairs(CleanUpConnections) do
					Connection:Disable()
				end
			end,
		},
		Active = Active,
		GrowthSize = 1.025,
		ShrinkSize = 0.95,
		AnimationSpeed = 0.2,
		Name = "SearchResult",
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = props["Index"] or 1,
		Size = UDim2.new(1, 0, 0, 35),
		BackgroundTransparency = props["Dark"] and 1 or 0,
		Image = "",

		OnClick = function()
			Handler_Interface:Set("QueueIndex", props["Index"])
		end,

		Visible = props["Index"] > CurrentQueueIndex,

		Children = {

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			ImageButton({
				Ref = DragRef,
				Active = Active,
				GrowthSize = 1.1,
				ShrinkSize = 0.5,
				AnimationSpeed = 0.2,

				Visible = true,

				Name = "AddToQueue",
				Image = "rbxassetid://18925349301",
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(0.04, 0.533),
				ImageColor3 = Computed(function()
					return Handler_Interface:Get("DefaultAccentColor")
				end),

				OnClick = function() end,

				AspectRatio = 1,
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = props["asset_name"],
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Size = UDim2.fromScale(0.85, 0.8),

				[Children] = {
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 5),
						PaddingRight = UDim.new(0.1, 0),
					}),
				},
			}),
		},
	})

	task.spawn(function()
		local DragRefValue = DragRef:get()
		repeat
			task.wait()
			DragRefValue = DragRef:get()
		until DragRefValue

		local Drag = Draggable.new(DragRefValue, function(Position: UDim2)
			print(DragRefValue)
		end)

		Drag:Enable()

		table.insert(CleanUpConnections, Drag)
	end)

	return SearchResult
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4e88f890f4b5491d88c6589835a7ea62">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">QueueItemLite</string>
								<string name="ScriptGuid">{b6793496-da43-445a-b3cb-175ab7e74ad2}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultProps = {
	["asset_audio_details_artist"]: string,
	["asset_audio_details_music_album"]: string,
	["asset_name"]: string,
	["asset_description"]: string,
	["asset_duration"]: number,
	["asset_id"]: number,
	["asset_name"]: string,

	Liked: boolean,
	Index: number,
	Dark: boolean,
}

local function WorldToScreen(Mouse, Pos) --This function gets a World Position (Pos) and returns a Vector2 value of the screen coordinates
	local Cam = workspace.CurrentCamera
	local point = Cam.CFrame:PointToObjectSpace(Pos)
	local aspectRatio = Mouse.ViewSizeX / Mouse.ViewSizeY
	local hfactor = math.tan(math.rad(Cam.FieldOfView) / 2)
	local wfactor = aspectRatio * hfactor

	local x = (point.x / point.z) / -wfactor
	local y = (point.y / point.z) / hfactor

	return Vector2.new(Mouse.ViewSizeX * (0.5 + 0.5 * x), Mouse.ViewSizeY * (0.5 + 0.5 * y))
end

return function(props: SearchResultProps)
	--// Value States
	local Active = Value(true)
	local DragRef = Value(nil)
	local Dragging = Value(false)

	local CleanUpConnections = {}
	local CurrentQueueIndex = Handler_Interface:Get("QueueIndex")

	local SearchResult = New("ImageButton")({
		[Ref] = DragRef,
		Name = "SearchResult",
		BackgroundColor3 = Handler_Interface:Get("DefaultAccentColor"),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = props["Index"] or 1,
		Size = UDim2.new(1, 0, 0, 35),
		BackgroundTransparency = props["Dark"] and 1 or 0.9,
		Image = "",

		[OnEvent("MouseButton1Click")] = function()
			local Queue = Handler_Interface:Get("Queue")
			table.remove(Queue, props["Index"])
			Handler_Interface:Set("Sound", props)

			Handler_Interface:Set("Queue", Queue)
		end,
		Visible = props["Index"] > CurrentQueueIndex,
		[Children] = {

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("ImageButton")({
				Visible = true,

				Name = "DragHandle",
				Image = "rbxassetid://18961808481",
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(0.6, 0.6),
				ImageColor3 = Computed(function()
					return Handler_Interface:Get("DefaultAccentColor")
				end),

				[OnEvent("MouseButton1Down")] = function()
					Dragging:set(false)
				end,

				[OnEvent("MouseButton1Down")] = function()
					Dragging:set(true)

					local Button = DragRef:get() :: ImageButton
					local StarterLayoutOrder = Button.LayoutOrder

					local Transparency = Button.BackgroundTransparency

					--// Get Mouse Position and Delta
					local MousePosition = UserInputService:GetMouseLocation()

					local Highlight = New("Frame")({
						Size = UDim2.new(1, 0, 0, 1),
						BackgroundColor3 = Handler_Interface:Get("DefaultAccentColor"),
					})

					Highlight.Parent = Button.Parent

					RunService:BindToRenderStep("Drag", 0, function()
						local Height = Button.AbsoluteSize.Y
						local Delta = UserInputService:GetMouseLocation() - Button.AbsolutePosition
						local MouseDelta = UserInputService:GetMouseLocation() - MousePosition
						local NewLayoutOrder = math.clamp(
							(Button.LayoutOrder + math.floor(Delta.Y / Height)) - 1,
							0,
							#Handler_Interface:Get("Queue") + 1
						)

						Button.BackgroundTransparency = 0
						Button.SongTitle.TextColor3 = Luminance(Button.BackgroundColor3)

						if math.abs(MouseDelta.Y / Height) > 0.5 then
							Highlight.LayoutOrder =
								math.clamp(NewLayoutOrder - 1, 0, #Handler_Interface:Get("Queue") + 1)
						else
							Highlight.LayoutOrder = Button.LayoutOrder
						end

						if not UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
							Handler_Interface:Fire("QueueReorder", {
								["Index"] = StarterLayoutOrder,
								["NewIndex"] = NewLayoutOrder,
							})

							Highlight:Destroy()

							RunService:UnbindFromRenderStep("Drag")
						end
					end)
				end,

				[Children] = {
					New("UIAspectRatioConstraint")({
						AspectRatio = 1,
					}),
				},
			}),

			New("ImageButton")({

				Visible = true,

				Name = "RemoveFromQueue",
				Image = Images.Icons.Remove,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Size = UDim2.fromScale(0.6, 0.6),

				ImageColor3 = Color3.new(1, 1, 1),

				[OnEvent("MouseButton1Click")] = function()
					local CurrentQueue = Handler_Interface:Get("Queue")

					if props["asset_id"] == CurrentQueue[props.Index]["asset_id"] then
						table.remove(CurrentQueue, props["Index"])
						Handler_Interface:Set("Queue", CurrentQueue)
					end
				end,

				[Children] = {
					New("UIAspectRatioConstraint")({
						AspectRatio = 1,
					}),
				},
			}),
			New("TextLabel")({
				Name = "SongTitle",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = props["asset_name"],
				TextColor3 = Handler_Interface:Get("DefaultAccentColor"),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Size = UDim2.fromScale(0.7, 0.8),

				[Children] = {
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 5),
						PaddingRight = UDim.new(0.1, 0),
					}),
				},
			}),

			New("UIPadding")({
				Name = "UIPadding",
				PaddingRight = UDim.new(0.1, 0),
			}),
		},
	})
	return SearchResult
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX1f3b1da283c544b9807382588410e05c">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">QueueHeader</string>
							<string name="ScriptGuid">{02966748-5be5-4169-924f-34e9a353bb46}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Queue",
	HeaderPadding = 5,
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Queue

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type QueueHeaderProps = {}

return function(props: QueueHeaderProps)
	--// Value States
	local Active = Value(true)

	local SearchBoxRef = Handler_Interface:GetState("SearchBoxRef")

	local QueueHeader = New("Frame")({
		Name = "QueueHeader",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -5,
		Size = UDim2.fromScale(0.998, 0.102),

		[Children] = {
			New("UIPadding")({
				Name = "UIPadding",
				PaddingBottom = UDim.new(0, Settings.HeaderPadding),
				PaddingLeft = UDim.new(0, Settings.HeaderPadding),
				PaddingRight = UDim.new(0, Settings.HeaderPadding),
				PaddingTop = UDim.new(0, Settings.HeaderPadding),
			}),
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			ImageButton({
				Active = Active,
				Name = "BackButton",
				BackgroundColor3 = Color3.fromRGB(206, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.143, 0.769),
				Image = "",
				BackgroundTransparency = 0,
				AnimationSpeed = 0.2,
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				OnClick = function()
					Handler_Interface:Set("Page", "AudioPlayer")
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = "rbxassetid://18925477687",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.2, 0.3),
					}),
				},
			}),

			New("Frame")({
				Name = "Search",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.629, 0.769),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),
					New("UIFlexItem")({
						Name = "UIFlexItem",
						FlexMode = Enum.UIFlexMode.Fill,
					}),

					New("TextLabel")({
						[Ref] = SearchBoxRef,
						Name = "SearchBox",
						FontFace = Font.new(
							"rbxasset://fonts/families/SourceSansPro.json",
							Enum.FontWeight.Bold,
							Enum.FontStyle.Normal
						),
						Text = Computed(function()
							local CurrentAudio = Handler_Interface:Get("Sound")
							return typeof(CurrentAudio) == "table" and CurrentAudio["asset_name"] or "Loading..."
						end),
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextScaled = true,
						TextSize = 14,
						TextWrapped = true,
						TextXAlignment = Enum.TextXAlignment.Left,
						AnchorPoint = Vector2.new(1, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.967, 0.5),
						Size = UDim2.fromScale(0.723, 0.5),
					}),

					New("Frame")({
						Name = "Icon",
						AnchorPoint = Vector2.new(0, 0.5),
						BackgroundColor3 = Color3.fromRGB(17, 17, 17),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.025, 0.5),
						Size = UDim2.fromScale(0.189, 0.833),

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("ImageLabel")({
								Name = "Icon",
								Image = Images.Icons.Queue,
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.4, 0.4),

								[Children] = {
									New("UIAspectRatioConstraint")({
										Name = "UIAspectRatioConstraint",
									}),
								},
							}),

							New("UIAspectRatioConstraint")({
								Name = "UIAspectRatioConstraint",
							}),
						},
					}),
				},
			}),

			ImageButton({
				Visible = false,
				Active = Active,
				Name = "Clear",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.143, 0.769),
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				AnimationSpeed = 0.2,
				Image = "",
				BackgroundTransparency = 0,
				OnClick = function()
					print("Clearing")
					Handler_Interface:Set("QueueHeaderText", "")
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = "rbxassetid://18925488171",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.3, 0.3),
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 5.38,
				DominantAxis = Enum.DominantAxis.Height,
			}),
		},
	})

	return QueueHeader
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5a722be423c648a4a4e9c9aa50a2e0bf">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchBar</string>
							<string name="ScriptGuid">{930c266f-aab9-441b-bd7b-f53b66c8030e}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Search = require(Util.Search)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchBarProps = {}

return function(props: SearchBarProps)
	--// Value States
	local Active = Value(true)

	local LikesSearchBoxRef = Handler_Interface:GetState("LikesSearchBoxRef")

	local SearchBar = New("Frame")({
		Name = "SearchBar",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -5,
		Size = UDim2.fromScale(0.998, 0.102),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			ImageButton({
				Active = Active,
				Name = "BackButton",
				BackgroundColor3 = Color3.fromRGB(206, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.143, 0.769),
				Image = "",
				BackgroundTransparency = 0,
				AnimationSpeed = 0.2,
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				OnClick = function()
					Handler_Interface:Set("Page", "AudioPlayer")
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = "rbxassetid://18925477687",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.2, 0.3),
					}),
				},
			}),

			New("Frame")({
				Name = "Search",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.629, 0.769),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("TextBox")({
						[Ref] = LikesSearchBoxRef,
						Name = "SearchBox",
						CursorPosition = -1,
						FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json"),
						PlaceholderColor3 = Color3.fromRGB(73, 74, 74),
						PlaceholderText = Computed(function()
							return Handler_Interface:Get("LikesRetrieved") and "Input your search"
								or "Loading your songs..."
						end),
						Text = Computed(function()
							return Handler_Interface:Get("LikesSearchBarText")
						end),
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextScaled = true,
						TextSize = 14,
						TextWrapped = true,
						TextXAlignment = Enum.TextXAlignment.Left,
						AnchorPoint = Vector2.new(1, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.967, 0.5),
						Size = UDim2.fromScale(0.723, 0.5),
						ClearTextOnFocus = false,

						[OnEvent("Focused")] = function() end,
						[OnEvent("FocusLost")] = function(PressedEnter: string, Element)
							local Text = LikesSearchBoxRef:get().Text
							local FavoritesResultsCanvasRef =
								Handler_Interface:Get("FavoritesResultsCanvasRef") :: ScrollingFrame

							Handler_Interface:Set("LikesSearchBarText", Text)

							if Text ~= "" then
								Handler_Interface:Set(
									"FavoritesResults",
									Search.searchSongs(Text, Handler_Interface:Get("Favorites"))
								)

								FavoritesResultsCanvasRef.CanvasPosition = Vector2.new(0, 0)
							else
								Handler_Interface:Set("FavoritesResults", Handler_Interface:Get("Favorites"))
							end
						end,
					}),

					New("Frame")({
						Name = "Icon",
						AnchorPoint = Vector2.new(0, 0.5),
						BackgroundColor3 = Color3.fromRGB(17, 17, 17),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.025, 0.5),
						Size = UDim2.fromScale(0.189, 0.833),

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("ImageLabel")({
								Name = "Icon",
								Image = "rbxassetid://18935266802",
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.4, 0.4),

								[Children] = {
									New("UIAspectRatioConstraint")({
										Name = "UIAspectRatioConstraint",
									}),
								},
							}),

							New("UIAspectRatioConstraint")({
								Name = "UIAspectRatioConstraint",
							}),
						},
					}),
				},
			}),

			ImageButton({
				Active = Active,
				Name = "Clear",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.143, 0.769),
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				AnimationSpeed = 0.2,
				Image = "",
				BackgroundTransparency = 0,
				OnClick = function()
					local SearchTab = Handler_Interface:Get("SearchTab")

					Handler_Interface:Set("Pill", "NaN")
					Handler_Interface:Set("LikesSearchBarText", "")
					Handler_Interface:Set("GenreBoxSelected", false)

					Handler_Interface:Set("FavoritesResults", Handler_Interface:Get("Favorites"))
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("ImageLabel")({
						Name = "Icon",
						Image = "rbxassetid://18925488171",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.3, 0.3),
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 5.38,
				DominantAxis = Enum.DominantAxis.Height,
			}),
		},
	})

	return SearchBar
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1443ea05d1634f9b93096ff77eea50f5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Tabs</string>
							<string name="ScriptGuid">{e2060d48-a494-4b14-9d4a-c803ca629013}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type TabsProps = {}

return function(props: TabsProps)
	--// Value States
	local Active = Value(true)
	local QueueTab = Handler_Interface:GetState("QueueTab")

	local Tabs = New("Frame")({
		Name = "Tabs",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -10,
		Size = UDim2.fromScale(0.998, 0.102),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("Frame")({
				Name = "TabContainer",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.0238, 0.115),
				Size = UDim2.fromScale(0.939, 0.769),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("Frame")({
						Name = "Underlay",
						BackgroundColor3 = Computed(function()
							return Handler_Interface:Get("DefaultAccentColor")
						end),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Size = UDim2.fromScale(0.5, 1),
						AnchorPoint = Tween(
							Computed(function()
								return QueueTab:get() == "Queue" and Vector2.new(0, 0) or Vector2.new(1, 0)
							end),
							Tweens.Fast
						),

						Position = Tween(
							Computed(function()
								return QueueTab:get() == "Queue" and UDim2.fromScale(0, 0) or UDim2.fromScale(1, 0)
							end),
							Tweens.Fast
						),

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),
						},
					}),

					New("Frame")({
						Name = "Overlay",
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Size = UDim2.fromScale(1, 1),

						[Children] = {
							New("UIListLayout")({
								Name = "UIListLayout",
								FillDirection = Enum.FillDirection.Horizontal,
								SortOrder = Enum.SortOrder.LayoutOrder,
							}),

							ImageButton({
								Active = Active,
								Size = Computed(function()
									if QueueTab:get() == "Queue" then
										return UDim2.fromScale(0.5, 1)
									end

									return UDim2.fromScale(0.5, 1)
								end),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								Image = "",
								AnimationSpeed = 0.2,
								GrowthSize = 1.1,
								ShrinkSize = 0.9,

								OnClick = function()
									QueueTab:set("Queue")
								end,
								Children = {
									New("TextLabel")({
										Name = "Queue",
										FontFace = Font.new(
											"rbxasset://fonts/families/SourceSansPro.json",
											Enum.FontWeight.Bold,
											Enum.FontStyle.Normal
										),
										TextSize = 25,
										TextScaled = true,
										TextWrapped = true,
										Text = "Queue",
										BackgroundColor3 = Color3.fromRGB(255, 255, 255),
										BackgroundTransparency = 1,
										BorderColor3 = Color3.fromRGB(0, 0, 0),
										TextColor3 = Tween(
											Computed(function()
												return QueueTab:get() ~= "Queue" and Color3.new(1, 1, 1)
													or Color3.new(0, 0, 0)
											end),
											Tweens.Fast
										),
										BorderSizePixel = 0,
										Size = UDim2.fromScale(1, 1),
									}),

									New("UIPadding")({
										Name = "UIPadding",
										PaddingBottom = UDim.new(0, 5),
										PaddingLeft = UDim.new(0, 5),
										PaddingRight = UDim.new(0, 5),
										PaddingTop = UDim.new(0, 5),
									}),
								},
							}),

							ImageButton({
								Active = Active,
								Size = Computed(function()
									return UDim2.fromScale(0.5, 1)
								end),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								Image = "",
								AnimationSpeed = 0.2,
								GrowthSize = 1.1,
								ShrinkSize = 0.9,

								AnchorPoint = Vector2.new(0.5, 0),
								Position = UDim2.fromScale(0.5, 0),
								OnClick = function()
									QueueTab:set("Favorites")
								end,
								Children = {
									New("TextLabel")({
										Name = "Favorites",
										FontFace = Font.new(
											"rbxasset://fonts/families/SourceSansPro.json",
											Enum.FontWeight.Bold,
											Enum.FontStyle.Normal
										),
										TextSize = 25,
										TextScaled = true,
										TextWrapped = true,
										Text = "Favorites",
										BackgroundColor3 = Color3.fromRGB(255, 255, 255),
										BackgroundTransparency = 1,
										BorderColor3 = Color3.fromRGB(0, 0, 0),
										TextColor3 = Tween(
											Computed(function()
												return QueueTab:get() == "Queue" and Color3.new(1, 1, 1)
													or Color3.new(0, 0, 0)
											end),
											Tweens.Fast
										),
										BorderSizePixel = 0,
										Size = UDim2.fromScale(1, 1),
									}),

									New("UIPadding")({
										Name = "UIPadding",
										PaddingBottom = UDim.new(0, 5),
										PaddingLeft = UDim.new(0, 5),
										PaddingRight = UDim.new(0, 5),
										PaddingTop = UDim.new(0, 5),
									}),
								},
							}),
						},
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 5.38,
				DominantAxis = Enum.DominantAxis.Height,
			}),
		},
	})

	return Tabs
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX8eaf488d80f7476fa02398efd8409721">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Root</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXc89e2f04ce2443879af6e5d81bbf8cb5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Search</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX2c311549d0b94bf9bf846db15821036a">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GenreBoxes</string>
							<string name="ScriptGuid">{b432a74d-21eb-4ec1-ab26-bfbe5c6f7d57}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Screen = require(Util.Screen)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Genres = require(Util.Genres)
local Luminance = require(Util.Luminance)
local MatteColor = require(Util.MatteColor)
local PastelColor = require(Util.PastelColor)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

local GenreBoxText = {
	["Trap"] = "Trap",
	["Ambient Background"] = "Ambient Background",
	["Chiptune"] = "Chiptune",
	["Phonk"] = "Phonk",
	["Dubstep"] = "Dubstep",
	["EDM"] = "EDM",
	["Lo-fi"] = "Lo-fi",
	["Movie Music"] = "Movie Music",
	["Hip-hop"] = "Hip-hop",
	["Pop"] = "Pop",
	["Rock"] = "Rock",
	["Kitsch-Retro"] = "Kitsch-Retro",
	["Classical"] = "Classical",
	["Reality TV Music"] = "Reality TV Music",
	["Latin"] = "Latin",
	["Folk"] = "Folk",
	["Folk-World"] = "Folk-World",
	["Elevator Music"] = "Elevator Music",
	["World-Beat"] = "World-Beat",
	["R&B"] = "R&B",
	["Country"] = "Country",
	["World-Pop"] = "World-Pop",
	["Jazz"] = "Jazz",
	["Religious"] = "Religious",
	["Blues"] = "Blues",
	["Kids"] = "Kids",
}

type GenreBoxesProps = {}

return function(props: GenreBoxesProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local GenreBoxes = New("ScrollingFrame")({
		Name = "GenreBoxes",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.0249, 0.2),
		Size = UDim2.fromScale(0.95, 0.799),
		AutomaticCanvasSize = Enum.AutomaticSize.Y,
		ScrollBarThickness = 1,

		Visible = Computed(function()
			local SearchTab = Handler_Interface:Get("SearchTab") :: string
			local SearchBarText = Handler_Interface:Get("SearchBarText") :: string
			local GenreBoxSelected = Handler_Interface:Get("GenreBoxSelected") :: string

			if SearchTab ~= "Library" then
				return false
			end

			if GenreBoxSelected or #SearchBarText > 0 then
				return false
			end

			return true
		end),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				Wraps = true,
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			New("UIPadding")({
				Name = "UIPadding",
				PaddingBottom = UDim.new(0, 5),
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),

			Computed(function()
				local CurrentGenres = Handler_Interface:Get("Genres")

				if #CurrentGenres == 0 then
					return New("TextLabel")({
						Text = "Wait while we download your tracks from Space...",
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextSize = 14,
						TextScaled = true,
						TextWrapped = true,
						Size = UDim2.new(1, 0, 0, 35),
						BackgroundTransparency = 1,
					})
				end
			end, function() end),

			Computed(function()
				local Temp = {}
				local DisabledGeneres = {
					["Heavy Metal"] = true,
					["Rock Soundtrack"] = true,
					["Dubstep"] = true,
					["Chill Rock"] = true,
					["Chill Electronic"] = true,
					["Chill Orchestral"] = true,
					["Epic Orchestral"] = true,
				}

				local ExcludedStations = Handler_Interface:Get("ExcludedStations") :: { string }
				local CurrentGenres = Handler_Interface:Get("Genres")

				-- for i = 1, 10 do
				-- 	table.insert(CurrentGenres, "Station  Test")
				-- end

				for Index, AudioScapeGenre in CurrentGenres do
					if
						DisabledGeneres[AudioScapeGenre]
						or ExcludedStations[AudioScapeGenre]
						or table.find(ExcludedStations, AudioScapeGenre)
					then
						continue
					end

					local IsStation = true

					if GenreBoxText[AudioScapeGenre] then
						IsStation = false
					end

					local BoxColor = IsStation and Color3.fromRGB(255, 255, 255) or MatteColor()
					local StationGradients = {
						MatteColor(),
						MatteColor(),
					}

					table.insert(
						Temp,
						New("ImageButton")({
							Name = `{AudioScapeGenre}GenreBox`,
							ImageColor3 = BoxColor,
							BackgroundColor3 = BoxColor,
							BorderColor3 = Color3.fromRGB(0, 0, 0),
							BorderSizePixel = 0,
							Size = UDim2.fromScale(0.32, 1),
							Visible = true,
							[OnEvent("MouseButton1Click")] = function()
								if not IsStation then
									Handler_Interface:Set("GenreBoxSelected", AudioScapeGenre)
								end

								Handler_Interface:Fire("ClientAudioscape", "search", {
									genre = AudioScapeGenre,
								}, IsStation)
							end,
							LayoutOrder = GenreBoxText[AudioScapeGenre] and Index or math.random(-100, -1),

							[Children] = {
								New("UIAspectRatioConstraint")({
									Name = "UIAspectRatioConstraint",
								}),

								New("UICorner")({
									Name = "UICorner",
									CornerRadius = UDim.new(0, 3),
								}),

								New("UIPadding")({
									Name = "UIPadding",
									PaddingBottom = UDim.new(0.1, 0),
									PaddingLeft = UDim.new(0.1, 0),
									PaddingRight = UDim.new(0.1, 0),
									PaddingTop = UDim.new(0.1, 0),
								}),

								New("TextLabel")({
									Name = "TextLabel",
									FontFace = Font.new(
										"rbxasset://fonts/families/Arimo.json",
										Enum.FontWeight.Bold,
										Enum.FontStyle.Normal
									),
									Text = Computed(function()
										if IsStation then
											local Text = `{AudioScapeGenre} Station`
											local SplitText = Text:split(" ")

											return table.concat(SplitText, "\n")
										end

										return AudioScapeGenre
									end),
									TextColor3 = Computed(function()
										if IsStation then
											return Luminance(StationGradients[1])
										end

										return Luminance(BoxColor)
									end),
									-- TextScaled = true,
									TextSize = Screen().width < 1000 and 10 or 14,
									-- TextSize = Computed(function()
									-- 	if Screen().Width < 1000 then
									-- 		return 14
									-- 	end

									-- 	return 20
									-- end),
									TextWrapped = true,
									TextXAlignment = Enum.TextXAlignment.Left,
									TextYAlignment = Enum.TextYAlignment.Top,
									BackgroundColor3 = Color3.fromRGB(255, 255, 255),
									BackgroundTransparency = 1,
									BorderColor3 = Color3.fromRGB(0, 0, 0),
									BorderSizePixel = 0,
									Size = UDim2.fromScale(1, 1),

									[Children] = {
										New("UITextSizeConstraint")({
											Name = "UITextSizeConstraint",
											MaxTextSize = 40,
										}),
									},
								}),

								if IsStation
									then New("ImageLabel")({
										Name = "ImageLabel",
										Image = Images.Icons.Radio,
										Size = UDim2.fromScale(0.25, 0.25),
										BackgroundTransparency = 1,
										AnchorPoint = Vector2.new(1, 1),
										Position = UDim2.fromScale(1, 1),
										ImageColor3 = Luminance(StationGradients[2]),

										[Children] = {
											New("UIAspectRatioConstraint")({
												Name = "UIAspectRatioConstraint",
											}),
										},
									})
									else {},

								if IsStation
									then New("UIGradient")({
										Name = "UIGradient",
										Color = ColorSequence.new({
											ColorSequenceKeypoint.new(0, StationGradients[1]),
											ColorSequenceKeypoint.new(1, StationGradients[2]),
										}),
										Rotation = 45,
									})
									else {},
							},
						})
					)
				end

				return Temp
			end, function() end),
		},
	})

	return GenreBoxes
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6169b682e8964bcb9aa084b93dcfa124">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PillsContainer</string>
							<string name="ScriptGuid">{80e41688-3dce-4e9b-960c-0bfe57481f7b}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Genres = require(Util.Genres)
local Search = require(Util.Search)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local Pill = require(script.Pill)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PillsContainerProps = {}

return function(props: PillsContainerProps)
	--// Value States
	local Active = Value(false)
	local ParentalRef = Value(nil)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local PillsContainer = New("Frame")({
		[Ref] = ParentalRef,
		Name = "Pills",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -2,
		Size = UDim2.fromScale(0.998, 0.1),

		Visible = Computed(function()
			if Handler_Interface:Get("SearchTab") ~= "Library" then
				return true
			end

			return Handler_Interface:Get("GenreBoxSelected") and true or false
		end),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				VerticalFlex = Enum.UIFlexAlignment.SpaceBetween,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("Frame")({
				Name = "BottomSeparator",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.new(1, 0, 0, 1),
			}),

			New("Frame")({
				Name = "TopSeparator",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = -2,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.new(1, 0, 0, 2),
			}),

			New("Frame")({
				Name = "PillsContainer",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0, -0.16),
				Size = UDim2.fromScale(1, 1),

				[Children] = {
					New("UIFlexItem")({
						Name = "UIFlexItem",
						FlexMode = Enum.UIFlexMode.Fill,
					}),
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 10),
					}),
					Computed(function()
						local KeyboardDetected = Handler_Interface:Get("KeyboardDetected")
						-- AutomaticCanvasSize = Enum.AutomaticSize.X,
						-- CanvasSize = UDim2.fromScale(2, 1),
						-- ScrollingDirection = Enum.ScrollingDirection.X,
						-- ScrollBarThickness = 1,

						return New(KeyboardDetected and "Frame" or "ScrollingFrame")({
							[Ref] = Handler_Interface:GetState("PillsCanvasRef"),

							Name = "Listing",
							Active = true,
							BackgroundColor3 = Color3.fromRGB(255, 255, 255),
							BackgroundTransparency = 1,
							BorderColor3 = Color3.fromRGB(0, 0, 0),
							BorderSizePixel = 0,
							Size = UDim2.fromScale(1, 0.997),

							[Children] = {
								Computed(function()
									local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame
									if PillsCanvasRef and PillsCanvasRef:IsA("ScrollingFrame") then
										PillsCanvasRef.ScrollingDirection = Enum.ScrollingDirection.X
										PillsCanvasRef.AutomaticCanvasSize = Enum.AutomaticSize.X
										PillsCanvasRef.Size = UDim2.new(1, 0, 0, 50)
										PillsCanvasRef.ScrollBarThickness = 0
									end
								end, function() end),

								New("UIListLayout")({
									Name = "UIListLayout",
									Padding = UDim.new(0.02, 0),
									FillDirection = Enum.FillDirection.Horizontal,
									SortOrder = Enum.SortOrder.LayoutOrder,
									VerticalAlignment = Enum.VerticalAlignment.Top,
									HorizontalAlignment = KeyboardDetected and Enum.HorizontalAlignment.Center
										or Enum.HorizontalAlignment.Left,
									Wraps = Computed(function()
										return KeyboardDetected
									end),
								}),

								New("UIPadding")({
									Name = "UIPadding",
									PaddingTop = KeyboardDetected and UDim.new(0, 0) or UDim.new(0.1, 0),
									PaddingBottom = KeyboardDetected and UDim.new(0.2, 0) or UDim.new(0, 0),
								}),

								Computed(function()
									local Parental = ParentalRef:get() :: Frame
									local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame
									local Emotions = Handler_Interface:Get("Emotions") :: { string }
									local SelectedGenre = Handler_Interface:Get("GenreBoxSelected") :: string?

									local PillCount = 0
									local PillComponents = {}

									if SelectedGenre then
										-- for Index, Emotion in Emotions do
										for Index, Emotion in Emotions do
											table.insert(
												PillComponents,
												Pill({
													Index = PillCount,
													Text = Emotion,
													Genre = SelectedGenre,
												})
											)

											PillCount += 1
										end
									end

									if #PillComponents > 0 and Parental and PillsCanvasRef then
										local FirstPill = PillComponents[1] :: ImageButton

										Parental.Size = UDim2.new(
											1,
											0,
											0, -- KeyboardDetected and 0 or 0.1,
											KeyboardDetected
													and (math.floor(#PillComponents / 3) * FirstPill.AbsoluteSize.Y) + 30
												or FirstPill.AbsoluteSize.Y + 20
										)

										local InitialSize = Parental.AbsoluteSize

										print(InitialSize, math.floor(InitialSize.X / FirstPill.AbsoluteSize.X))
									end

									return PillComponents
								end, function() end),
							},
						})
					end, function() end),

					New("ImageLabel")({
						Name = "ImageLabel",
						Image = "rbxassetid://18925300527",
						AnchorPoint = Vector2.new(1, 0),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(1, 0),
						Size = UDim2.new(-0.159, 100, 0.719, 0),
						Visible = Computed(function()
							return not Handler_Interface:Get("KeyboardDetected")
						end),
					}),
				},
			}),
		},
	})

	return PillsContainer
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXc5814be3beb147ec9a57186935ec73d7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Pill</string>
								<string name="ScriptGuid">{e7af6d9f-ca61-41f4-99b1-364cb154a86d}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Search = require(Util.Search)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type PillProps = {
	Index: number,
	Text: string,
	Genre: string,
	OnClick: (() -> nil)?,
}

return function(props: PillProps)
	--// Value States
	local Active = Value(true)

	local IsSelected = Handler_Interface:Get("Pill") == props.Text

	local Pill = ImageButton({
		Active = Active,
		Name = "Pill",
		BackgroundColor3 = Computed(function()
			return IsSelected and Handler_Interface:Get("DefaultAccentColor") or Color3.fromRGB(31, 31, 31)
		end),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Size = UDim2.fromOffset(80, 100),
		BackgroundTransparency = 0,
		Image = "",
		GrowthSize = 1.1,
		ShrinkSize = 0.9,
		AnimationSpeed = 0.1,
		LayoutOrder = Computed(function()
			return IsSelected and -1 or props.Index
		end),

		AspectRatio = 3.15,

		OnClick = function()
			local PillsCanvasRef = Handler_Interface:Get("PillsCanvasRef") :: ScrollingFrame
			local SearchResultsCanvasRef = Handler_Interface:Get("SearchResultsCanvasRef") :: ScrollingFrame

			if IsSelected then
				Handler_Interface:Set("Pill", "")
				Handler_Interface:Fire("ClientAudioscape", "search", {
					genre = props["Genre"],
				})
			else
				Handler_Interface:Set("Pill", props.Text)
				Handler_Interface:Fire("ClientAudioscape", "search", {
					genre = props["Genre"],
					emotion = props["Text"],
				})
			end

			SearchResultsCanvasRef.CanvasPosition = Vector2.new(0, 0)

			local _ = if props["OnClick"] then props["OnClick"]() else nil
		end,

		Children = {
			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(1, 0),
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				TextColor3 = Computed(function()
					return (
						IsSelected and Luminance(Handler_Interface:Get("DefaultAccentColor"))
						or Color3.fromRGB(255, 255, 255)
					)
				end),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				Text = props.Text,
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0.5, 0.5),
				Size = UDim2.fromScale(0.9, 0.9), -- PillTextSize
			}),

			-- New("UIAspectRatioConstraint")({
			-- 	Name = "UIAspectRatioConstraint",
			-- 	AspectRatio = 3.15,
			-- }),
		},
	})

	return Pill
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXe81e827989a44d4c9c79eaef2f40a32f">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchBar</string>
							<string name="ScriptGuid">{5341f190-f078-4af7-9c6c-33eb6533d993}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Search = require(Util.Search)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchBarProps = {}

return function(props: SearchBarProps)
	--// Value States
	local Active = Value(true)

	local SearchBoxRef = Handler_Interface:GetState("SearchBoxRef")

	local SearchBar = New("Frame")({
		Name = "SearchBar",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -5,
		Size = UDim2.fromScale(0.998, 0.102),
		Visible = Computed(function()
			return Handler_Interface:Get("SearchEnabled")
		end),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("UIPadding")({
				Name = "UIPadding",

				PaddingLeft = UDim.new(0, 10),
				PaddingRight = UDim.new(0, 10),
			}),

			New("Frame")({
				Name = "Search",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.329, 0),
				Size = UDim2.fromScale(0.939, 0.769),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("TextBox")({
						[Ref] = SearchBoxRef,
						Name = "SearchBox",
						CursorPosition = -1,
						FontFace = Font.new("rbxasset://fonts/families/SourceSansPro.json"),
						PlaceholderColor3 = Color3.fromRGB(73, 74, 74),
						PlaceholderText = "Paste a song ID",
						Text = Computed(function()
							return Handler_Interface:Get("SearchBarText")
						end),
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextScaled = true,
						TextSize = 14,
						TextWrapped = true,
						TextXAlignment = Enum.TextXAlignment.Left,
						AnchorPoint = Vector2.new(1, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.967, 0.5),
						Size = UDim2.fromScale(0.723, 0.5),
						ClearTextOnFocus = false,

						[OnEvent("Focused")] = function() end,
						[OnEvent("FocusLost")] = function(PressedEnter: string, Element)
							local Text: string = SearchBoxRef:get().Text

							Handler_Interface:Set("SearchBarText", Text)

							if Handler_Interface:Get("SearchTab") == "Library" then
								if tonumber(Text) or Text:lower():find("rbxassetid://") then
									local NumberId = tonumber(Text)
									local AssetId = Text:lower():find("rbxassetid://")

									if NumberId then
										Handler_Interface:Fire("ProcessIDSearch", NumberId)
									elseif AssetId then
										Handler_Interface:Fire("ProcessIDSearch", Text:sub(14, #Text))
									end
									return
								else
									Handler_Interface:Set("SearchBarText", "Not a valid song ID!")
									task.delay(0.5, function()
										Handler_Interface:Set("SearchBarText", "")
									end)
								end
								-- Handler_Interface:Fire("ClientAudioscape", "search", {
								-- 	query = Text,
								-- })
							else
								if Text ~= "" then
									Handler_Interface:Set(
										"FavoritesResults",
										Search.searchSongs(Text, Handler_Interface:Get("Favorites"))
									)
								else
									Handler_Interface:Set("FavoritesResults", Handler_Interface:Get("Favorites"))
								end
							end
						end,
					}),

					New("Frame")({
						Name = "Icon",
						AnchorPoint = Vector2.new(0, 0.5),
						BackgroundColor3 = Color3.fromRGB(17, 17, 17),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.025, 0.5),
						Size = UDim2.fromScale(0.189, 0.833),

						[Children] = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("ImageLabel")({
								Name = "Icon",
								Image = "rbxassetid://18935266802",
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.4, 0.4),

								[Children] = {
									New("UIAspectRatioConstraint")({
										Name = "UIAspectRatioConstraint",
									}),
								},
							}),

							New("UIAspectRatioConstraint")({
								Name = "UIAspectRatioConstraint",
							}),
						},
					}),

					ImageButton({
						Active = Active,
						Name = "Clear",
						BackgroundColor3 = Color3.fromRGB(31, 31, 31),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						AnchorPoint = Vector2.new(1, 0.5),
						LayoutOrder = 2,
						Position = UDim2.fromScale(0.99, 0.5),
						Size = UDim2.fromScale(0.143, 0.769),
						GrowthSize = 1.1,
						ShrinkSize = 0.9,
						AnimationSpeed = 0.2,
						Image = "",
						BackgroundTransparency = 0,
						OnClick = function()
							local SearchTab = Handler_Interface:Get("SearchTab")

							Handler_Interface:Set("Pill", "NaN")
							Handler_Interface:Set("SearchBarText", "")
							Handler_Interface:Set("GenreBoxSelected", false)

							if SearchTab == "Library" then
								Handler_Interface:Set("LibraryResults", {})
							else
								Handler_Interface:Set("FavoritesResults", Handler_Interface:Get("Favorites"))
							end
						end,

						Children = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("ImageLabel")({
								Name = "Icon",
								Image = "rbxassetid://18925488171",
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.3, 0.3),
							}),
						},
					}),

					New("UIFlexItem")({
						Name = "UIFlexItem",
						FlexMode = Enum.UIFlexMode.Fill,
					}),
				},
			}),

			-- ImageButton({
			-- 	Active = Active,
			-- 	Name = "Search",
			-- 	BackgroundColor3 = Color3.fromRGB(31, 31, 31),
			-- 	BorderColor3 = Color3.fromRGB(0, 0, 0),
			-- 	BorderSizePixel = 0,
			-- 	LayoutOrder = 2,
			-- 	Position = UDim2.fromScale(0.329, 0),
			-- 	Size = UDim2.fromScale(0.143, 0.769),
			-- 	GrowthSize = 1.1,
			-- 	ShrinkSize = 0.9,
			-- 	AnimationSpeed = 0.2,
			-- 	Image = "",
			-- 	BackgroundTransparency = 0,
			-- 	OnClick = function() end,

			-- 	Children = {
			-- 		New("UICorner")({
			-- 			Name = "UICorner",
			-- 			CornerRadius = UDim.new(0, 5),
			-- 		}),

			-- 		New("ImageLabel")({
			-- 			Name = "Icon",
			-- 			Image = "rbxassetid://18935266802",
			-- 			AnchorPoint = Vector2.new(0.5, 0.5),
			-- 			BackgroundColor3 = Color3.fromRGB(255, 255, 255),
			-- 			BackgroundTransparency = 1,
			-- 			BorderColor3 = Color3.fromRGB(0, 0, 0),
			-- 			BorderSizePixel = 0,
			-- 			Position = UDim2.fromScale(0.5, 0.5),
			-- 			Size = UDim2.fromScale(0.3, 0.3),
			-- 		}),
			-- 	},
			-- }),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 5.38,
				DominantAxis = Enum.DominantAxis.Height,
			}),
		},
	})

	return SearchBar
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX91efe18baa4243bba6b2339b0a7f2da1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchResults</string>
							<string name="ScriptGuid">{aa382614-22f6-4a9f-afb5-22410fdc6d98}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local TimeSorter = require(Util.TimeSorter)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local SearchResult = require(script.SearchResult)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultsProps = {}

return function(props: SearchResultsProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local SearchResults = New("ScrollingFrame")({
		[Ref] = Handler_Interface:GetState("SearchResultsCanvasRef"),
		Name = "Results",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.0249, 0.2),
		Size = UDim2.fromScale(0.95, 0.799),
		Visible = Computed(function()
			local Searching = Handler_Interface:Get("Searching") :: boolean
			local SearchTab = Handler_Interface:Get("SearchTab") :: string
			local SearchBarText = Handler_Interface:Get("SearchBarText") :: string
			local GenreBoxSelected = Handler_Interface:Get("GenreBoxSelected") :: string

			if Searching then
				return false
			end

			if SearchTab ~= "Library" then
				return true
			end

			if #SearchBarText > 0 or GenreBoxSelected then
				return true
			end

			return false
		end),

		ScrollBarThickness = 1,
		AutomaticCanvasSize = Enum.AutomaticSize.Y,

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),

			Computed(function()
				local SearchTab = Handler_Interface:Get("SearchTab") :: string
				local LibraryResults = Handler_Interface:Get("LibraryResults")
				local FavoritesResults = Handler_Interface:Get("FavoritesResults")

				local SongCount = 1
				local SongResultList = {}

				local CuratedResults = SearchTab == "Library" and LibraryResults or FavoritesResults

				if SearchTab ~= "Library" and #CuratedResults > 1 then
					TimeSorter(CuratedResults)
				end

				for Index, Song in CuratedResults do
					Song.Index = SearchTab == "Library" and Index or SongCount
					Song.Dark = SongCount % 2 == 0

					table.insert(SongResultList, SearchResult(Song))

					SongCount += 1
				end

				return SongResultList
			end, function() end),
		},
	})

	return SearchResults
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX8bc5e8dd0aa7422f9581c5d0c4fc5d27">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SearchResult</string>
								<string name="ScriptGuid">{a5780b48-fcd4-42b4-a51d-9dec7819adc1}</string>
								<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchResultProps = {
	["asset_audio_details_artist"]: string,
	["asset_audio_details_music_album"]: string,
	["asset_audio_details_music_genre"]: string,
	["asset_audio_details_sound_effect_category"]: string | nil,
	["asset_audio_details_sound_effect_subcategory"]: string | nil,
	["asset_audio_details_tags"]: string,
	["asset_created_utc"]: string,
	["asset_description"]: string,
	["asset_duration"]: string,
	["asset_id"]: string,
	["asset_name"]: string,
	["asset_updated_utc"]: string,
	["creator_id"]: string,
	["creator_is_verified_creator"]: boolean,
	["creator_name"]: string,
	["asset_bpm"]: number | nil,
	["asset_first_beat_offset"]: number | nil,
	["asset_first_downbeat"]: number | nil,

	Liked: boolean,
	Index: number,
	Dark: boolean,
}

return function(props: SearchResultProps)
	--// Value States
	local FavoritesDictionary = Handler_Interface:Get("FavoritesDictionary")

	local Active = Value(true)
	local Liked = Value(FavoritesDictionary[props["asset_id"]] or false)

	local LikedImage = "rbxassetid://18952672240"
	local UnlikedImage = "rbxassetid://18925349461"

	local SearchResult = ImageButton({
		Active = Active,
		GrowthSize = 1.025,
		ShrinkSize = 0.95,
		AnimationSpeed = 0.2,
		Name = "SearchResult",
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = props["Index"] or 1,
		Size = UDim2.new(1, 0, 0, 35),
		BackgroundTransparency = props["Dark"] and 1 or 0,
		Image = "",

		OnClick = function()
			Handler_Interface:Fire("PlaySound", props)
		end,

		Children = {
			ImageButton({
				Active = Active,
				GrowthSize = 1.1,
				ShrinkSize = 0.5,
				AspectRatio = 1.2,
				AnimationSpeed = 0.2,

				Visible = Computed(function()
					return Handler_Interface:Get("SearchTab") == "Library"
				end),

				Name = "Like",
				Image = Computed(function()
					return Liked:get() and LikedImage or UnlikedImage
				end),
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 2,
				Size = UDim2.fromScale(0.6, 0.6),

				ImageColor3 = Computed(function()
					return Liked:get() and Handler_Interface:Get("DefaultAccentColor") or Color3.fromRGB(255, 255, 255)
				end),

				OnClick = function()
					Liked:set(not Liked:get())
					Handler_Interface:Fire("LikeEvent", props, Liked:get())
				end,
			}),

			ImageButton({
				Active = Active,
				GrowthSize = 1.1,
				ShrinkSize = 0.5,
				AnimationSpeed = 0.2,

				Visible = Computed(function()
					return Handler_Interface:Get("SearchTab") == "Library"
				end),

				Name = "AddToQueue",
				Image = "rbxassetid://18925349301",
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(0.6, 0.6),
				ImageColor3 = Computed(function()
					return Handler_Interface:Get("DefaultAccentColor")
				end),

				OnClick = function()
					Handler_Interface:Fire("AddToQueue", props)
				end,

				AspectRatio = 1,
			}),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("UICorner")({
				Name = "UICorner",
				CornerRadius = UDim.new(0, 5),
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = props["asset_name"] or "Unknown",
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Size = UDim2.fromScale(0.7, 0.8),

				[Children] = {
					New("UIPadding")({
						Name = "UIPadding",
						PaddingLeft = UDim.new(0, 5),
						PaddingRight = UDim.new(0.1, 0),
					}),
				},
			}),
		},
	})

	return SearchResult
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX6ac9c77122db4f8f827489e27d895239">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SearchingFrame</string>
							<string name="ScriptGuid">{2ae1012e-4018-47cc-bf30-b8207ba6cc41}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Genres = require(Util.Genres)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
	SpinnerSize = 50,
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchingFrameProps = {}

return function(props: SearchingFrameProps)
	--// Value States
	local Active = Value(false)
	local SpinnerRef = Value()

	RunService:BindToRenderStep("BoomboxSearchingAnimation", 0, function()
		if SpinnerRef:get() then
			SpinnerRef:get().Rotation = SpinnerRef:get().Rotation + 5
		end
	end)

	local SearchingFrame = New("Frame")({
		[Cleanup] = function()
			RunService:UnbindFromRenderStep("BoomboxSearchingAnimation")
		end,
		Name = "SearchingFrame",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.0249, 0.2),
		Size = UDim2.fromScale(0.95, 0.799),

		Visible = Computed(function()
			return Handler_Interface:Get("Searching")
		end),

		[Children] = {

			New("UIPadding")({
				Name = "UIPadding",
				PaddingTop = UDim.new(0, 5),
				PaddingBottom = UDim.new(0, 5),
			}),

			New("Frame")({
				[Ref] = SpinnerRef,
				Size = UDim2.fromOffset(Settings.SpinnerSize, Settings.SpinnerSize),
				AnchorPoint = Vector2.new(0.5, 0.5),
				Position = UDim2.fromScale(0.5, 0.5),
			}),

			New("TextLabel")({
				Name = "TextLabel",
				FontFace = Font.new(
					"rbxasset://fonts/families/SourceSansPro.json",
					Enum.FontWeight.Bold,
					Enum.FontStyle.Normal
				),
				Text = "Searching...",
				TextColor3 = Computed(function()
					return Luminance(Color3.new(0, 0, 0))
				end),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Bottom,
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				BackgroundTransparency = 1,
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Size = UDim2.fromScale(1, 1),

				[Children] = {
					New("UITextSizeConstraint")({
						Name = "UITextSizeConstraint",
						MaxTextSize = 40,
					}),
				},
			}),

			New("UIFlexItem")({
				Name = "UIFlexItem",
				FlexMode = Enum.UIFlexMode.Fill,
			}),
		},
	})

	return SearchingFrame
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXdddfc75c218e4e28b07eac8dc2e6b9e0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Tabs</string>
							<string name="ScriptGuid">{444bc92a-da3b-487d-ab2b-183c309488e7}</string>
							<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Luminance = require(Util.Luminance)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type TabsProps = {}

return function(props: TabsProps)
	--// Value States
	local Active = Value(true)
	local SearchTab = Handler_Interface:GetState("SearchTab")

	local Tabs = New("Frame")({
		Name = "Tabs",
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = -10,
		Size = UDim2.fromScale(0.998, 0.102),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),

			New("Frame")({
				Name = "TabContainer",
				BackgroundColor3 = Color3.fromRGB(31, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.0238, 0.115),
				Size = UDim2.fromScale(0.939, 0.769),

				[Children] = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("UIListLayout")({
						Name = "UIListLayout",
						FillDirection = Enum.FillDirection.Horizontal,
						SortOrder = Enum.SortOrder.LayoutOrder,
						Padding = UDim.new(0.02, 0),
					}),

					ImageButton({
						Active = Active,
						Name = "BackButton",
						BackgroundColor3 = Color3.fromRGB(206, 31, 31),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.0, 0),
						Size = UDim2.fromScale(1, 1),
						Image = "",
						BackgroundTransparency = 0,
						LayoutOrder = -2,
						AnimationSpeed = 0.2,
						GrowthSize = 1.1,
						ShrinkSize = 0.9,
						AspectRatio = 1,
						OnClick = function()
							Handler_Interface:Set("Page", "AudioPlayer")
						end,

						Children = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("ImageLabel")({
								Name = "Icon",
								Image = "rbxassetid://18925477687",
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.2, 0.3),
							}),
						},
					}),

					New("Frame")({
						Name = "Overlay",
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 0,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Size = UDim2.fromScale(1, 1),

						[Children] = {
							New("UIListLayout")({
								Name = "UIListLayout",
								FillDirection = Enum.FillDirection.Horizontal,
								SortOrder = Enum.SortOrder.LayoutOrder,
							}),

							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("UIFlexItem")({
								Name = "UIFlexItem",
								FlexMode = Enum.UIFlexMode.Fill,
							}),

							ImageButton({
								Active = Active,
								Size = Computed(function()
									if SearchTab:get() == "Library" then
										return UDim2.fromScale(1, 1)
									end

									return UDim2.fromScale(0, 1)
								end),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								Image = "",
								AnimationSpeed = 0.2,
								GrowthSize = 1.1,
								ShrinkSize = 0.9,

								OnClick = function()
									SearchTab:set("Library")
								end,
								Children = {
									New("TextLabel")({
										Name = "Library",
										FontFace = Font.new(
											"rbxasset://fonts/families/SourceSansPro.json",
											Enum.FontWeight.Bold,
											Enum.FontStyle.Normal
										),
										TextSize = 25,
										TextScaled = true,
										TextWrapped = true,
										Text = Computed(function()
											local GenreBoxSelected = Handler_Interface:Get("GenreBoxSelected")

											if GenreBoxSelected then
												return GenreBoxSelected
											end

											return "Browse"
										end),
										BackgroundColor3 = Color3.fromRGB(255, 255, 255),
										BackgroundTransparency = 1,
										BorderColor3 = Color3.fromRGB(0, 0, 0),
										TextColor3 = Color3.new(0, 0, 0),
										BorderSizePixel = 0,
										Size = UDim2.fromScale(1, 1),
									}),

									New("UIPadding")({
										Name = "UIPadding",
										PaddingBottom = UDim.new(0, 5),
										PaddingLeft = UDim.new(0, 5),
										PaddingRight = UDim.new(0, 5),
										PaddingTop = UDim.new(0, 5),
									}),
								},
							}),

							ImageButton({
								Active = Active,
								Size = Computed(function()
									if Handler_Interface:Get("SearchTab") ~= "Library" then
										return UDim2.fromScale(1, 1)
									end

									return UDim2.fromScale(0, 1)
								end),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								Image = "",
								AnimationSpeed = 0.2,
								GrowthSize = 1.1,
								ShrinkSize = 0.9,

								OnClick = function()
									SearchTab:set("Favorites")
								end,
								Children = {
									New("TextLabel")({
										Name = "Favorites",
										FontFace = Font.new(
											"rbxasset://fonts/families/SourceSansPro.json",
											Enum.FontWeight.Bold,
											Enum.FontStyle.Normal
										),
										TextSize = 25,
										TextScaled = true,
										TextWrapped = true,
										Text = "Favorites",
										BackgroundColor3 = Color3.fromRGB(255, 255, 255),
										BackgroundTransparency = 1,
										BorderColor3 = Color3.fromRGB(0, 0, 0),
										TextColor3 = Color3.new(0, 0, 0),
										BorderSizePixel = 0,
										Size = UDim2.fromScale(1, 1),
									}),

									New("UIPadding")({
										Name = "UIPadding",
										PaddingBottom = UDim.new(0, 5),
										PaddingLeft = UDim.new(0, 5),
										PaddingRight = UDim.new(0, 5),
										PaddingTop = UDim.new(0, 5),
									}),
								},
							}),
						},
					}),

					ImageButton({
						Active = Active,
						Name = "Clear",
						BackgroundColor3 = Color3.fromRGB(31, 31, 31),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						AnchorPoint = Vector2.new(1, 0.5),
						LayoutOrder = 2,
						Position = UDim2.fromScale(0.99, 0.5),
						Size = UDim2.fromScale(1, 1),
						AspectRatio = 1,
						GrowthSize = 1.1,
						ShrinkSize = 0.9,
						AnimationSpeed = 0.2,
						Image = "",
						BackgroundTransparency = 0,
						OnClick = function()
							Handler_Interface:Set("Pill", "NaN")
							Handler_Interface:Set("SearchBarText", "")
							Handler_Interface:Set("GenreBoxSelected", false)
							Handler_Interface:Set("LibraryResults", {})
						end,

						Visible = Computed(function()
							return not Handler_Interface:Get("SearchEnabled")
						end),

						Children = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("ImageLabel")({
								Name = "Icon",
								Image = "rbxassetid://18925488171",
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.3, 0.3),
							}),
						},
					}),
				},
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 5.38,
				DominantAxis = Enum.DominantAxis.Height,
			}),
		},
	})

	return Tabs
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXac92a286a45245dcb5408dc049573239">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Config</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX0f590790d3fe45889b098fe59afa80d5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InterfaceSettings</string>
						<string name="ScriptGuid">{a11b45c6-2f19-4d00-875b-b573fcb4a14e}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Sunday September 17th 2023 3:58:52 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Monday December 18th 2023 11:51:17 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
local module = {
	AutoActive = "NaN",
	BaseDebug = false,
}

return module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXfcc6484e0f3246d89fb0a1cb1f5c0b15">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InterfaceSignals</string>
						<string name="ScriptGuid">{d1913aaf-9416-4f4b-949f-5969714ca1bb}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Monday September 18th 2023 12:27:53 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Saturday November 25th 2023 11:07:20 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
local Handler_Interface = {
	ToggleAnimation = Instance.new("BindableEvent"),
}

return Handler_Interface]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXe51b514db3e5442c9c6b074038657c61">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">InterfaceStates</string>
						<string name="ScriptGuid">{a20a6150-da46-4338-9194-3655fa9bc014}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Saturday September 23rd 2023 2:04:00 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Saturday September 23rd 2023 2:04:39 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
local Value = Fusion.Value

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX84ff26882d2741bf8fca8f0d6138be7b">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Handlers</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXc637401c1fb947d4afc5706f04d36a99">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Handlers_Interface</string>
						<string name="ScriptGuid">{4b771b06-4a83-4e88-8ec2-7d422f837405}</string>
						<ProtectedString name="Source"><![CDATA[---@diagnostic disable: undefined-type
--[[
--Created Date: Monday November 20th 2023 12:13:34 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday July 12th 2024 10:51:19 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
-- Implementation of Interface.

--// Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")

--// Plugin
local Plugin = script.Parent.Parent.Parent

--// Fusion
local Fusion = require(Plugin.BoomBoxPackages.Fusion)
local Value = Fusion.Value
local Observer = Fusion.Observer

--// Maid
local Maid = require(Plugin.BoomBoxPackages.Maid)

--// Class
local Interface = {}
Interface.__index = Interface

--// Private Function
local function FlattenStates(states, prefix)
	local flatStates = {}
	for key, value in pairs(states) do
		-- Construct a new key using the prefix and the current key
		local newKey = key

		if typeof(value) == "table" and not getmetatable(value) then
			-- If the value is a table and not a Fusion Value object, recursively flatten it
			local nestedStates = FlattenStates(value, newKey)
			for nestedKey, nestedValue in pairs(nestedStates) do
				flatStates[nestedKey] = nestedValue
			end
		else
			-- If the value is not a table or is a Fusion Value object, add it directly
			flatStates[newKey] = value
		end
	end
	return flatStates
end

---
-- @description Constructs a new Interface object.
-- @return Interface - The newly created Interface instance.
--
function Interface.new()
	local Event = function()
		return Instance.new("BindableEvent")
	end

	local Function = function()
		return Instance.new("BindableFunction")
	end

	local info = {
		--// External
		Events = {
			General = {
				ApplyPreset = Event(),
				PlaySound = Event(),
				AddToQueue = Event(),
				ToggleSong = Event(),
				InstaQuery = Event(),
				QueueReorder = Event(),
				ToggleBoombox = Event(),
				ProcessIDSearch = Event(),
				BoomboxEventMediator = Event(),
				ClientAudioscape = Event(),
				LikeEvent = Event(),
				ResizeFrame = Event(),
			},
		},

		--// States
		States = {

			Default = {
				AudioListener = Value(),
				LikesRetrieved = Value(false),
				DraggingEnabled = Value(false),
				DefaultPosition = Value(Vector2.new(1, 0.5)),
				DefaultAccentColor = Value(Color3.new(1, 1, 1)),
			},

			Root = {
				Page = Value("AudioPlayer"),
				DragCache = Value({}),
				Volume = Value(1),
				MaxVolume = Value(1),
				SearchEnabled = Value(false),
				ExcludedStations = Value({}),
				VolumePercent = Value(0.5),
				Fading = Value(false),
				BoomboxVisible = Value(false),
				PlayerListGui = Value(false),
				KeyboardDetected = Value(UserInputService.KeyboardEnabled),
				Viewport = Value(workspace.CurrentCamera.ViewportSize),
				AudioPreset = Value(1),

				ShowFXModal = Value(false),

				Loaded = Value(false),

				QueueTab = Value("Queue"),
				SearchTab = Value("Library"),
				ScreenGui = Value(false),
			},

			Tracking = {
				InteractionTick = Value(0),
			},

			AudioPlayer = {
				Shuffling = Value(false),
				PlayingLiked = Value(false),
			},

			Search = {

				States = {
					Genres = Value({}),
					Emotions = Value({
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
						"Loading",
					}),

					Sound = Value(false),
					AutoPlay = Value(false),
					SoundPlaying = Value(false),

					Length = Value(10),
					AudioPlayer = Value(Instance.new("AudioPlayer")),
					AudioAnalyzer = Value(Instance.new("AudioAnalyzer")),

					Queue = Value({}),
					ShuffledQueue = Value({}),
					GeneratedQueue = Value({}),

					QueueIndex = Value(1),
					QueueMaxLength = Value(40),
					Favorites = Value({}),
					FavoritesDictionary = Value({}),

					Pill = Value("NaN"),
					PillQueries = Value({
						Happy = "Happy",
						Anger = "Anger",
						Sad = "Sad",
						Rad = "Rad",
						Orchestral = "Orchestral",
						Real = "Real",
						Magical = "Magical",
						Emotional = "Emotional",
					}),
					GenreBoxSelected = Value(false),

					Searching = Value(false),
					SearchQuery = Value(""),
					SearchBarText = Value(""),
					LikesSearchBarText = Value(""),

					LibraryResults = Value({}),
					FavoritesResults = Value({}),
				},

				Refs = {
					SearchBoxRef = Value(),
					PillsCanvasRef = Value(),
					LikesSearchBoxRef = Value(),
					SearchResultsCanvasRef = Value(),
					FavoritesResultsCanvasRef = Value(),
				},
			},

			Player = {
				DisableAppearance = Value(false),
				PlayerHidden = Value(false),
				PlayerVisible = Value(true),
				PlayerSide = Value(-1),

				Refs = {
					PlayerRef = Value(),
				},
			},
		},

		--// State Subscriptions
		StateSubscriptions = {},

		--// CleanUp
		_maid = Maid.new(),
	}

	setmetatable(info, Interface):Init()

	return info
end

---
-- @description Removes Layers from self.Event
--
function Interface:CondensedSelf()
	local function RecursiveLoop(A, _Tbl)
		local Tbl = _Tbl or {}
		for i, v in pairs(A) do
			if typeof(v) == "table" and not v["_value"] then
				-- Removed 'return' to allow continuation of the loop
				RecursiveLoop(v, Tbl)
			else
				if Tbl[i] then
					warn(i .. " already exists!")
				end

				Tbl[i] = v
			end
		end
		return Tbl
	end

	self.Events = RecursiveLoop(self.Events, {})
	self.States = FlattenStates(self.States, "")
end

---
-- @description Adds Observers for the States in the Interface.
--
function Interface:InitializeSubscriptionArrays()
	for StateName: string, State in pairs(self.States) do
		local CurrentStateSubscriptionArray = self.StateSubscriptions[StateName]
		self.StateSubscriptions[StateName] = CurrentStateSubscriptionArray or {}
	end
end

---
-- @description Initializes the Interface.
--
function Interface:Init()
	self:CondensedSelf()
	self:InitializeSubscriptionArrays()
	self:ListenToStates()

	-- Players.LocalPlayer.CharacterAdded:Connect(function(Character)
	-- 	self:SetState("Character", Character)
	-- 	workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	-- end)

	-- task.spawn(function()
	-- 	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	-- 	self:SetState("Character", Character)
	-- end)
end

---
-- @description Adds Observers for the States in the Interface.
--
function Interface:ListenToStates()
	-- Adding Observers
	for StateName, State in pairs(self.States) do
		--// LocalStateSubscriptions
		local StateSubscriptions = self.StateSubscriptions[StateName]

		local observer = Observer(State)
		self._maid:GiveTask(observer:onChange(function()
			for _, Callback: () -> nil in pairs(StateSubscriptions) do
				task.defer(Callback, State:get())
			end
		end))
	end
end

---
-- @description Fetches a desired BindableEvent from the Interface.
-- @param SignalName string - The name of the BindableEvent to fetch.
-- @return BindableEvent - The fetched BindableEvent.
--
function Interface:GetEvent(SignalName: string): BindableEvent
	local DesiredSignal: BindableEvent = self.Events[SignalName]
	assert(DesiredSignal, "Bindable Event `" .. SignalName .. "` does not exist")

	return DesiredSignal
end

---
-- @description Fetches a desired State from the Interface.
-- @param StateName string - The name of the State to fetch.
-- @return Fusion.Value<any> - The fetched State.
--

function Interface:GetState(StateName: string)
	local DesiredState = self.States[StateName]
	assert(DesiredState, "State `" .. StateName .. "` does not exist")

	return DesiredState
end

---
-- @description Fetches a desired State value from the Interface.
-- @param StateName string - The name of the State to fetch.
-- @return Fusion.Value<any> - The fetched State.
--
function Interface:Get(StateName: string)
	local DesiredState = self.States[StateName]
	assert(DesiredState, "State `" .. StateName .. "` does not exist")

	return DesiredState:get()
end

---
-- @description Sets a state value in the Interface.
-- @param StateName string - The name of the State to set.
-- @param Value any - The value to set the state to.
--
function Interface:SetState(StateName: string, _Value)
	local DesiredState = self:GetState(StateName)
	DesiredState:set(_Value)
end

---
-- @description Sets a state value in the Interface.
-- @param StateName string - The name of the State to set.
-- @param Value any - The value to set the state to.
--
function Interface:Set(StateName: string, _Value)
	local DesiredState = self:GetState(StateName)
	DesiredState:set(_Value)
end

---
-- @description Hooks an event listener to a desired State.
-- @param StateName string - The name of the State to hook.
-- @param callback function - The function to execute when the event is triggered.
--
function Interface:SubscribeToState(State: string, callback: () -> nil)
	local DesiredState = self:GetState(State)
	local StateSubscriptions = self.StateSubscriptions[State] or {}

	table.insert(StateSubscriptions, callback)
end

---
-- @description Hooks an event listener to a desired BindableEvent.
-- @param SignalName string - The name of the BindableEvent to hook.
-- @param callback function - The function to execute when the event is triggered.
--
function Interface:Subscribe(SignalName: string, callback: (...any) -> any)
	local DesiredSignal: BindableEvent | BindableFunction = self:GetEvent(SignalName)

	if DesiredSignal.ClassName == "BindableEvent" then
		-- For BindableEvent, connect the event to the callback
		self._maid:GiveTask(DesiredSignal.Event:Connect(callback))
	elseif DesiredSignal.ClassName == "BindableFunction" then
		-- For BindableFunction, set the OnInvoke to the callback
		DesiredSignal.OnInvoke = function(...)
			return callback(...)
		end
	else
		warn("Unsupported signal type for subscription: " .. DesiredSignal.ClassName)
	end
end

---
-- @description Fires a BindableEvent with the provided arguments.
-- @param SignalName string - The name of the BindableEvent to fire.
-- @param ... any - The arguments to pass when firing the event.
--
function Interface:Fire(SignalName: string, ...)
	local DesiredSignal: BindableEvent | BindableFunction = self:GetEvent(SignalName)
	local IsBindableFunction = DesiredSignal:IsA("BindableFunction")
	local Tuple = { ... }

	if not IsBindableFunction then
		DesiredSignal:Fire(...)
	else
		-- If it is a BindableFunction, invoke it and yield until it returns
		local result
		local success, err = pcall(function()
			result = DesiredSignal:Invoke(table.unpack({ Tuple }))
		end)

		if not success then
			warn("Error invoking BindableFunction '" .. SignalName .. "': " .. tostring(err))
			return false
		end

		return result
	end
end

---
-- @description Cleans up all tasks and listeners associated with the Interface.
--
function Interface:DoCleaning()
	self._maid:Cleanup()
end

return Interface.new()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX3e218d197bed4056b3fd39176b310e39">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Pages</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX8ff04a2465fa4d5ea000a96a00402f06">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioPlayer</string>
						<string name="ScriptGuid">{0277a7d4-66cf-4d3a-9d08-4f4d8d252d35}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Draggable = require(Util.Draggable)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "AudioPlayer",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.AudioPlayer

local FXModal = require(Interface.Pages.FXModal)

local Playing = require(LocalComponents.Playing)
local TimeBar = require(LocalComponents.TimeBar)
local Buttons = require(LocalComponents.Buttons)
local AudioControls = require(LocalComponents.AudioControls)

local AudioScapeButton = require(LocalComponents.AudioscapeButton)
local AudioControlsVertical = require(LocalComponents.AudioControlsVertical)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type AudioPlayerProps = {}

return function(props: AudioPlayerProps)
	--// Value States
	local Active = Value(false)
	local Visible = Value(true)

	local PlayerRef = Handler_Interface:GetState("PlayerRef")

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	--// Debugging
	if Interface_Settings.AutoActive == Settings.Page then
		task.delay(0, function()
			Active:set(true)
		end)
	end

	local AudioPlayer = New("Frame")({
		[Ref] = PlayerRef,
		Name = "AudioPlayer",
		BackgroundColor3 = Color3.fromRGB(17, 17, 17),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		AnchorPoint = Computed(function()
			local DefaultPosition = Handler_Interface:Get("DefaultPosition") :: Vector2
			local Confined = Vector2.new(math.clamp(DefaultPosition.X, 0, 1), math.clamp(DefaultPosition.Y, 0, 1))

			return Confined
		end),
		Position = Computed(function()
			local DefaultPosition = Handler_Interface:Get("DefaultPosition") :: Vector2
			local Confined = Vector2.new(math.clamp(DefaultPosition.X, 0, 1), math.clamp(DefaultPosition.Y, 0, 1))

			return UDim2.fromScale(Confined.X, Confined.Y)
		end),
		Size = UDim2.new(0, 275, 0, 120),
		ClipsDescendants = false,

		[Children] = {
			Computed(function()
				local ShowFXModal = Handler_Interface:Get("ShowFXModal")
				if ShowFXModal then
					return FXModal({})
				end

				return {}
			end, function() end),

			New("Frame")({
				Name = "AudioPlayer",
				BackgroundColor3 = Color3.fromRGB(17, 17, 17),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				AnchorPoint = Vector2.new(1, 0.5),
				Position = UDim2.fromScale(1, 0.5),
				BackgroundTransparency = 0,
				Size = Tween(
					Computed(function()
						return Handler_Interface:Get("PlayerVisible") and UDim2.new(1, 0, 1, 0) or UDim2.new(0, 0, 1, 0)
					end),
					Tweens.Fast
				),

				[Children] = {
					Buttons({}),
					Playing({}),
					TimeBar({}),
					AudioControls({}),
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("UIPadding")({
						Name = "UIPadding",
						PaddingBottom = UDim.new(0, 5),
						PaddingLeft = UDim.new(0, 5),
						PaddingRight = UDim.new(0, 5),
						PaddingTop = UDim.new(0, 5),
					}),
				},
			}),

			New("ImageButton")({
				Name = "SideBar",
				BackgroundColor3 = Color3.fromRGB(17, 17, 17),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				Position = Tween(
					Computed(function()
						local DesiredSize = Handler_Interface:Get("PlayerVisible") and UDim2.fromScale(0, 0.5)
							or UDim2.fromScale(1, 0.5)

						return DesiredSize
					end),
					Tweens.Fast
				),
				AnchorPoint = Tween(
					Computed(function()
						local DesiredSize = Handler_Interface:Get("PlayerVisible") and Vector2.new(1, 0.5)
							or Vector2.new(1, 0.5)

						return DesiredSize
					end),
					Tweens.Fast
				),
				Size = Tween(
					Computed(function()
						local DesiredSize = Handler_Interface:Get("PlayerVisible") and UDim2.new(0, 20, 0.9, 0)
							or UDim2.new(0, 30, 1, 0)

						-- Handler_Interface:Fire("ResizeFrame", DesiredSize)

						return DesiredSize
					end),
					Tweens.Fast
				),

				-- Visible = Computed(function()
				-- 	return Handler_Interface:Get("PlayerVisible")
				-- end),

				[Children] = {
					New("UIDragDetector")({
						BoundingUI = PlayerRef:get(),
					}),
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					Computed(function()
						local PlayerVisible = Handler_Interface:Get("PlayerVisible")
						if PlayerVisible then
							return New("ImageButton")({
								ZIndex = Computed(function()
									return PlayerVisible and 2 or -4
								end),
								Size = UDim2.fromScale(1, 1),
								BackgroundTransparency = 1,
								[OnEvent("MouseButton1Click")] = function()
									Handler_Interface:Set("PlayerVisible", false)
									Handler_Interface:Set("PlayerHidden", true)
								end,
								[Children] = {
									New("ImageLabel")({
										Size = UDim2.fromScale(0.8, 0.8),
										Position = UDim2.fromScale(0.5, 0.5),
										AnchorPoint = Vector2.new(0.5, 0.5),
										-- Rotation = 180,
										-- Rotation = 180,
										BackgroundTransparency = 1,
										-- Image = "rbxassetid://18925477687",
										Image = "rbxassetid://485495665",
										[Children] = {
											New("UIAspectRatioConstraint")({
												AspectRatio = 1,
											}),
										},
									}),
								},
							})
						end

						return {}
					end, function() end),

					-- AudioScapeButton({}),
					AudioControlsVertical({}),
				},
			}),
		},
	})

	return AudioPlayer
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX222e1550975641119ca518fdeacde542">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FXModal</string>
						<string name="ScriptGuid">{9901f264-d142-41b4-9487-267200b5c812}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Luminance = require(Util.Luminance)
local MatteColor = require(Util.MatteColor)
local PastelColor = require(Util.PastelColor)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "FXModal",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
-- local LocalComponents = Components.Pages

local ImageButton = require(BaseComponents.ImageButton)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

local function Buttons()
	local Active = Value(true)
	return New("Frame")({
		Name = "Buttons",
		BackgroundColor3 = Color3.fromRGB(31, 31, 31),
		BackgroundTransparency = 1,
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		LayoutOrder = 2,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.fromScale(0.5, 0.5),
		Size = UDim2.fromScale(1, 0.25),

		[Children] = {

			ImageButton({
				Active = Active,
				Name = "FX",
				BackgroundTransparency = 0,
				BackgroundColor3 = Color3.fromRGB(255, 31, 31),
				BorderColor3 = Color3.fromRGB(0, 0, 0),
				BorderSizePixel = 0,
				LayoutOrder = 1,
				Position = UDim2.fromScale(0.873, 0.06),
				Size = UDim2.fromScale(0.556, 1.11),
				Image = "",
				GrowthSize = 1.1,
				ShrinkSize = 0.9,
				AnimationSpeed = 0.1,

				OnClick = function()
					Handler_Interface:Set("ShowFXModal", false)
					-- Handler_Interface:Set("AudioPreset", 1)
					-- Handler_Interface:Fire("ApplyPreset", "AudioFader", 1)
					-- Handler_Interface:Fire("ApplyPreset", "AudioPlayer", 1)
					-- Handler_Interface:Fire("ApplyPreset", "AudioReverb", 1)
				end,

				Children = {
					New("UICorner")({
						Name = "UICorner",
						CornerRadius = UDim.new(0, 5),
					}),

					New("TextLabel")({
						Name = "Icon",
						Text = "X",
						FontFace = Font.new(
							"rbxasset://fonts/families/SourceSansPro.json",
							Enum.FontWeight.Bold,
							Enum.FontStyle.Normal
						),
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = Color3.fromRGB(255, 255, 255),
						BackgroundTransparency = 1,
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(0.55, 0.55),
						TextScaled = true,
						TextColor3 = Color3.new(1, 1, 1),
					}),

					New("UIAspectRatioConstraint")({
						Name = "UIAspectRatioConstraint",
					}),
				},
			}),

			Computed(function()
				local Temp = {}
				for i = 1, 4 do
					local StationGradients = {
						MatteColor(),
						MatteColor(),
						-- PastelColor(),
						-- PastelColor(),
					}

					Temp[i] = ImageButton({
						Active = Active,
						Name = "FX",
						BackgroundTransparency = 0,
						BackgroundColor3 = Computed(function()
							local Preset = Handler_Interface:Get("AudioPreset")
							if Handler_Interface:Get("AudioPreset") == i + 1 then
								return Color3.fromRGB(220, 220, 31)
							end

							return Color3.fromRGB(31, 31, 31)
						end),
						BorderColor3 = Color3.fromRGB(0, 0, 0),
						BorderSizePixel = 0,
						LayoutOrder = i + 1,
						Position = UDim2.fromScale(0.873, 0.06),
						Size = UDim2.fromScale(0.556, 1.11),
						Image = "",
						GrowthSize = 1.1,
						ShrinkSize = 0.9,
						AnimationSpeed = 0.1,

						OnClick = function()
							-- Handler_Interface:Set("ShowFXModal", false)
							local LocalPreset = i + 1
							local ActivePreset = Handler_Interface:Get("AudioPreset")

							if LocalPreset == ActivePreset then
								Handler_Interface:Set("AudioPreset", 1)
								Handler_Interface:Fire("ApplyPreset", "AudioFader", 1)
								Handler_Interface:Fire("ApplyPreset", "AudioPlayer", 1)
								Handler_Interface:Fire("ApplyPreset", "AudioReverb", 1)
								return
							end

							Handler_Interface:Set("AudioPreset", LocalPreset)
							Handler_Interface:Fire("ApplyPreset", "AudioFader", LocalPreset)
							Handler_Interface:Fire("ApplyPreset", "AudioPlayer", LocalPreset)
							Handler_Interface:Fire("ApplyPreset", "AudioReverb", LocalPreset)
						end,

						Children = {
							New("UICorner")({
								Name = "UICorner",
								CornerRadius = UDim.new(0, 5),
							}),

							New("TextLabel")({
								Name = "Icon",
								Text = "FX" .. i,
								FontFace = Font.new(
									"rbxasset://fonts/families/SourceSansPro.json",
									Enum.FontWeight.Bold,
									Enum.FontStyle.Normal
								),
								AnchorPoint = Vector2.new(0.5, 0.5),
								BackgroundColor3 = Color3.fromRGB(255, 255, 255),
								BackgroundTransparency = 1,
								BorderColor3 = Color3.fromRGB(0, 0, 0),
								BorderSizePixel = 0,
								Position = UDim2.fromScale(0.5, 0.5),
								Size = UDim2.fromScale(0.55, 0.55),
								TextScaled = true,
								TextColor3 = Computed(function()
									local Preset = Handler_Interface:Get("AudioPreset")
									if Preset == i + 1 then
										return Color3.new(1, 1, 1) --Luminance(StationGradients[1], 0)
									end

									return Color3.new(1, 1, 1)
								end),
							}),

							New("UIAspectRatioConstraint")({
								Name = "UIAspectRatioConstraint",
							}),

							Computed(function()
								local Preset = Handler_Interface:Get("AudioPreset")
								if Handler_Interface:Get("AudioPreset") == i + 1 then
									return New("UIGradient")({
										Name = "UIGradient",
										Color = ColorSequence.new({
											ColorSequenceKeypoint.new(0, StationGradients[1]),
											ColorSequenceKeypoint.new(1, StationGradients[2]),
										}),
										Rotation = 45,
									})
								end

								return {}
							end, function() end),
						},
					})
				end

				return Temp
			end, function() end),

			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0, 5),
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			New("UIAspectRatioConstraint")({
				Name = "UIAspectRatioConstraint",
				AspectRatio = 2,
			}),
		},
	})
end

type FxModalProps = {}

return function(props: FxModalProps)
	--// Value States
	local Active = Value(false)

	local FxModal = New("ImageButton")({
		BackgroundTransparency = 0.5,
		Size = UDim2.fromScale(1, 1),
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.fromScale(0.5, 0.5),
		BackgroundColor3 = Color3.new(0, 0, 0),
		[OnEvent("MouseButton1Click")] = function()
			Handler_Interface:Set("ShowFXModal", false)
		end,

		[Children] = {
			Buttons(),
		},
	})

	return FxModal
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXee2115e9a43a4f119ace7b1ffa6a6bce">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Queue</string>
						<string name="ScriptGuid">{4443f96c-c4b5-4642-9967-1c3308320b72}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Queue",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Queue

local Tabs = require(LocalComponents.Tabs)
local Favorites = require(LocalComponents.Favorites)
local SearchBar = require(LocalComponents.SearchBar)
local QueueHeader = require(LocalComponents.QueueHeader)
local QueueContainer = require(LocalComponents.QueueContainer)
local PillsContainer = require(LocalComponents.PillsContainer)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type QueueProps = {}

return function(props: QueueProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	local Queue = New("Frame")({
		Name = "Queue",
		BackgroundColor3 = Color3.fromRGB(17, 17, 17),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.692, -0.0013),
		Size = UDim2.fromScale(0.308, 1),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),
			Tabs({}),

			Computed(function()
				if Handler_Interface:Get("QueueTab") == "Queue" then
					return {
						QueueHeader({}),
						QueueContainer({}),
					}
				else
					return {
						SearchBar({}),
						Favorites({}),
						PillsContainer({}),
					}
				end
			end, function() end),
		},
	})

	return Queue
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX7e5662d8dd774444881ab415661016da">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Root</string>
						<string name="ScriptGuid">{b7766d55-5c4a-4c2b-bd18-bad5c956c78d}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)
local Screen = require(Util.Screen)
local Instween = require(Util.Instween)
local Viewport = require(Util.Viewport)
local Draggable = require(Util.Draggable)
local AudioPlayerSider = require(Util.AudioPlayerSider)

--// Types
local Types_Song = require(Interface.Types.Sound)

--// Packages
local Packages = script.Parent.Parent.Parent.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)

--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Hydrate = Fusion.Hydrate
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Root",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local PagesFolder = script.Parent
local Components = Interface.Components

local Queue = require(PagesFolder.Queue)
local Search = require(PagesFolder.Search)
local AudioPlayer = require(PagesFolder.AudioPlayer)

local Pages = {
	Queue = Queue(),
	Search = Search(),
	AudioPlayer = AudioPlayer(),
}

local BasePageInfo = {}
local DraggablePages = {
	AudioPlayer = true,
}

for PageName, Page: Frame in pairs(Pages) do
	BasePageInfo[PageName] = {
		Size = Page.Size,
		Position = Page.Position,
		AnchorPoint = Page.AnchorPoint,
		BackgroundTransparency = Page.BackgroundTransparency,
	}
end

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type RootProps = {}

return function(props: RootProps)
	local AudioAssembly = require(Players.LocalPlayer.PlayerGui.BoomBoxClient.Modules.AudioAssembly)

	--// Value States
	local Page = Value(Pages[Handler_Interface:Get("Page")])
	local PageName = Value(Handler_Interface:Get("Page"))
	local SpinnerRef = Value()

	local DragCache = {}

	local PlayerListEnabled = StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.PlayerList)
	Handler_Interface:Set("PlayerListGui", PlayerListEnabled)

	local FirstAssignment = true
	local LastOnScreenPosition = UDim2.fromScale(0.5, 0.5)

	Handler_Interface:SubscribeToState("PlayerListGui", function(Enabled: boolean)
		if Enabled then
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, PlayerListEnabled)
		else
			PlayerListEnabled = StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.PlayerList)
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
		end
	end)

	Viewport(function(ViewportSize: Vector2)
		Handler_Interface:Set("Viewport", ViewportSize)
	end)

	if RunService:IsRunning() then
		local Sound = Handler_Interface:Get("AudioPlayer") :: AudioPlayer
		Sound.Parent = Players.LocalPlayer.PlayerGui

		local function Connections(CurrentSound: AudioPlayer)
			local ConnectionsCreated = {}

			ConnectionsCreated["Played"] = CurrentSound:GetPropertyChangedSignal("IsPlaying"):Connect(function()
				Handler_Interface:Set("SoundPlaying", CurrentSound.IsPlaying)
			end)

			ConnectionsCreated["Ended"] = CurrentSound.Ended:Connect(function()
				if CurrentSound == Handler_Interface:Get("AudioPlayer") then
					Handler_Interface:Fire("ToggleSong", 1)
				end
			end)

			ConnectionsCreated["Destroying"] = CurrentSound.Destroying:Connect(function()
				for _, Connection in pairs(ConnectionsCreated) do
					Connection:Disconnect()
				end
			end)
		end

		Connections(Sound)

		Hydrate(Sound)({
			Volume = Computed(function()
				return Handler_Interface:Get("Volume")
			end),
		})

		--// Crossfading logic within the Sound state subscription
		Handler_Interface:SubscribeToState("Sound", function(Song: Types_Song.ReadableDictionary)
			Sound = Handler_Interface:Get("AudioPlayer") :: AudioPlayer

			if not Song or not Song.asset_id then
				return
			end

			-- If there is a current sound and Song.Fade exists, perform crossfade
			if Sound.IsPlaying and Song.Fade and not Song.Faded then
				Song.Faded = true

				local FadeOutTween = Instween.new(
					Sound,
					{
						Volume = 0,
					},
					Song.Fade, -- Use the Fade value from the Song
					{
						EasingStyle = Enum.EasingStyle.Linear,
						EasingDirection = Enum.EasingDirection.Out,
					}
				)

				FadeOutTween.Completed:Once(function()
					Sound:Stop()
					Sound:Destroy()
				end)

				FadeOutTween:Play()
			else
				Sound:Stop()
				Sound:Destroy()
			end

			-- Create and configure the new sound
			local NewSound =
				AudioAssembly.CreateLayers({ "AudioPitchShifter", "AudioFader", "AudioReverb", "AudioEqualizer" })
			NewSound.Name = "AudioscapeBoomBox"
			NewSound.AssetId = "rbxassetid://" .. Song.asset_id

			if not Handler_Interface:Get("BoomboxVisible") then
				NewSound.Volume = Song.Fade and 0 or Handler_Interface:Get("Volume") :: number -- Start at 0 for fade in, or full volume if no fade.Volume = ClickedPercent * Handler_Interface:Get("MaxVolume")
			else
				NewSound.Volume = 0
			end

			NewSound.Parent = Players.LocalPlayer.PlayerGui
			Connections(NewSound)
			Handler_Interface:Set("AudioPlayer", NewSound)

			-- Load the new sound and handle playback
			if not NewSound.IsReady then
				NewSound:GetPropertyChangedSignal("IsReady"):Wait()
			end

			Handler_Interface:Set("Length", NewSound.TimeLength)

			if Handler_Interface:Get("AutoPlay") then
				NewSound:Play()
			end

			-- If Song.Fade exists, fade in the new sound
			if Song.Fade then
				local FadeInTween = Instween.new(
					NewSound,
					{
						Volume = Handler_Interface:Get("Volume") :: number,
					},
					Song.Fade, -- Use the Fade value from the Song
					{
						EasingStyle = Enum.EasingStyle.Linear,
						EasingDirection = Enum.EasingDirection.Out,
					}
				)

				FadeInTween.Completed:Once(function()
					FadeInTween:Destroy()
					Handler_Interface:Set("Fading", false)
				end)

				FadeInTween:Play()
				Handler_Interface:Set("Fading", true)
			end

			Song.Fade = nil
		end)

		Handler_Interface:SubscribeToState("Favorites", function(Favorites: { [string]: Types_Song.ReadableDictionary })
			local Song = Handler_Interface:Get("Sound") :: Types_Song.ReadableDictionary

			if not Song then
				return
			end

			Handler_Interface:Set("PlayingLiked", Favorites[tostring(Song.asset_id)] and true or false)
		end)
	end

	local Root = New("ImageButton")({
		Visible = Computed(function()
			if Handler_Interface:Get("DisableAppearance") then
				return false
			end

			return Handler_Interface:Get("Loaded")
		end),
		Active = Computed(function()
			return Handler_Interface:Get("PlayerVisible")
		end),
		Size = Computed(function()
			local CurrentPageName = PageName:get() :: string
			local CurrentViewport = Handler_Interface:Get("Viewport") :: Vector2

			if CurrentPageName ~= "AudioPlayer" and CurrentViewport.X < CurrentViewport.Y then
				return UDim2.fromScale(0.5, 1)
			end

			return BasePageInfo[PageName:get()].Size
		end),
		Position = Computed(function()
			local DragCachePosition = DragCache[PageName:get()]
			local CurrentViewport = Handler_Interface:Get("Viewport") :: Vector2

			if DragCachePosition then
				return DragCachePosition
			end

			if FirstAssignment and PageName:get() == "AudioPlayer" then
				FirstAssignment = false
				return BasePageInfo[PageName:get()].Position
			end

			if PageName:get() ~= "AudioPlayer" and CurrentViewport.X < CurrentViewport.Y then
				return UDim2.fromScale(1, 0.5)
			end

			return BasePageInfo[PageName:get()].Position
		end),
		AnchorPoint = Computed(function()
			if PageName:get() == "AudioPlayer" then
				return BasePageInfo[PageName:get()].AnchorPoint
			else
				local CurrentViewport = Handler_Interface:Get("Viewport") :: Vector2

				if CurrentViewport.X < CurrentViewport.Y then
					return Vector2.new(1, 0.5)
				end
			end

			return Vector2.new(0, 0)
		end),
		BackgroundTransparency = 1,

		[Children] = {
			Computed(function()
				local PageElement = Page:get()
				PageElement.Position = UDim2.fromScale(0, 0)
				PageElement.Size = UDim2.fromScale(1, 1)

				if PageName:get() == "AudioPlayer" then
					PageElement.Position = UDim2.fromScale(0, 0)
					PageElement.AnchorPoint = Vector2.new(0, 0)
				end
				return PageElement
			end, function() end),
		},
	}) :: Frame

	--// Handling Dragging

	local Drag

	if Handler_Interface:Get("DraggingEnabled") then
		Drag = Draggable.new(Root, function(Position: UDim2)
			local ScreenSize = Screen()
			local CurrentPageName = PageName:get()

			DragCache[CurrentPageName] = Position

			local DesiredSize = Handler_Interface:Get("PlayerVisible") and 10 or 30

			if
				Root.AbsolutePosition.X - DesiredSize > 0
				and Root.AbsolutePosition.X + Root.AbsoluteSize.X < ScreenSize.width
				and Root.AbsolutePosition.Y > 0
				and Root.AbsolutePosition.Y + (Root.AbsoluteSize.Y * 1.5) < ScreenSize.height
			then
				LastOnScreenPosition = Position
			else
				Root.Position = LastOnScreenPosition
			end
		end)
		Drag:Enable()
	end

	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Page:set(Pages[NewPage])
		PageName:set(NewPage)

		if Handler_Interface:Get("DraggingEnabled") then
			if DraggablePages[NewPage] then
				Drag:Enable()
			else
				Drag:Disable()
			end
		end

		if NewPage == "Search" or NewPage == "Queue" then
			Handler_Interface:Set("PlayerListGui", false)
		else
			Handler_Interface:Set("PlayerListGui", true)
		end
	end)

	Handler_Interface:Subscribe("ResizeFrame", function(NewSize: UDim2)
		Root.Size = NewSize
	end)

	-- AudioPlayerSider(Root, Pages.AudioPlayer, PlayerAnchorPointCache)

	return Root
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX014cc72b9d704a54a1a13c4139054ac7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Search</string>
						<string name="ScriptGuid">{db25acf5-4efa-4afc-b247-d50da3adc47d}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)
local Interface_Settings = require(Interface.Config.InterfaceSettings)

--// Util
local Util = Interface.Util
local Tweens = require(Util.Tweens)
local Sounds = require(Util.Sounds)
local Images = require(Util.Images)

--// Packages
local Packages = ReplicatedStorage.BoomBoxPackages

--// Fusion
local Fusion = require(Packages.Fusion)
--// Fusion Imports
local New = Fusion.New
local Ref = Fusion.Ref
local Out = Fusion.Out
local Value = Fusion.Value
local Tween = Fusion.Tween
local OnEvent = Fusion.OnEvent
local Cleanup = Fusion.Cleanup
local Computed = Fusion.Computed
local Observer = Fusion.Observer
local Children = Fusion.Children

--// Configuration
local Settings = {
	Debug = true,
	Page = "Search",
}

--------------------------------------------------------------------------------
--// Child Components //--
--------------------------------------------------------------------------------
local Components = Interface.Components
local BaseComponents = Components.Base
local LocalComponents = Components.Search

local Tabs = require(LocalComponents.Tabs)
local SearchBar = require(LocalComponents.SearchBar)
local GenreBoxes = require(LocalComponents.GenreBoxes)
local SearchResults = require(LocalComponents.SearchResults)
local PillsContainer = require(LocalComponents.PillsContainer)
local SearchingFrame = require(LocalComponents.SearchingFrame)

--------------------------------------------------------------------------------
--// Main Component //--
--------------------------------------------------------------------------------

type SearchProps = {}

return function(props: SearchProps)
	--// Value States
	local Active = Value(false)

	--// Signals
	Handler_Interface:SubscribeToState("Page", function(NewPage: string)
		Active:set(NewPage == Settings.Page)
	end)

	local Search = New("Frame")({
		Name = "Search",
		BackgroundColor3 = Color3.fromRGB(17, 17, 17),
		BorderColor3 = Color3.fromRGB(0, 0, 0),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.692, -0.0013),
		Size = UDim2.fromScale(0.308, 1),

		[Children] = {
			New("UIListLayout")({
				Name = "UIListLayout",
				Padding = UDim.new(0.01, 0),
				HorizontalAlignment = Enum.HorizontalAlignment.Center,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),

			Tabs({}),
			SearchBar({}),
			GenreBoxes({}),
			SearchResults({}),
			PillsContainer({}),

			Computed(function()
				if Handler_Interface:Get("Searching") then
					return SearchingFrame({})
				end
			end, function(Child)
				return Child and Child or nil
			end),
		},
	})

	return Search
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX24de806fef7245d9b88fb142bd7b3b83">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Stories</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX141caf79ce7b4f9c8ad5b7a98287a0d8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioPlayer.story</string>
						<string name="ScriptGuid">{e931d8a2-6cde-419e-8db5-2d6d09d123fe}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:59:22 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Monday September 25th 2023 10:39:56 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ServerScriptService = game:GetService("ServerScriptService")

--// Pages
local Components = ServerScriptService.AudioscapeBoomBox.Interface.Components
local Pages = ServerScriptService.AudioscapeBoomBox.Interface.Pages

local RootFrame = require(Pages.AudioPlayer)({})

return function(target: Frame)
	RootFrame.Parent = target

	return function()
		RootFrame:Destroy()
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXa7d1da44f80648d78991ecf4670774ea">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Queue.story</string>
						<string name="ScriptGuid">{6844fa89-dfe9-4a03-9d44-dd8c6f28a461}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:59:22 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Monday September 25th 2023 10:39:56 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ServerScriptService = game:GetService("ServerScriptService")

--// Pages
local Components = ServerScriptService.AudioscapeBoomBox.Interface.Components
local Pages = ServerScriptService.AudioscapeBoomBox.Interface.Pages

local RootFrame = require(Pages.Queue)({})

return function(target: Frame)
	RootFrame.Parent = target

	return function()
		RootFrame:Destroy()
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX83119db5fe40481b834f008b4ded31da">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Root.story</string>
						<string name="ScriptGuid">{f5d93652-2d71-46be-ace9-717c26143e8b}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:59:22 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Monday September 25th 2023 10:39:56 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ServerScriptService = game:GetService("ServerScriptService")

--// Pages
local Components = ServerScriptService.AudioscapeBoomBox.Interface.Components
local Pages = ServerScriptService.AudioscapeBoomBox.Interface.Pages

local RootFrame = require(Pages.Root)({})

return function(target: Frame)
	RootFrame.Parent = target

	return function()
		RootFrame:Destroy()
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXa378132ae9854925b5001b4cfaa033d8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Search.story</string>
						<string name="ScriptGuid">{b55d83d8-1381-40e3-896f-986e1a759811}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:59:22 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Monday September 25th 2023 10:39:56 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--// Services
local ServerScriptService = game:GetService("ServerScriptService")

--// Pages
local Components = ServerScriptService.AudioscapeBoomBox.Interface.Components
local Pages = ServerScriptService.AudioscapeBoomBox.Interface.Pages

local RootFrame = require(Pages.Search)({})

return function(target: Frame)
	RootFrame.Parent = target

	return function()
		RootFrame:Destroy()
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX7f49d6b1de0f41e5b1cbaa987e78add6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Types</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX8e591b2ed26849ef9ea6beb5ba1530ae">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Sound</string>
						<string name="ScriptGuid">{a5820014-1d78-4f87-9fac-6fd3aa89b5dd}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Wednesday July 10th 2024 1:12:53 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Wednesday July 10th 2024 1:13:01 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
export type ReadableDictionary = {
	asset_audio_details_artist: string,
	asset_audio_details_music_album: string,
	asset_audio_details_music_genre: string,
	asset_audio_details_sound_effect_category: string | nil,
	asset_audio_details_sound_effect_subcategory: string | nil,
	asset_audio_details_tags: string,
	asset_created_utc: string,
	asset_description: string,
	asset_duration: string,
	asset_id: string,
	asset_name: string,
	asset_updated_utc: string,
	creator_id: string,
	creator_is_verified_creator: boolean,
	creator_name: string,
	asset_bpm: number | nil,
	asset_first_beat_offset: number | nil,
	asset_first_downbeat: number | nil,
}

return {}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXcc1c50d5b2e3432daf0f97adb4116c59">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Util</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX98ac8138ed604fca820c1d2aa3430382">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">AudioPlayerSider</string>
						<string name="ScriptGuid">{9c27977e-700c-41c1-abf6-a1069478dceb}</string>
						<ProtectedString name="Source"><![CDATA[--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--// Interface
local Interface = ReplicatedStorage.Interface
local Handler_Interface = require(Interface.Handlers.Handlers_Interface)

--// Dependencies
local ScreenSize = require(script.Parent.Screen)()

return function(Root: Frame, Frame: Frame, PlayerAnchorPointCache)
	local PlayerRef = Handler_Interface:Get("PlayerRef") :: Frame

	if not PlayerRef then
		return
	end

	local PlayerSize = PlayerRef.AbsoluteSize
	local PlayerPosition = PlayerRef.AbsolutePosition

	if Handler_Interface:Get("PlayerSide") == 1 then
		if PlayerPosition.X + PlayerSize.X > ScreenSize.width then
			Handler_Interface:Set("PlayerSide", -1)
			Frame.Position = UDim2.fromScale(1, 0)
			Frame.AnchorPoint = Vector2.new(1, 0)
			Root.AnchorPoint = Vector2.new(1, 0)
			PlayerAnchorPointCache:set(Root.AnchorPoint)
		end
	else
		if PlayerPosition.X < 0 then
			Handler_Interface:Set("PlayerSide", 1)
			Frame.Position = UDim2.fromScale(0, 0)
			Frame.AnchorPoint = Vector2.new(0, 0)
			Root.AnchorPoint = Vector2.new(0, 0)
			PlayerAnchorPointCache:set(Root.AnchorPoint)
		end
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX8e395787a2614612b3b917e9c668574c">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Camera</string>
						<string name="ScriptGuid">{01b1ee29-832a-4a70-80d5-dace7dad29a9}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Tuesday October 17th 2023 1:38:00 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Thursday April 4th 2024 1:04:39 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
-- Implementation of Camera.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Module
local Camera = {}

function Camera.getCameraOffset(fov, extentsSize)
	local halfSize = extentsSize.Magnitude / 2
	local fovDivisor = math.tan(math.rad(fov / 2))
	return halfSize / fovDivisor
end

function Camera.zoomToExtents(camera, instance)
	local isModel = instance:IsA("Model")

	local instanceCFrame = isModel and instance:GetModelCFrame() or instance.CFrame
	local extentsSize = isModel and instance:GetExtentsSize() or instance.Size

	local cameraOffset = Camera.getCameraOffset(camera.FieldOfView, extentsSize)
	local cameraRotation = camera.CFrame - camera.CFrame.p

	local instancePosition = instanceCFrame.p
	camera.CFrame = cameraRotation + instancePosition + (-cameraRotation.LookVector * cameraOffset)
	camera.Focus = cameraRotation + instancePosition
end

return Camera]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9309acfd978045dd8bccd8d4b5958869">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Capitalize</string>
						<string name="ScriptGuid">{023c81d8-e2b8-4cc9-b7c4-80b57d2b9343}</string>
						<ProtectedString name="Source"><![CDATA[return function(str)
	local finalized = str:gsub("(%a)([%w_']*)", function(firstLetter, restOfWord)
		return firstLetter:upper() .. restOfWord:lower()
	end)

	return finalized
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX399d6129fdfc4f5f90069069eb167381">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Draggable</string>
						<string name="ScriptGuid">{bfc2997c-8e48-4814-8d62-a424cd0431ea}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	@Author: Spynaz
	@Description: Enables dragging on GuiObjects. Supports both mouse and touch.
	
	For instructions on how to use this module, go to this link:
	https://devforum.roblox.com/t/simple-module-for-creating-draggable-gui-elements/230678
--]]

local UDim2_new = UDim2.new

local UserInputService = game:GetService("UserInputService")

local DraggableObject = {}
DraggableObject.__index = DraggableObject

-- Sets up a new draggable object
function DraggableObject.new(Object, CallBack)
	local self = {}
	self.Object = Object
	self.DragStarted = nil
	self.DragEnded = nil
	self.Dragged = nil
	self.Dragging = false
	self.CallBack = CallBack

	setmetatable(self, DraggableObject)

	return self
end

-- Enables dragging
function DraggableObject:Enable()
	local object = self.Object
	local dragInput = nil
	local dragStart = nil
	local startPos = nil
	local preparingToDrag = false

	-- Updates the element
	local function update(input)
		local delta = input.Position - dragStart
		local newPosition =
			UDim2_new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		object.Position = newPosition

		self.CallBack(newPosition)

		return newPosition
	end

	self.InputBegan = object.InputBegan:Connect(function(input)
		if
			input.UserInputType == Enum.UserInputType.MouseButton1
			or input.UserInputType == Enum.UserInputType.Touch
		then
			preparingToDrag = true
			--[[if self.DragStarted then
				self.DragStarted()
			end
			
			dragging	 	= true
			dragStart 		= input.Position
			startPos 		= Element.Position
			--]]

			local connection
			connection = input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End and (self.Dragging or preparingToDrag) then
					self.Dragging = false
					connection:Disconnect()

					if self.DragEnded and not preparingToDrag then
						self.DragEnded()
					end

					preparingToDrag = false
				end
			end)
		end
	end)

	self.InputChanged = object.InputChanged:Connect(function(input)
		if
			input.UserInputType == Enum.UserInputType.MouseMovement
			or input.UserInputType == Enum.UserInputType.Touch
		then
			dragInput = input
		end
	end)

	self.InputChanged2 = UserInputService.InputChanged:Connect(function(input)
		if object.Parent == nil then
			self:Disable()
			return
		end

		if preparingToDrag then
			preparingToDrag = false

			if self.DragStarted then
				self.DragStarted()
			end

			self.Dragging = true
			dragStart = input.Position
			startPos = object.Position
		end

		if input == dragInput and self.Dragging then
			local newPosition = update(input)

			if self.Dragged then
				self.Dragged(newPosition)
			end
		end
	end)
end

-- Disables dragging
function DraggableObject:Disable()
	self.InputBegan:Disconnect()
	self.InputChanged:Disconnect()
	self.InputChanged2:Disconnect()

	if self.Dragging then
		self.Dragging = false

		if self.DragEnded then
			self.DragEnded()
		end
	end
end

return DraggableObject]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXf09293a895de4d7fa7125ec75b75d1e4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Genres</string>
						<string name="ScriptGuid">{07fac29f-7832-471f-bb1e-e4a835405673}</string>
						<ProtectedString name="Source"><![CDATA[local Genres = {}

Genres.GenreConversions = {
	["rock"] = "Rock",
	["scores-orchestral"] = "Movie Music",
	["electronic"] = "EDM",
	["pop"] = "Pop",
	["atmosphere"] = "Ambient",
	["corporate"] = "Reality TV Music",
	["folk-contemporary"] = "Folk",
	["jazz"] = "Jazz",
	["ethnic-folk"] = "Folk-World",
	["hip-hop"] = "Hip-hop",
	["classical"] = "Classical",
	["children"] = "Kids",
	["kitsch-retro"] = "Kitch-Retro",
	["easy-listening"] = "Elevator Music",
	["world-beat"] = "World-Beat",
	["religious"] = "Religious",
	["funk-soul-r-b"] = "R&B",
	["latin"] = "Latin",
	["country"] = "Country",
	["ethnic-pop"] = "World-Pop",
	["blues"] = "Blues",
	["Phonk"] = "Phonk",
}

Genres.EmotionConversions = {
	["Dance"] = "Dance_music",
	["Exciting"] = "Exciting_music",
	["Angry"] = "Angry_music",
	["Chill"] = "Tender_music",
	["Happy"] = "Happy_music",
	["Scary"] = "Scary_music",
	["Sad"] = "Sad_music",
	["Laid Back"] = "New-age_music",
}
Genres.EmotionConversionsReversal = {
	["Dance_music"] = "Dance",
	["Exciting_music"] = "Exciting",
	["Angry_music"] = "Angry",
	["Tender_music"] = "Chill",
	["Happy_music"] = "Happy",
	["Scary_music"] = "Scary",
	["Sad_music"] = "Sad",
	["New-age_music"] = "Laid Back",
}

return Genres]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX96dbaed1275d445789f737e496d01bfa">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Images</string>
						<string name="ScriptGuid">{d7cad29d-f5c2-4071-a854-0b7d67a32146}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 11:27:41 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Tuesday December 19th 2023 1:11:52 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
return {
	Icons = {
		Skip = "rbxassetid://18881497118",
		Rewind = "rbxassetid://18881496575",
		Play = "rbxassetid://18881496807",
		Pause = "rbxassetid://18881496961",
		Loop = "rbxassetid://18494883282",

		Radio = "rbxassetid://134098917901689",

		Back = "rbxassetid://18619359944",
		Remove = "rbxassetid://120102783556633",
		-- Remove = "rbxassetid://18619360107",
		Emotes = "rbxassetid://18501541108",
		Shuffle = "rbxassetid://133420889460943",
		Likes = "rbxassetid://18501540967",
		LikeFill = "rbxassetid://18619231117",
		LikeOutline = "rbxassetid://18494997452",
		Library = "rbxassetid://18538854391",
		Playing = "rbxassetid://18501540591",
		Settings = "rbxassetid://18501540365",
		Queue = "rbxassetid://92846077417489",

		LikedImage = "rbxassetid://18952672240",
		UnlikedImage = "rbxassetid://18925349461",
		PlaylistAdd = "rbxassetid://18648211687",
	},
	Trading = {
		LeftPanel = "rbxassetid://14473079256",
		RightPanel = "rbxassetid://14473107622",
	},
}]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXe64f7572c07e42f7b5fcfe83239946db">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Instween</string>
						<string name="ScriptGuid">{29e2c8fa-3fb2-432c-8b4a-5219c095a798}</string>
						<ProtectedString name="Source"><![CDATA[--[[
Tween

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = Tween.TopLevel('foo')
    print(foobar.Thing)

DESCRIPTION

    A detailed description of the module.

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of Tween.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

--// module
local Tween = {}

function Tween.new(Object: Instance, Changes: table, Time: number, Settings: table)
	Settings = Settings or {}

	if Settings.Reversing then
		local test = if Settings.Reversing ~= nil then Settings.Reversing else false
	end

	local Info = TweenInfo.new(
		Time,
		Settings.EasingStyle or Enum.EasingStyle.Linear, -- EasingStyle
		Settings.EasingDirection or Enum.EasingDirection.Out, -- EasingDirection
		Settings.TimesRepeated or 0, -- Times repeteated
		if Settings.Reversing ~= nil then Settings.Reversing else false, -- Reversing
		Settings.Delay or 0 -- Time Delay
	)
	local Action = TweenService:Create(Object, Info, Changes)
	return Action
end

return Tween]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXf59a7ab047f147dfa5d70972040b9bd6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Luminance</string>
						<string name="ScriptGuid">{1f94ff19-120b-45ee-bd06-503160ffd14f}</string>
						<ProtectedString name="Source"><![CDATA[return function(color, opacity)
	-- Default opacity to 1
	opacity = opacity or 1

	-- Extract the RGB components from the Color3 value
	local red = color.R
	local green = color.G
	local blue = color.B

	-- Adjust the RGB components based on opacity
	red = red * opacity + (1 - opacity)
	green = green * opacity + (1 - opacity)
	blue = blue * opacity + (1 - opacity)

	-- Calculate the luminance
	local luminance = 0.299 * red + 0.587 * green + 0.114 * blue

	-- If luminance is greater than 0.5, use black text; otherwise, use white text
	if luminance > 0.5 then
		return Color3.new(0, 0, 0) -- Black
	else
		return Color3.new(1, 1, 1) -- White
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX48a6194168de4b15b1e0c7031d20cefe">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MatteColor</string>
						<string name="ScriptGuid">{33c8924b-21ec-4ac0-b136-6269264a16ee}</string>
						<ProtectedString name="Source"><![CDATA[-- Matte Color Generator
local function generateMatteColor()
	-- Generate random RGB values with low saturation for a matte effect
	local red = math.random(0.2 * 255, 0.7 * 255) / 255
	local green = math.random(0.2 * 255, 0.7 * 255) / 255
	local blue = math.random(0.2 * 255, 0.7 * 255) / 255

	-- Slightly reduce the brightness to make the color more muted
	local brightnessFactor = 0.8
	red = red * brightnessFactor
	green = green * brightnessFactor
	blue = blue * brightnessFactor

	-- Return the Color3 value
	return Color3.new(red, green, blue)
end

return generateMatteColor]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2721714e26c540768cc2ae43925db1eb">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PastelColor</string>
						<string name="ScriptGuid">{a3754529-c087-48e9-a8ab-498b51dfa3a0}</string>
						<ProtectedString name="Source"><![CDATA[-- Pastel Color Generator
local function generatePastelColor()
	-- Base color (random values between 0 and 1)
	local baseRed = math.random()
	local baseGreen = math.random()
	local baseBlue = math.random()

	-- Mix with white to create pastel effect
	local pastelRed = (baseRed + 1) / 2
	local pastelGreen = (baseGreen + 1) / 2
	local pastelBlue = (baseBlue + 1) / 2

	-- Return Color3 value
	return Color3.new(pastelRed, pastelGreen, pastelBlue)
end

return generatePastelColor]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX9844396857ec43c4952317bb6e1f2f5a">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">PlayerFromId</string>
						<string name="ScriptGuid">{8083bd6b-4a2d-4561-8a54-750c2c78eefc}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday April 26th 2024 10:45:07 am CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Friday April 26th 2024 12:00:00 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
local Players = game:GetService("Players")

return function(Id: string)
	for i, p: Player in ipairs(Players:GetPlayers()) do
		if p.Name == Id then
			return p
		end
	end

	return false
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXd992b0ff5fae4274bf134f7c54a78e79">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Screen</string>
						<string name="ScriptGuid">{14a460fe-8ea8-463e-8444-acb8367d361a}</string>
						<ProtectedString name="Source"><![CDATA[return function()
	local Camera = workspace.CurrentCamera
	local ScreenSize = {}

	ScreenSize.width = Camera.ViewportSize.X
	ScreenSize.height = Camera.ViewportSize.Y

	return ScreenSize
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXcd36c3efa0e24e4fa188ce15411505a2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Search</string>
						<string name="ScriptGuid">{cf3fdbb2-b61e-48b2-a7f3-91044248563d}</string>
						<ProtectedString name="Source"><![CDATA[local Module = {}

local Genere = require(script.Parent.Genres)
local TimeSorter = require(script.Parent.TimeSorter)

-- Function to split a string into lowercase words
function Module.splitStringToLower(str)
	local words = {}
	for word in str:gmatch("%w+") do
		table.insert(words, word:lower())
	end
	return words
end

-- Function to search songs based on query term
function Module.searchSongs(queryTerm, songs)
	local keywords = Module.splitStringToLower(queryTerm)
	local results = {}

	for _, song in songs do
		local description = (song.asset_description or ""):lower()
		local genre = (song.asset_audio_details_music_genre or ""):lower()
		local tags = (song.asset_audio_details_music_genre or ""):lower()
		local name = song.asset_name:lower()
		local match = false

		for _, keyword in keywords do
			if genre:find(keyword) or description:find(keyword) or name:find(keyword) then
				match = true
				break
			end
		end

		if match then
			table.insert(results, song)
		end
	end

	return TimeSorter(results)
end

function Module.searchFromTag(queryTerm, songs)
	local results = {}

	for _, song in songs do
		if not song.asset_audio_details_tags then
			continue
		end
		local tags = song.asset_audio_details_tags:split(",")
		local reversalTerm = Genere.EmotionConversions[queryTerm]
		local match = false

		if not reversalTerm then
			continue
		end

		if table.find(tags, reversalTerm) then
			table.insert(results, song)
		end
	end

	return TimeSorter(results)
end

function Module.getPillsFromTags(songs)
	local results = {}
	local ResultsDictionary = {}

	for _, song in songs do
		local match = false

		if not song.asset_audio_details_tags then
			continue
		end

		local tags = song.asset_audio_details_tags:split(",")

		for Tag, TagReversal in Genere.EmotionConversionsReversal do
			local Found = table.find(tags, Tag)
			if Found and not ResultsDictionary[TagReversal] then
				ResultsDictionary[TagReversal] = true

				table.insert(results, TagReversal)

				match = true
				break
			end
		end
	end

	return results
end

return Module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX09a42e7b44164f679c9c1dcfa38b69ed">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Sounds</string>
						<string name="ScriptGuid">{741b88c5-cd58-4f2c-a29d-e324222c50e6}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:51:40 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Saturday March 16th 2024 8:15:47 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--[[
Sounds

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = Sounds.TopLevel('foo')
   

DESCRIPTION

    A detailed description of the module.

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of Sounds.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Packages
local Maid = require(ReplicatedStorage.BoomBoxPackages.Maid)

--// Class
local Sounds = {}
Sounds.__index = Sounds

function Sounds.new()
	local SoundDictionary = {
		Click = "rbxassetid://12313312",
		_maid = Maid.new(),
	}
	setmetatable(SoundDictionary, Sounds)
	return SoundDictionary
end

function Sounds:Play(SoundName: string)
	if true then
		return
	end
	local targetSound = self[SoundName]

	if not targetSound then
		return warn(SoundName .. " does not exist.")
	end

	local SoundEndedConnection
	local Sound = Instance.new("Sound")
	Sound.SoundId = targetSound

	Sound:Play()

	SoundEndedConnection = Sound.Ended:Connect(function()
		Sound:Destroy()
		SoundEndedConnection:Disconnect()
	end)
end

function Sounds:Disconnect()
	for _, c: RBXScriptConnection in pairs(self.Connections) do
		c:Disconnect()
	end
end

function Sounds:Destroy()
	self:Disconnect()

	setmetatable(self, nil)
	table.clear(self)
	table.freeze(self)
end

return Sounds]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX56f33abefa214bfb9fe5b72a510b15d8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TimeSorter</string>
						<string name="ScriptGuid">{ff2edd22-96bc-4a6f-a8d0-63ed86bf054d}</string>
						<ProtectedString name="Source"><![CDATA[-- liked_at_sorter.lua

local liked_at_sorter = {}

-- Function to convert ISO 8601 liked_at to a comparable format
local function parse_liked_at(ts)
	local pattern = "(%d+)-(%d+)-(%d+)T(%d+):(%d+):(%d+).(%d+)Z"
	local year, month, day, hour, min, sec, msec = ts:match(pattern)
	return os.time({ year = year, month = month, day = day, hour = hour, min = min, sec = sec }) + (msec / 1000)
end

-- Function to sort a dictionary of dictionaries by liked_ats and return a sorted array
function liked_at_sorter.sort_by_liked_at(data)
	-- Extract keys and sort them based on liked_ats
	local keys = {}
	for k in pairs(data) do
		table.insert(keys, k)
	end

	table.sort(keys, function(a, b)
		return parse_liked_at(data[a].liked_at) > parse_liked_at(data[b].liked_at)
	end)

	-- Create a sorted array
	local sorted_array = {}
	for _, k in ipairs(keys) do
		table.insert(sorted_array, data[k])
	end

	return sorted_array
end

return liked_at_sorter.sort_by_liked_at]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2f0c3563b86c40e1940851ebc7dd5c9c">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Tweens</string>
						<string name="ScriptGuid">{2b8408ec-4ca9-47e8-affd-d8391452dd7e}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Friday September 22nd 2023 10:36:56 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Thursday July 4th 2024 8:37:18 am CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]

local Settings = {
	DefaultTransitionTime = 0.75,
	DefaultContentDelay = 0.3,
}

local Tweens = {

	DefaultTransitionTime = Settings.DefaultTransitionTime,
	DefaultContentDelay = Settings.DefaultContentDelay,
	Default = TweenInfo.new(
		Settings.DefaultTransitionTime,
		Enum.EasingStyle.Sine,
		Enum.EasingDirection.InOut,
		0,
		false,
		0
	),
	Toon = TweenInfo.new(
		Settings.DefaultTransitionTime,
		Enum.EasingStyle.Back,
		Enum.EasingDirection.InOut,
		0,
		false,
		0
	),
}

Tweens.Fast =
	TweenInfo.new(Settings.DefaultTransitionTime / 5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, 0)

Tweens.ToonMedium =
	TweenInfo.new(Settings.DefaultTransitionTime / 2.5, Enum.EasingStyle.Back, Enum.EasingDirection.InOut, 0, false, 0)

Tweens.ToonFast =
	TweenInfo.new(Settings.DefaultTransitionTime / 5, Enum.EasingStyle.Back, Enum.EasingDirection.InOut, 0, false, 0)

Tweens.RadialMenuTransitionTime = Settings.DefaultTransitionTime / 1.5

function Tweens.modifyTween(
	_BaseStyle: string,
	Changes: {
		Time: number?,
		EasingStyle: Enum.EasingStyle?,
		EasingDirection: Enum.EasingDirection?,
		RepeatCount: number?,
		Reverses: boolean?,
		DelayTime: number?,
	},
	SaveName: string?
)
	local BaseStyle = Tweens[_BaseStyle]

	local NewTween = TweenInfo.new(
		Changes.Time or BaseStyle.Time,
		Changes.EasingStyle or BaseStyle.EasingStyle,
		Changes.EasingDirection or BaseStyle.EasingDirection,
		Changes.RepeatCount or BaseStyle.RepeatCount,
		Changes.Reverses or BaseStyle.Reverses,
		Changes.DelayTime or BaseStyle.DelayTime
	)

	if SaveName then
		Tweens[SaveName] = NewTween
	end

	return NewTween
end

Tweens.WindowTime = Tweens.Toon.Time / 2.5

local TweenService = game:GetService("TweenService")

function Tweens.new(Object: Instance, Changes: table, Time: number, Settings: table)
	Settings = Settings or {}

	if Settings.Reversing then
		local test = if Settings.Reversing ~= nil then Settings.Reversing else false
	end

	local Info = TweenInfo.new(
		Time,
		Settings.EasingStyle or Enum.EasingStyle.Linear, -- EasingStyle
		Settings.EasingDirection or Enum.EasingDirection.Out, -- EasingDirection
		Settings.TimesRepeated or 0, -- Times repeteated
		if Settings.Reversing ~= nil then Settings.Reversing else false, -- Reversing
		Settings.Delay or 0 -- Time Delay
	)
	local Action = TweenService:Create(Object, Info, Changes)
	return Action
end

return Tweens]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX622a097a1e94438788eac64ca04afca5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">UICorner</string>
						<string name="ScriptGuid">{5e5b814d-347f-4d72-b860-889e41a30bea}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Monday September 18th 2023 1:09:04 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Saturday March 16th 2024 8:15:47 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--[[
UICorner

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = UICorner.TopLevel('foo')
   

DESCRIPTION

    A module for creating relatively scaled ui strokes

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of UICorner.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Private Functions
local function GetAverage(vector: Vector2): number
	return (vector.X + vector.Y) / 2
end

--// Variables
local STUDIO_SCREEN_SIZE = Vector2.new(1366, 767) -- change 0, 0 to your studio resolution
local camera: Camera = workspace.Camera

local studioAverage = GetAverage(STUDIO_SCREEN_SIZE)
local currentScreenAverage = GetAverage(camera.ViewportSize)

--// Variable-reliant Private Functions
local function AdjustCornerRadius(OriginalCornerRadius: number)
	local ratio = OriginalCornerRadius / studioAverage
	return currentScreenAverage * ratio
end

local function ModifyUICorners(args: any)
	currentScreenAverage = GetAverage(camera.ViewportSize) -- re-calculate the screen average as it could've changed
	return AdjustCornerRadius(args)
end

--// Module
local UICorner = function(_CornerRadius: number)
	local ratio = (_CornerRadius or 1) / studioAverage
	local CornerRadius = currentScreenAverage * ratio

	return CornerRadius
end

return UICorner]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXf549ce08b44e4ff480dc4667796e7f4b">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">UIStroke</string>
						<string name="ScriptGuid">{2e0eb025-150c-40f5-bbeb-c382ba6aeeaa}</string>
						<ProtectedString name="Source"><![CDATA[--[[
--Created Date: Monday September 18th 2023 1:09:04 pm CEST
--Author: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
-------
--Last Modified: Saturday March 16th 2024 8:15:47 pm CEST
--Modified By: Trendon Robinson at <The_Pr0fessor (Rbx), @TPr0fessor (Twitter)>
--]]
--[[
UIStroke

    A short description of the module.

SYNOPSIS

    -- Lua code that showcases an overview of the API.
    local foobar = UIStroke.TopLevel('foo')
   

DESCRIPTION

    A module for creating relatively scaled ui strokes

API

    -- Describes each API item using Luau type declarations.

    -- Top-level functions use the function declaration syntax.
    function ModuleName.TopLevel(thing: string): Foobar

    -- A description of Foobar.
    type Foobar = {

        -- A description of the Thing member.
        Thing: string,

        -- Each distinct item in the API is separated by \n\n.
        Member: string,

    }
]]

-- Implementation of UIStroke.

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Private Functions
local function GetAverage(vector: Vector2): number
	return (vector.X + vector.Y) / 2
end

--// Variables
local STUDIO_SCREEN_SIZE = Vector2.new(1366, 767) -- change 0, 0 to your studio resolution
local camera: Camera = workspace.Camera

local studioAverage = GetAverage(STUDIO_SCREEN_SIZE)
local currentScreenAverage = GetAverage(camera.ViewportSize)

--// Variable-reliant Private Functions
local function AdjustThickness(OriginalThickness: number)
	local ratio = OriginalThickness / studioAverage
	return currentScreenAverage * ratio
end

local function ModifyUiStrokes(args: any)
	currentScreenAverage = GetAverage(camera.ViewportSize) -- re-calculate the screen average as it could've changed
	return AdjustThickness(args)
end

--// Module
local UIStroke = function(_Thickness: number)
	local ratio = (_Thickness or 1) / studioAverage
	local Thickness = currentScreenAverage * ratio

	return Thickness
end

return UIStroke]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX006dc1c9095642ccb3059e6e664db004">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Viewport</string>
						<string name="ScriptGuid">{0e9154f3-8a2d-4659-8a78-9554eff9391c}</string>
						<ProtectedString name="Source"><![CDATA[local CurrentCamera = workspace.CurrentCamera
local Module = {
	Subscriptions = {},
}

CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	for i, v in pairs(Module.Subscriptions) do
		v(CurrentCamera.ViewportSize)
	end
end)

return function(cb: () -> nil)
	table.insert(Module.Subscriptions, cb)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>